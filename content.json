[{"title":"","date":"2017-07-19T15:04:59.000Z","path":"2017/07/19/AlgoAndMath/","text":"leetcode 算法集锦 主要是牛客网上 leetcode 的算法题实践. 在 Blog 包含自己的解法和对别人优秀解法的分析. 序号 考点 题目 C/C++ Java 01 树 Minimum Depth of Binary Tree NULL 题解 02 栈 evaluate-reverse-polish-notation NULL 题解 02 : evaluate-reverse-polish-notation Evaluate the value of an arithmetic expression in Reverse Polish Notation.Valid operators are+,-,*,/. Each operand may be an integer or another expression. Some examples: [“2”, “1”, “+”, “3”, ““] -&gt; ((2 + 1) 3) -&gt; 9 [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6 我的解法 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Stack;public class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;String&gt; s = new Stack&lt;&gt;(); int op1 = 0; int op2 = 0; for (int i = 0; i &lt; tokens.length; i++) &#123; switch (tokens[i]) &#123; case \"+\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 + op1)); break; &#125; case \"-\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 - op1)); break; &#125; case \"*\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 * op1)); break; &#125; case \"/\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 / op1)); break; &#125; default: &#123; s.push(tokens[i]); break; &#125; &#125; &#125; return Integer.parseInt(s.pop()); &#125;&#125; 其他解法 12345678910111213141516171819202122232425262728293031import java.util.Stack;public class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i = 0;i&lt;tokens.length;i++)&#123; try&#123; int num = Integer.parseInt(tokens[i]); stack.add(num); &#125;catch (Exception e) &#123; int b = stack.pop(); int a = stack.pop(); stack.add(get(a, b, tokens[i])); &#125; &#125; return stack.pop(); &#125; private int get(int a,int b,String operator)&#123; switch (operator) &#123; case \"+\": return a+b; case \"-\": return a-b; case \"*\": return a*b; case \"/\": return a/b; default: return 0; &#125; &#125;&#125; 01 : Minimum Depth of Binary Tree Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 我的解法 123456789101112131415深度优先遍历所有节点, 直至叶子节点后返回长度. 每次取当前节点左右子节点的 [最小值+1] 为该节点的最小深度. public class Solution &#123; public int run(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int length1 = run(root.left); int length2 = run(root.right); if (length1 == 0 || length2 == 0) &#123; return length1 + length2 + 1; &#125; return Math.min(length1, length2) + 1; &#125;&#125; 其他思路 1234567891011121314151617181920212223242526class Solution &#123;public: typedef TreeNode* tree; int run(TreeNode *root) &#123; //采用广度优先搜索，或者层序遍历，找到的第一个叶节点的深度即是最浅。 if(! root) return 0; queue&lt;tree&gt; qu; tree last,now; int level,size; last = now = root; level = 1;qu.push(root); while(qu.size())&#123; now = qu.front(); qu.pop(); size = qu.size(); if(now-&gt;left)qu.push(now-&gt;left); if(now-&gt;right)qu.push(now-&gt;right); if(qu.size()-size == 0)break; if(last == now)&#123; level++; if(qu.size())last = qu.back(); &#125; &#125; return level; &#125;&#125;;","tags":[]},{"title":"Android Blog Collection","date":"2017-07-08T03:27:00.000Z","path":"2017/07/08/AndroidBlogCollection/","text":"this repo aims to collect some high quality basic knowledge Android Blog. Just like source code analysis or something. 这个仓库致力于收集我在学习 Android 开发过程所遇到的高质量的基础知识文章. 类似于源码分析之类的, 可以帮大家加深对基础原理的理解. 0. Start&gt; 前言 现在网络上有太多的知识可供学习, 但是作为一个自学者, 是好事也是坏事, 好事指不用担心没资源, 坏事是指对学习效率,理解程度和知识体系搭建都不太好.网上的文章不全是高质量的, 而且很多都是重复的碎片化知识,大家写的都差不多.所以为了自己的系统学习, 建议买书, 碰到哪个模块不懂再找大牛的 Blog 加深理解. 所以可以看到我推荐的基本都是成一个小体系的系列文章, 可以帮助我们形成一个好的”学习思维树”. 而不是一大堆”散叶”. 而其他文章主要是作为自己加深理解, 对某个知识点深入学习的参考. 首先可以肯定像我这种刚刚入门的在写文章的高度和视野都不如大牛. 而对于基础的知识,特别是涉及源码解析, 只要以一份资料为主就可以了. 最多加一两份做参考. 所以, 基本这种类型的文章, 我会收藏整理在这篇文章里并且永久更新. 同时自己也会利用课余时间把自己的实践项目以一个入门的学习者的视角解析, 相信这样对初学的开发者是比较友好的.如果你和我也一样处在这个阶段, 欢迎关注这篇文章. 这里永久更新这类基础知识解读. GitHub 和 Blog 永久更新练习项目. 如果对你有帮助欢迎 Star ^_^; &gt; 更新 v3 : 敬请期待… v2 : 添加 JVM 设计模式 常用框架 计算机基础 四大模块优质 Blog 收集 v1 : 以 Android View 基础知识为主的 Blog 收集. 1. UI&gt; View 的绘制源码解析 这里推荐的是Carson_Ho的一系列源码分析教程, 主要是从 View 和 ViewGroup 的测量, 布局和绘制过程进行详细分析, 很多图示十分清晰易懂, 对于初学者和进阶者都是很不错的学习资料. 如果有找到其他的好的教程我还会继续加上. 自定义View基础 - 最易懂的自定义View原理系列(1) 自定义View Measure过程 - 最易懂的自定义View原理系列(2) 自定义View Layout过程 - 最易懂的自定义View原理系列(3) 自定义View Draw过程- 最易懂的自定义View原理系列(4) 前面给了 View 的绘制最主要的三个过程进行了详细分析的 Blog, 在前面的阅读基础上,下面给出郭霖大神的 View 的工作原理系列文章. 相信在读完以下四篇文章之后你会对 View 有一个重新认识的. Android LayoutInflater原理分析，带你一步步深入了解View(一) Android视图绘制流程完全解析，带你一步步深入了解View(二) Android视图状态及重绘流程分析，带你一步步深入了解View(三) Android自定义View的实现方法，带你一步步深入了解View(四) 下面介绍扔物线的HenCoder：给高级 Android 工程师的进阶手册, 包含了视频讲解. 目前持续更新, 在学习完前面的 Blog 并进行了部分实践 Demo 后把这当做复习提高挺不错的, 同时我也会一直关注并更新. HenCoder Android 开发进阶: 自定义 View 1-1 绘制基础 &gt; View 相关类解析 这个主要是介绍一些对自定义 View 过程中需要仔细了解的一些类的使用. Path类的最全面详解 - 自定义View应用系列 Canvas类的最全面详解 - 自定义View应用系列 &gt; XML 使用示例 这里推荐Keegan小钢的Android样式的开发相关教程, 通过十分简洁的小例子帮你快速实现对 XML 的了解和使用. Android样式的开发:shape篇 Android样式的开发:selector篇 Android样式的开发:layer-list篇 Android样式的开发:drawable汇总篇 Android样式的开发:View Animation篇 Android样式的开发:Property Animation篇 Android样式的开发:Style篇 &gt; 动画 Android 动画介绍, 感谢阿祥JOKER 分享. Android动画解析 重点!!!这里还是推荐郭霖大神的文章. 然后后面补充一篇偏知识点式的文章供复习. Android属性动画完全解析(上)，初识属性动画的基本用法 Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法 Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法 补充参考:Android动画，一篇就够, 感谢Shaun白一辰的分享. &gt; 事件分发 事件分发是一个重要的知识点, 在面试中也有很大几率被问到.在开发中经常会遇到, 只有彻底理解好了在写代码时候才能思路清晰.希望以下文章能帮助你我弄清事件分发机制. Android事件分发机制详解：史上最全面、最易懂 &gt; 自成体系的 View 教程 这里主要是推荐一些其他优秀文章作为参考阅读, 同样也是自成体系的. GcsSloop : 安卓自定义View教程目录 2. Java API 这里主要是对 Java API 中的一些重要的源码解析进行收集. 同时也是面试重点, 希望能加深对 Java 的认识. 做到真的理解底层实现而不是只会使用. 由于 Java 面太广, 所以在这里主要是以知识点的形式覆盖基本概念. 这里推荐 树上月 的教程. 从 Blog 介绍看接触 Java 有一段时间, 所以分析会比较深入且正确. 更主要的是, 他把 Java 类文章基本都串起来了, 共有 38 篇可供学习. 文章太多就不一一贴链接了… 想学Java, 值得一阅 3. 浅析JVM 当然这块知识会推荐一本书, 是《深入理解 Java 虚拟机》， 而网上的那些分析大多数都是基于这本书的。这里会收集一些较好的讲解共在线阅读。 4. 深入理解设计模式 这块也有一本书《Android 源码设计模式解析与实战》推荐. Java 的 23 种设计模式全解析 5. Android 常用框架分析6. 计算机基础&gt; 数据库如果有人问你数据库的原理，叫他看这篇文章 &gt; 网络&gt; 操作系统","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"Collection","slug":"Collection","permalink":"http://fitzeng.org/tags/Collection/"}]},{"title":"Common Sense","date":"2017-07-05T02:00:00.000Z","path":"2017/07/05/tips/","text":"this aticle aims to collect some common sense when you meet during dev.这篇文章主要是记录我在 Android 开发过程中遇到的一些概念问题, 在这里提供简单快速的使用规范. 开源项目许可证MIT、GPLv2和Apache占据了前三位。choosealicense.com为许可证的选择给出了建议. MIT是一个几乎可以“为所欲为”的许可证，如果你希望简单、宽松，它是你的不二选择. 如果你关心软件的专利问题，但同样希望宽松，可以选择Apache. 如果你希望代码使用者同样能把他们的贡献分享出来，那就选择GPL. 参考","tags":[{"name":"Tips","slug":"Tips","permalink":"http://fitzeng.org/tags/Tips/"}]},{"title":"BMP压缩成JPEG过程实现与分析","date":"2017-06-12T16:00:00.000Z","path":"2017/06/13/BMP2JPEG/","text":"GitHub 前言由于最近做了图像相关的学习，所以想再深入点，但是自己的知识有限，目前只能把自己所学的通过这个小小的实验来加深理解。参考大牛的 Blog 加上自己亲手实践，写了这篇文章。以后还会继续添加图像处理的相关知识。 BMP介绍 BMP文件头文件头主要是包含一个文件的ID信息，所以BMP的文件头自然也是说明自己的文件格式，文件大小等信息，一般是14位表示。意义如下图所示： 位图信息头信息头主要是对图片特征的描述，比如说宽高，像素，压缩方式等，一般是40位。主要介绍如下表： 调色板调色板是可选的，使用索引来表示图像，调色板就是索引与其对应的颜色的映射表，这次实验选用的是24bit的图片。 位图数据这里就是存储图片的内容了。 JPEG介绍JPEG是有损压缩编码下的一种图片格式，目前压缩效果好，应用广泛。其原理主要是将传统的RGB模式下的图片转化成YCbCr格式。因为人眼的结构问题对亮度更加敏感，所以可以将亮度和色度分离开来，对色度可进行较大的舍弃从而进行较大程度的压缩而对视觉不造成太大影响。既然是压缩而成的格式，那必然有解压缩过程，而解压缩所以依赖的量化表和哈夫曼表自然要记录下来。所以和BMP对比自然而然头结构出来了，而且要比BMP复杂。下面只给出部分信息： BMP 读取 构建BMP的文件头和头信息结构体 12345678910111213141516171819202122//BMP 文件格式【文件头和头部信息】typedef struct &#123; unsigned short bfType; unsigned int bfSize; unsigned short bfReserved1; unsigned short bfReserved2; unsigned int bfOffBits;&#125; BITMAPFILEHEADER;typedef struct &#123; unsigned int biSize; int biWidth; int biHeight; unsigned short biPlanes; unsigned short biBitCount; unsigned int biCompression; unsigned int biSizeImage; int biXPelsPerMeter; int biYPelsPerMeter; unsigned int biClrUsed; unsigned int biClrImportant;&#125; BITMAPINFOHEADER; 图片校验 1234567891011121314151617181920212223242526272829303132//打开文件FILE* fp = fopen(fileName, \"rb\");if(fp==0) &#123; return false;&#125;BITMAPFILEHEADER fileHeader;BITMAPINFOHEADER infoHeader;// 读取头部 14字节if(1 != fread(&amp;fileHeader, sizeof(fileHeader), 1, fp)) &#123; return false;&#125;// 判断是不是BM类型if(fileHeader.bfType!=0x4D42) &#123; return false;&#125;// 读取头部信息 40字节if(1 != fread(&amp;infoHeader, sizeof(infoHeader), 1, fp)) &#123; return false;&#125;// 判断是不是24位类型。也就是RGB的存储格式if(infoHeader.biBitCount != 24 || infoHeader.biCompression != 0) &#123; return false;&#125;int width = infoHeader.biWidth;int height = infoHeader.biHeight &lt; 0 ? (-infoHeader.biHeight) : infoHeader.biHeight;// 判断二进制的最后三位是不是000，也就是判断是不是8的倍数if((width&amp;7) != 0 || (height&amp;7) != 0) &#123; return false;&#125; 图片内容读取 123456789101112131415161718192021222324252627// RGB三个分量int bmpSize = width*height*3;unsigned char* buffer = new unsigned char[bmpSize];if(buffer == 0) &#123; return false;&#125;// 将文件指针移到数据区域fseek(fp, fileHeader.bfOffBits, SEEK_SET);if(infoHeader.biHeight &gt; 0) &#123; for(int i = 0; i &lt; height; i++) &#123; // 读取第i行,每此读 3（size） * width （count）大小 if(width != fread(buffer + (height - 1 - i) * width * 3, 3, width, fp)) &#123; delete[] buffer; buffer = 0; return false; &#125; &#125;&#125; else &#123; if(width*height != fread(buffer, 3, width*height, fp)) &#123; delete[] buffer; buffer = 0; return false; &#125;&#125; 存储信息 1234567// 获取宽高和大小m_rgbBuffer = buffer;m_width = width;m_height = height;fclose(fp);fp=0; JPEG 写入在前期JPEG写入是，要进行一系列准备工作，根据JPEG官方提供的标准量化表和哈夫曼表进行自己的操作得到自己满意的压缩编码。 数值表： 直流分量表： 交流分量表： 下面给出具体代码： 亮度量化表 1234567891011// 亮度量化表const unsigned char Luminance_Quantization_Table[64] = &#123; 16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99&#125;; 色度量化表 1234567891011// 色度量化表const unsigned char Chrominance_Quantization_Table[64] = &#123; 17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99&#125;; 标准直流分量色度亮度哈夫曼表 12345const char Standard_DC_Luminance_NRCodes[] = &#123; 0, 0, 7, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 &#125;;const unsigned char Standard_DC_Luminance_Values[] = &#123; 4, 5, 3, 2, 6, 1, 0, 7, 8, 9, 10, 11 &#125;;const char Standard_DC_Chrominance_NRCodes[] = &#123; 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 &#125;;const unsigned char Standard_DC_Chrominance_Values[] = &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 &#125;; 标准交流分量色度亮度哈夫曼表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const char Standard_AC_Luminance_NRCodes[] = &#123; 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d &#125;;const unsigned char Standard_AC_Luminance_Values[] = &#123; 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa&#125;;const char Standard_AC_Chrominance_NRCodes[] = &#123; 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 &#125;;const unsigned char Standard_AC_Chrominance_Values[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa&#125;; 计算哈夫曼编码 123456789101112131415void JpegEncoder::_computeHuffmanTable(const char* nr_codes, const unsigned char* std_table, BitString* huffman_table) &#123; unsigned char pos_in_table = 0; unsigned short code_value = 0; for(int k = 1; k &lt;= 16; k++) &#123; for(int j = 1; j &lt;= nr_codes[k-1]; j++) &#123; huffman_table[std_table[pos_in_table]].value = code_value; huffman_table[std_table[pos_in_table]].length = k; pos_in_table++; code_value++; &#125; code_value &lt;&lt;= 1; &#125;&#125; 初始化量化表根据传入的参数调整量化程度，因为这个量化过程是有损的。所以其结果对图像质量有较大影响。 123456789101112131415161718192021222324252627282930// 初始化量化表void JpegEncoder::_initQualityTables(int quality_scale) &#123; if(quality_scale &lt;= 0) &#123; quality_scale = 1; &#125; if(quality_scale &gt;= 100) &#123; quality_scale = 99; &#125; for(int i = 0; i &lt; 64; i++) &#123; int temp = ((int)(Luminance_Quantization_Table[i] * quality_scale + 50) / 100); if (temp &lt;= 0) &#123; temp = 1; &#125; if (temp &gt; 0xFF) &#123; temp = 0xFF; &#125; m_YTable[ZigZag[i]] = (unsigned char)temp; temp = ((int)(Chrominance_Quantization_Table[i] * quality_scale + 50) / 100); if (temp&lt;=0) &#123; temp = 1; &#125; if (temp&gt;0xFF) &#123; temp = 0xFF; &#125; m_CbCrTable[ZigZag[i]] = (unsigned char)temp; &#125;&#125; 写文件头到这里文件头基本已经确定，可以写入JPEG文件了。 RGB 转化成 YCbCr每读取一个 8*8 的方块区域，就进行颜色空间转化。转换式和代码如下： 1234567891011121314151617181920212223Y= 0.299*R + 0.587*G + 0.114*BC_b= -0.168*R – 0.331*G + 0.449*BC_r= 0.5*R – 0.419*G – 0.018*B void JpegEncoder::_convertColorSpace(int xPos, int yPos, char* yData, char* cbData, char* crData) &#123; for (int y = 0; y &lt; 8; y++) &#123; // 跳行 unsigned char* p = m_rgbBuffer + (y + yPos) * m_width * 3 + xPos * 3; for (int x = 0; x &lt; 8; x++) &#123; unsigned char B = *p++; unsigned char G = *p++; unsigned char R = *p++; yData[y * 8 + x] = (char)(0.299f * R + 0.587f * G + 0.114f * B - 128); // yData[y * 8 + x] = 0; cbData[y * 8 + x] = (char)(-0.1687f * R - 0.3313f * G + 0.5f * B ); // cbData[y * 8 + x] = 0; crData[y * 8 + x] = (char)(0.5f * R - 0.4187f * G - 0.0813f * B); // crData[y * 8 + x] = 0; &#125; &#125;&#125; DCT变换和量化DCT变换式和量化代码： 12345678910111213141516171819202122232425// DCT变化 + 量化（未优化）void JpegEncoder::_forward_DCT(const char* channel_data, short* fdc_data) &#123; const float PI = 3.1415926f; for(int v = 0; v &lt; 8; v++) &#123; for(int u = 0; u &lt; 8; u++) &#123; float alpha_u = (u==0) ? 1 / sqrt(8.0f) : 0.5f; float alpha_v = (v==0) ? 1 / sqrt(8.0f) : 0.5f; float temp = 0.f; for(int x = 0; x &lt; 8; x++) &#123; for(int y = 0; y &lt; 8; y++) &#123; float data = channel_data[y * 8 + x]; data *= cos((2 * x + 1) * u * PI / 16.0f); data *= cos((2 * y + 1) * v * PI / 16.0f); temp += data; &#125; &#125; temp *= alpha_u * alpha_v / m_YTable[ZigZag[v * 8 + u]]; fdc_data[ZigZag[v*8+u]] = (short) ((short)(temp + 16384.5) - 16384); &#125; &#125;&#125; 哈夫曼编码 直流分量差分编码 123456789101112 // encode DCint dcDiff = (int)(DU[0] - prevDC);prevDC = DU[0];if (dcDiff == 0) &#123; outputBitString[index++] = HTDC[0];&#125; else &#123; BitString bs = _getBitCode(dcDiff); outputBitString[index++] = HTDC[bs.length]; outputBitString[index++] = bs;&#125; 交流分量游长编码 123456789101112131415161718192021222324252627 // encode ACsint endPos=63; //end0pos = first element in reverse order != 0while((endPos &gt; 0) &amp;&amp; (DU[endPos] == 0)) &#123; endPos--;&#125;for(int i = 1; i &lt;= endPos; ) &#123; int startPos = i; while((DU[i] == 0) &amp;&amp; (i &lt;= endPos)) &#123; i++; &#125; int zeroCounts = i - startPos; if (zeroCounts &gt;= 16) &#123; for (int j = 1; j &lt;= zeroCounts / 16; j++) &#123; outputBitString[index++] = SIXTEEN_ZEROS; &#125; zeroCounts = zeroCounts % 16; &#125; BitString bs = _getBitCode(DU[i]); outputBitString[index++] = HTAC[(zeroCounts &lt;&lt; 4) | bs.length]; outputBitString[index++] = bs; i++;&#125; 对三个通道进行以上同样的操作。（DCT变化-哈夫曼编码-写入） 1234567891011121314151617181920BitString outputBitString[128];int bitStringCounts;// Y通道压缩_forward_DCT(yData, yQuant);_doHuffmanEncoding(yQuant, prev_DC_Y, m_Y_DC_Huffman_Table, m_Y_AC_Huffman_Table, outputBitString, bitStringCounts);_write_bitstring_(outputBitString, bitStringCounts, newByte, newBytePos, fp);// Cb通道压缩_forward_DCT(cbData, cbQuant);_doHuffmanEncoding(cbQuant, prev_DC_Cb, m_CbCr_DC_Huffman_Table, m_CbCr_AC_Huffman_Table, outputBitString, bitStringCounts);_write_bitstring_(outputBitString, bitStringCounts, newByte, newBytePos, fp);// Cr通道压缩_forward_DCT(crData, crQuant);_doHuffmanEncoding(crQuant, prev_DC_Cr, m_CbCr_DC_Huffman_Table, m_CbCr_AC_Huffman_Table, outputBitString, bitStringCounts);_write_bitstring_(outputBitString, bitStringCounts, newByte, newBytePos, fp); 整个流程就是如下图所示： 实验结果测试图片 pic1.bmp 16进制 测试代码 12345678910111213const char* inputFileName = \"pic1.bmp\";JpegEncoder encoder;// 读取BMP格式的文件if(!encoder.readFromBMP(inputFileName)) &#123; return 1;&#125;// 将BMP格式的文件按照JPEG标准压缩成JPEG文件if(!encoder.encodeToJPG(\"out.jpeg\", 50)) &#123; printf(\"jpg\\n\"); return 1;&#125; 读取的BMP文件信息，大小和尺寸都符合原图 测试结果 out.jpeg 十六进制，可以和标准格式比较确实是通过BMP转成了JPEG格式 可以看到，压缩效果还是比较比较明显的，但是编码性能不是最好的，没有对数据前期进行优化，效率只是中规中矩。下面介绍对流程和结果的测试分析过程流程： 分析为什么转换成YCbCr域对色域的压缩会让人接受：从RGB到YCbCr的转换公式我们可以分析出Y所占比重较高，说明应该存储的细节相对较多，和人眼对亮度更加敏感符合。那么事实是否如此？ 从左到右依次是 Y（72.8k），Cb（37.4k），Cr（33.9k）分量，从光感上说，明显是Y的灰度图像给出了细节，其它两个分量只是给出色彩，没有细节。接着从大小分析也和我们的预测符合，大概比例是 2：1：1，说明存储的细节越多所需的空间自然越大。接下来对BMP原始通道RGB加扰动和YCbCr加相同的扰动，对图像的影响又会怎样？ 从左到右一次是在RGB通道和YCbCr通道加干扰。可以看到RGB收干扰的程度更大，原因不大好用数学分析，我觉得很可能是RGB通道对干扰是没有减弱直接进入通道转换，而YCrCb则是在色度通道进行压缩了，同时也是对干扰的舍弃，所以效果比较好。 下面分析为什么量化矩阵对结果会有很大影响，可以做一个实验，改变生成量化矩阵的算法，看看结果如何。 这两张的量化程度不同，但是可以看到的是他们都有或多或少的呈色块显示迹象，所以应该存储的空间应该是很小的。结果也确实如此，回到问题，我们的量化矩阵没有优化，造成数值过大，在量化过程中，导致过多数为0，也就是那些高频分量，而高频正是细节的体现，失去高频自然就失去了细节。所以量化矩阵的取值直接关系到了生成图像的品质。 以上是我对BMP转换成JPEG的过程分析，同时也辅以代码加以实现和测试。对于JPEG的解码过程那就是过程的逆过程了，但是由于编码是有损的，而且编码表量化表都是有转型损失的，所以解码之后的图像也会有部分损失。着呢个过程和读取解码BMP一样。先读取文件头，接下来初始化表，再就是直接读取数据根据表解码出YCbCr的值，反量化之后通过DCT逆变换还原。 其中的源码是thecodeway提供的，欢迎大家去他的 Blog 看看他的图像分析文章，我只是对他的代码加以自己的理解。 最后：如有不足，欢迎指正，共同进步。 多谢阅读 参考资料[1] 足迹 : https://www.cnblogs.com/Matrix_Yao/archive/2009/12/02/1615295.html [2] lakeone : https://www.cnblogs.com/lakeone/p/3596996.html [3] thecodeway : https://thecodeway.com/blog/?p=522 [4] SoC Design Lab http://twins.ee.nctu.edu.tw/courses/soclab_04/lab_hw_pdf/proj1_jpeg_introduction.pdf","tags":[{"name":"图像处理","slug":"图像处理","permalink":"http://fitzeng.org/tags/图像处理/"},{"name":"C/C++","slug":"C-C","permalink":"http://fitzeng.org/tags/C-C/"}]},{"title":"Android 单元测试和 Robolectric 源码解析","date":"2017-05-13T16:00:00.000Z","path":"2017/05/14/Android 单元测试和 Robolectric 源码解析/","text":"前言作为一个 Android 开发的程序员，最痛苦的事情其实莫过于测试了，龟速的模拟器和麻烦的手机，基本上每测试一次都要浪费 1-2 min 去加载程序。而有了 Robolectric 这些就可以避免了。至于 Robolectric 的介绍推荐大家看看官网 （其中的用户指导是很好的学习资料）。我们用他的很大一个原因是他不需要再去把程序加载到 Android 手机或者模拟器中运行，他有自己的实现，能够调用 Android 中的很多库，下面的源码分析会提及。可是 Android Studio 对 Robolectric 不是很友好，而且在 Google 的官方教程中的测试工具也不是这个。。。同时 Robolectric 对于 Android Studio 的教程介绍似乎还是停留在 1.x 阶段，但是在 2.x 中的使用略有不同。 讲了这么多，所以 Robolectric 和 Junit 4 有什么不同？不都是测试吗？我的理解是 Junit 4 与 Robolectric 的关系和 Java 与 Android 的关系差不多。毕竟 Robolectric 是个第三方的测试库，其中很多还是要用到 Junit 的。 好了，基本的介绍完成了，下面开始使用，但是使用不是我们这次的重点，重点是源码分析。但是源码分析也是建立在知道使用的基础上，如果你之前没有使用过，推荐你看官方的 user guide。或者这两篇 Blog。 Android单元测试框架Robolectric3.0介绍(一) Android单元测试框架Robolectric3.0介绍(二) 准备其实前面 Blog 的介绍可能会有点偏差，现在的 Android Studio 2.3.1 在建立工程时除了自己的源码包，还有两个，分别是 test 和 androidTest。经过我的尝试， test 包下的测试文件可以直接测试，而 androidTest下面的还是要 android 运行环境的。个人更倾向于一个用做单元测试一个用于集成测试这种理解。所以在导入依赖包时要注意了。 121. testCompile \"org.robolectric:robolectric:3.3.2\"2. androidTestCompile \"org.robolectric:robolectric:3.3.2\" 第一种对应的测试文件要放在 test 包下，而第二种就是放在 androidTest 包下，如果搞错，你的 Robolectric 中的测试方法是无法使用的。 123456789101112dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support.constraint:constraint-layout:1.0.2' testCompile 'junit:junit:4.12' testCompile 'org.robolectric:robolectric:3.3.2' sourceCompatibility = 1.8 targetCompatibility = 1.8&#125; 至于运行的话，大家可以直接右键文件，title bar 点击运行或者在 cmd 运行都行。但是有一点要注意，一定要配置文件的 working directory，不然找不到 manifest.xml 等文件。 测试写一个如下布局 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"org.fitzeng.robolectrictest.MainActivity\"&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:id=\"@+id/et\" android:text=\"@string/app_name\" android:maxLines=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;Button android:id=\"@+id/btn_et\" android:text=\"EditText Test\" android:textAllCaps=\"false\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 1234567891011121314151617181920212223242526272829303132public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private EditText editText; private Button btnEt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); &#125; private void initViews() &#123; editText = (EditText) findViewById(R.id.et); btnEt = (Button) findViewById(R.id.btn_et); btnEt.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_et: &#123; btnEt.setText(editText.getText().toString()); break; &#125; default: break; &#125; &#125;&#125; 可以看到，这里就是测试一下点击事件，看看点击之后是否能获取 EditText 中的文本内容。 下面开始写测试代码，注意之前如果配置的是 testCompile 的话一定要把测试文件建在 test 包下，不然无法导入 Robolectric 。 1234567891011121314151617181920212223242526272829@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class, sdk = 24)public class MainActivityTest &#123; private Button btnEt; private EditText editText; @Before public void setUp() &#123; // get mainActivity obj MainActivity mainActivity = Robolectric.setupActivity(MainActivity.class); // get button btnEt = (Button) mainActivity.findViewById(R.id.btn_et); // get edittext editText = (EditText) mainActivity.findViewById(R.id.et); &#125; @Test public void testMainActivity() &#123; // simulate click event btnEt.performClick(); // get button content String expectedContent = btnEt.getText().toString(); // get edittext content String actualContent = editText.getText().toString(); // compare expectedContent and actualContent Assert.assertEquals(expectedContent, actualContent); &#125;&#125; 上面的代码我都加了注释，基本过程很清楚了，这里点击事件是只要点击，我们就把 EditText 中的文本替换 Button 的文本。测试结果如下：可以看到花的 27s 完成了点击测试，很方便。大家可以试试测试失败会是什么情况。 这里并没有开启模拟器，但是却完成了整个点击事件并进行了检测。事件虽小，但是意义很大。意味着我们不需要开启模拟器也可以对 Android 程序进行测试了。 源码分析在开始这个流程的分析之前，如果你之前对 Junit 没有任何了解，可以看看 Junit 的分析，这里仿照 Junit 对 Robolectric 进行类比分析。可以找到 Junit 的 main 入口下面一步一步分析就好了。 但是 Robolectric 代码量实在太大，去里面找东西实在太难，但是凭借程序员的直觉，相信大家最先找到的有价值的文件可能是下面几个：其中看到测试生命周期是不是眼前一亮？还有 Robolectric 类里面的函数，包含了 Fragment， AttributeSet， Activity， Service， IntentService， ContentProvider 等等熟悉的内容。可以肯定，这里就是“宇宙中心”。上面的测试代码其实也验证了这个观点。再看看 RobolectricTestRunner 这个类，还是和 Junit 4 有一腿的。里面的方法无非就是做一些初始化的工作，注释说的很明确了，就是提供一个模拟的 Android 运行时环境（和前面说的加载 manifest文件有关），这也是为什么可以直接在没有模拟器的情况下进行一些模拟点击测试的原因。 123456789/** * Installs a &#123;@link SandboxClassLoader&#125; and &#123;@link ResourceTable&#125; in order to * provide a simulation of the Android runtime environment. */// public class RobolectricTestRunner extends SandboxTestRunner// public class SandboxTestRunner extends BlockJUnit4ClassRunner// public class BlockJUnit4ClassRunner extends ParentRunner&lt;FrameworkMethod&gt;// public abstract class ParentRunner&lt;T&gt; extends Runner implements Filterable,Sortable// public abstract class Runner implements Describable 这样没有实例只看源码有点不知道往哪个方向解析，所以我们开始从源码角度看看前面测试过程怎么执行的来加深理解。 最开始是调用了 Robolectric.setupActivity(Class) 那么我们就从这里入手。 step 1 : Robolectric.setupActivity(Class)123public static &lt;T extends Activity&gt; T setupActivity(Class&lt;T&gt; activityClass) &#123; return buildActivity(activityClass).setup().get();&#125; 首先是获取 Activity 对象，正好 setUpActivity(Class) 是返回一个 Activity 对象的。那么是如何获取到的呢？那就要看源码具体实现了。大概过程是建立一个 Activity 然后 setup 一下再获取对象。 step 2.1 : Robolectric.buildActivity(Class)123public static &lt;T extends Activity&gt; ActivityController&lt;T&gt; buildActivity(Class&lt;T&gt; activityClass) &#123; return buildActivity(activityClass, null);&#125; step 2.2 : Robolectric.buildActivity(Class, Intent)123public static &lt;T extends Activity&gt; ActivityController&lt;T&gt; buildActivity(Class&lt;T&gt; activityClass, Intent intent) &#123; return ActivityController.of(getShadowsAdapter(), ReflectionHelpers.callConstructor(activityClass), intent);&#125; 到这里就可以看到利用这个类名和 Intent （null），采用反射机制可以获取这个类的对象。有兴趣的还可以深究下去。 step 3.1 : Robolectric.buildActivity(activityClass).setup()12345678910111213141516171819202122/*** Calls the same lifecycle methods on the Activity called by Android the first time the Activity is created.** @return Activity controller instance.*/public ActivityController&lt;T&gt; setup() &#123; return create().start().postCreate(null).resume().visible();&#125;/** * Calls the same lifecycle methods on the Activity called by Android when an Activity is restored from previously saved state. * * @param savedInstanceState Saved instance state. * @return Activity controller instance. */public ActivityController&lt;T&gt; setup(Bundle savedInstanceState) &#123; return create(savedInstanceState) .start() .restoreInstanceState(savedInstanceState) .postCreate(savedInstanceState) .resume() .visible();&#125; 前面的两个函数的注释很清楚，第一个是 Activity 第一次调用时调用，第二个是 Activity 之前被调用过并且在 Bundle 对象中保存了实例状态，可以将 Bundle 中的数据作为参数直接调用函数加载。返回的是一个 Activity 控制器实例。 step 3.2 : setup() -&gt; create().start().postCreate(null).resume().visible()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ActivityController.create()public ActivityController&lt;T&gt; create() &#123; return create(null);&#125;public ActivityController&lt;T&gt; create(final Bundle bundle) &#123; shadowMainLooper.runPaused(new Runnable() &#123; @Override public void run() &#123; ReflectionHelpers.callInstanceMethod(Activity.class, component, \"performCreate\", from(Bundle.class, bundle)); &#125; &#125;); return this;&#125;ActivityController.start()public ActivityController&lt;T&gt; start() &#123; invokeWhilePaused(\"performStart\"); return this;&#125;ActivityController.postCreate(Bundle)public ActivityController&lt;T&gt; postCreate(Bundle bundle) &#123; invokeWhilePaused(\"onPostCreate\", from(Bundle.class, bundle)); return this;&#125;ActivityController.resume()public ActivityController&lt;T&gt; resume() &#123; invokeWhilePaused(\"performResume\"); return this;&#125;ActivityController.visible()public ActivityController&lt;T&gt; visible() &#123; shadowMainLooper.runPaused(new Runnable() &#123; @Override public void run() &#123; ReflectionHelpers.setField(component, \"mDecor\", component.getWindow().getDecorView()); ReflectionHelpers.callInstanceMethod(component, \"makeVisible\"); &#125; &#125;); ViewRootImpl root = component.getWindow().getDecorView().getViewRootImpl(); if (root != null) &#123; // If a test pause thread before creating an activity, root will be null as runPaused is waiting // Related to issue #1582 Display display = Shadow.newInstanceOf(Display.class); Rect frame = new Rect(); display.getRectSize(frame); Rect insets = new Rect(0, 0, 0, 0); final RuntimeAdapter runtimeAdapter = RuntimeAdapterFactory.getInstance(); runtimeAdapter.callViewRootImplDispatchResized( root, frame, insets, insets, insets, insets, insets, true, null); &#125; return this;&#125; 这里看起来代码量有点多，但是大概意思应该就是为 Activity 提供一个 Android 运行环境的保障。从 Window ， DecorView 之类的就可以确认我们的想法。如果不熟悉的话可以再去了解 Android 的界面绘制过程，这里目前知道这层意思就可以了。 step 4 : Robolectric.buildActivity(activityClass).setup().get()123public T get() &#123; return component;&#125; 。。。我看到这里首先的感觉是一脸懵逼，怎么这么简单，我们的预期是返回一个 Activity 对象，也就是一个组件，从意思来看可以理解，但是这个 component 是怎么来的？下面就来慢慢分析。 1234567891011121314151617181920212223242526public abstract class ComponentController&lt;C extends ComponentController&lt;C, T&gt;, T&gt; &#123; protected final C myself; protected T component; protected final ShadowLooperAdapter shadowMainLooper; protected Intent intent; protected boolean attached; @SuppressWarnings(\"unchecked\") public ComponentController(ShadowsAdapter shadowsAdapter, T component, Intent intent) &#123; this(shadowsAdapter, component); this.intent = intent; &#125; @SuppressWarnings(\"unchecked\") public ComponentController(ShadowsAdapter shadowsAdapter, T component) &#123; myself = (C) this; this.component = component; shadowMainLooper = shadowsAdapter.getMainLooper(); &#125; public T get() &#123; return component; &#125;&#125; 看到这里我们可以确认的是 component 是来自 ComponentController() 构造函数来进行初始化的，这是你会发祥一个很熟悉的参数 ShadowsAdapter ，看看这个类。看完之后你会发现这其实是一个接口。这时你要思考的是，这些参数怎么来的，不可能凭空产生，肯定是在你的类生成 Activity 组件过程中构造的。看看 step 2.2 中的函数你会发现，第一个就是 getShadowsAdapter()，第二个是 ReflectionHelpers.callConstructor(activityClass)， 是不是发现了点什么，就是从这里开始，埋下了种子。同时 step 3.2 中有component ，发现他就是抽象类 ComponentController 中的变量，而且是 protected 的。那么现在唯一的猜想就是 ActivityController 继承自 ComponentController ，从类的命名来说是很合理的。那么源码是这样的吗？ 12// public class ActivityController&lt;T extends Activity&gt; extends org.robolectric.util.ActivityController&lt;T&gt; // abstract public class ActivityController&lt;T extends Activity&gt; extends ComponentController&lt;org.robolectric.android.controller.ActivityController&lt;T&gt;, T&gt; 看到这说明我们的想法完全正确！总算弄清楚 component 的身份，但是还是不知道他是怎么生成的？我们的预测是和 Activity 要有关联，目前的分析还看不出来，而且这里的 step 3.2 中的 component 直接作为参数传递了，说明在之前就已经被初始化了，也就是构造函数 ComponentController(ShadowsAdapter shadowsAdapter, T component) 已经被调用了。那么我们还是要回到 step 2.2 中的 ActivityController.of(getShadowsAdapter(), ReflectionHelpers.callConstructor(activityClass), intent) 因为那是 Activity 的消失和 component 出现的临界点。开始看看 of 函数。 123456789public static &lt;T extends Activity&gt; ActivityController&lt;T&gt; of(ShadowsAdapter shadowsAdapter, T activity, Intent intent) &#123; return new ActivityController&lt;&gt;(shadowsAdapter, activity, intent).attach();&#125;private ActivityController(ShadowsAdapter shadowsAdapter, T activity, Intent intent) &#123; super(shadowsAdapter, activity, intent); this.shadowsAdapter = shadowsAdapter; shadowReference = shadowsAdapter.getShadowActivityAdapter(this.component);&#125; 这时看到 activity 传给了super，应该有点警觉，前面不是验证了 ActivityController 继承自 ComponentController 吗？而 component 又是在 ComponentController 中的，难道。。。 接着 super 123456789101112protected ActivityController(ShadowsAdapter shadowsAdapter, T activity, Intent intent) &#123; super(shadowsAdapter, activity, intent);&#125;public ComponentController(ShadowsAdapter shadowsAdapter, T component, Intent intent) &#123; this(shadowsAdapter, component); this.intent = intent;&#125;public ComponentController(ShadowsAdapter shadowsAdapter, T component) &#123; myself = (C) this; this.component = component; shadowMainLooper = shadowsAdapter.getMainLooper();&#125; 费了这么一大圈最终还是找到了，就是和之前的猜想一致。就是 Activity 经过一系列的操作 (这里操作是指 ReflectionHelpers.callConstructor(activityClass), intent) ) 最终直接传递给 component 。 所以获取 Activity 对象的分析就告一段落了。至于构建细节，怎么在 JVM 中绘制 View 的我也不怎么清楚，要想了解可以对 step 3.1 中的函数进一步深究。我大概可以确定应该是在那个过程中完成的。 过程总结看图 模拟点击 -&gt; performClick()接下来就是根据获取的 Activity 来获取布局中的控件进行测试。 这里分析的是一个点击事件： 12345678910111213141516171819202122/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 你会发现这里的 performClick() 中其实是调用了 onClick() 的。下面就是要验证确定会执行这个点击事件。首先 li != null 这个条件是怎么成立的？ 12345678static class ListenerInfo &#123; /** * Listener used to dispatch focus change events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ ......&#125; 通过上述代码你会发现这是一个 View 的静态内部类。所以其实 mListenerInfo 应该是类中的一个变量。那么这个变量是在何时被初始化的呢？ 123456789ListenerInfo mListenerInfo;ListenerInfo getListenerInfo() &#123; if (mListenerInfo != null) &#123; return mListenerInfo; &#125; mListenerInfo = new ListenerInfo(); return mListenerInfo;&#125; 经过一番查找可以肯定的是，前面应该是调用了 getListenerInfo() 函数。而对于一个 Button 的 listenerInfo 凭直觉可以猜测下很大可能是 setOnClickListener() 中调用的。因为设置点击监听应该是要获取监听信息的吧。。。再就是前面除了对 Button 设置了点击事件就没做其他操作了，而且如果事件得到触发的话意味着 mListenerInfo 一定是被初始化了的。种种猜测都指向 setOnClickListener() ，那就看看源码吧。 1234567891011121314/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125; 确实是如此，如果你没有进行前面的猜测的话，可以直接搜这个函数看看在哪些地方调用了，这时你会发现一个共同点：所有和视图监听有关的函数都有调用 getListenerInfo() 。至于为什么这样？很简单，因为他们都是 Listener ，自然需要 ListenerInfo 来确定自己是什么监听，并且通过 ListenerInfo 进行管理，只要 ListenerInfo 中的某个变量是 null 就意味着这个 Listener 是未注册的。这点可以从 li.mOnClickListener != null 这个条件验证，也就是前面点击事件的触发条件。 1234567891011121314151617public void setOnScrollChangeListener(OnScrollChangeListener l) &#123; getListenerInfo().mOnScrollChangeListener = l;&#125;public void setOnFocusChangeListener(OnFocusChangeListener l) &#123; getListenerInfo().mOnFocusChangeListener = l;&#125;public void addOnLayoutChangeListener(OnLayoutChangeListener listener) &#123; ListenerInfo li = getListenerInfo(); if (li.mOnLayoutChangeListeners == null) &#123; li.mOnLayoutChangeListeners = new ArrayList&lt;OnLayoutChangeListener&gt;(); &#125; if (!li.mOnLayoutChangeListeners.contains(listener)) &#123; li.mOnLayoutChangeListeners.add(listener); &#125;&#125; 好了，点击事件就分析到这，总结一下：最开始就是设置监听，设置监听过程中会在 View 中将点击事件用 ListenerInfo 记录。在模拟点击事件中调用 performClick() ，下面就是对事件是否注册来确定是否触发点击事件。 之后就是自己写逻辑了，对你的预期和模拟跑出来的结果是否一致进行测试。这里就是 Junit 内容了。 总结通过这次源码分析，发现只要细心，很多大牛的代码慢慢读也是可以读懂的。虽然代码量太大不可能一行不落地阅读，但是从一个小例子出发，慢慢分析就可以得出你自己理解，其实代码的逻辑就是常人的逻辑，其中值得学习的恰恰是这种常人逻辑之间的协调和对代码整个的宏观把控。 这是我第一次写关于源码分析的文章，其中肯定有很多不足，欢迎大家指正。还有推荐下我的个人 Blog 最后感谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"Android Unit Test","slug":"Android-Unit-Test","permalink":"http://fitzeng.org/tags/Android-Unit-Test/"}]},{"title":"实现一个类似QQ的社交聊天工具-4","date":"2017-04-14T06:00:00.000Z","path":"2017/04/14/ZZChatApp4/","text":"GitHub 实现一个类似QQ的社交聊天工具-4准备做好【ZZChatApp3】中的内容并且下载了实现一个类似QQ的社交聊天工具-1中的资料就可以开始下面的了环境自己尝试是否能配好，下面只是给出一些提示和建议。Xampp + Java EE 实现目标这里已经实现基本的通讯了。由于最近特别忙，所以打算写两篇的网络编程总结成一篇，细节应该都会提到，只是不会太详细。希望大家多利用身边的网络资源。基本在网上都有现成的答案。 实现过程 这就是大体的方向，所以目前目标很简单，为了不打断以后的编码思路，前期工作要做好。 环境配置 下载Xampp 开启 Apache 和 mySql, 在浏览器中输入 127.0.0.1: 看看有 Xampp 界面就成功，点击 admin 出现数据库就说明数据库可以访问了。 至于 Java EE 自身是不携带 WindowBuilder 也就是你无法使用 JFrame 的图形界面进行设计。怎么安装动手搜搜就知道了。之后就只要添加访问数据库的一个库到工程里面。在资料4已经给出，导入 buildpath 就可以了。 数据库创建 这里只是效果图，数据库的内容我们通过代码来创建，可以保证每一次的测试环境一样。 通讯协议这一部分的目的是数据解析要用到的。可以这样想，我发送一个登录消息和聊天消息服务器能区分吗？如果能够区分，那是怎么区分的？这就是设计通讯协议的最原始原因。其实如果学过网络通讯就知道，TCP/IP协议有个头，这个头就存在这某些信息，代表着自己身份，之后的信息就按这身份的协议去解析。这里就用一个很简单的 [Action]:[info, info, … , info] 来作为对象传输。[Action]就是一个头，后面连着消息，至于消息如何解析，就要看你自己协议的具体约定了。这里我提供一个很简陋的在资源4中，也就是 Version lab版 所遵守的协议。 服务端这里我们使用 socket 来编写。如果之前你没有接触过这方面，可能现在想知道手机怎么和电脑通讯？别急，先看看这个例子在电脑上怎么访问自己写的服务器。 演示很简单，就是一个简单的界面来开启服务，如果你是测试,可以先不编写界面，直接运行就开启服务 serverListener.start(); 之后在cmd telnet 中通过 127.0.0.1 这个 IP 访问端口 27777 。可以看到控制台输出 “haha”， 如果你的电脑没有 telnet 可以开启或者直接在浏览器中访问 127.0.0.1:27777. 效果一样。这是就代表有一个和服务器建立的连接。 从这里可以猜想，手机如果连接的是电脑的无线，也就是处于同一个局域网内的话，是不是也可以访问到浏览器。可以试试，手机连接电脑无线，那么通过什么访问端口呢？ 127.0.0.1？仔细思考就知道应该是行不通的，手机和电脑建立的连接走的是哪条线路呢？我们连的是无线，所以通过无线适配器和电脑建立连接，所以我们要访问电脑上的端口肯定是要经过这个适配器的。所以找到无线网络适配器的 IPv4, 就可以 通过 IPv4:27777 访问了。 下面解释一下代码。 1234567891011121314151617public class ServerListener extends Thread&#123; private ServerSocket serverSocket; @Override public void run() &#123; try &#123; serverSocket = new ServerSocket(27777, 27); while (true) &#123; Socket socket = serverSocket.accept(); System.out.println(\"haha\"); ChatSocket chatSocket = new ChatSocket(socket); chatSocket.start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以看到，这是一个死循环。只要不发生异常和手动关闭，这段代码是会一直运行下去的。其中 1Socket socket = serverSocket.accept(); 这一行是关键，代表的是没有 socket 接入的话，程序会一直阻塞在这句代码处，一旦有 socket 接入，则返回一个 socket ，由于一个服务器必然是有多个客户端连接的。所以我们给每个 socket 连接都分配一个线程并且开启线程，接着循环进入阻塞，直到有下一个连接建立，重复上述步骤。这就是这段代码的运行状态。 现在假设有线程已经开启了。怎么接收数据？ socket 是以流的形式传输数据。所以只要获取流，再将这个流进行相关操作就行了。下面解释一下我们的主要代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ChatSocket extends Thread&#123; private Socket socket; private String message = null; private BufferedReader bufferedReader; private BufferedWriter bufferedWriter; public ChatSocket(Socket s) &#123; this.socket = s; try &#123; this.bufferedReader = new BufferedReader(new InputStreamReader(s.getInputStream(), \"UTF-8\")); this.bufferedWriter = new BufferedWriter(new OutputStreamWriter(s.getOutputStream(), \"UTF-8\")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; try &#123; String line = null; while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; message += line; &#125; else &#123; delMessage(message); line = null; message = null; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; MainWindow.getMainWindow().setShowMsg(this.username + \" login out !\"); MainWindow.getMainWindow().removeOfflineUsers(this.username); ChatManager.getChatManager().remove(socketMsg); bufferedWriter.close(); bufferedReader.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 首先定义一个 BufferedReader 和 BufferedWriter ，作用是接受客户端的数据和向客户端发送数据。很好记，Reader 对于自己来说就是读取别处的数据，Writer 是向目标对象写数据。所以 BufferedReader 是接受客户端的数据，BufferedWriter 是向客户端发送数据。 那么如何获取呢？ 在构造函数中可以看到这两句 12this.bufferedReader = new BufferedReader(new InputStreamReader(s.getInputStream(), \"UTF-8\"));this.bufferedWriter = new BufferedWriter(new OutputStreamWriter(s.getOutputStream(), \"UTF-8\")); 可以一起写也可以分开。如下： 123456// 从 socket 获取输入流InputStream inputStream = s.getInputStream();// 将位流通过 “UTF-8” 的格式读取为字符流InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");// 将字符流放入 Buffer。方便使用BufferedReader bufferedReader = new BufferedReader(inputStreamReader); 多想想整个数据的传输过程就很明朗了。有点像 OSI 的那个七层模型，一层一层封装与解封装。 上面只是获取到了流，并没有进行数据读写操作。开始下面介绍读取流中的数据。 12345678910String line = null;while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; message += line; &#125; else &#123; delMessage(message); line = null; message = null; &#125;&#125; 看着有点乱。。再看一下下面的吧。 1234567891011121314public void sendMsg(String msg) &#123; try &#123; while (socket == null) ; if (bufferedWriter != null) &#123; System.out.println(\"send :\" + msg); bufferedWriter.write(msg + \"\\n\"); bufferedWriter.flush(); bufferedWriter.write(\"-1\\n\"); bufferedWriter.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 可以清楚的看到，发送消息之后后面会加一个 “-1” 作为消息的终止符，也就是接接收方在接收到 -1 时，说明前面的数据是作为一整个信息的，将数据传出进行处理。接着清空继续接收接下来的消息，循环往复。可以看到 bufferedReader 这个流只要不关闭，这个会永远循环下去。 好了消息的发送和接收都基本算是处理好了，接下来就是数据处理，数据处理必然是要依赖协议的。所以依赖协议自己实现如下的函数。 123456789101112131415161718192021222324public void delMessage(String msg) &#123; if (msg != null) &#123; String action = getAction(msg); switch(action) &#123; case \"LOGIN\": &#123; dealLogin(msg); break; &#125; case \"REGISTER\": &#123; dealRegister(msg); break; &#125; case \"DRESSUP\": &#123; dealDressUp(msg); break; &#125; case \"GETDRESSUP\": &#123; dealGetDressUp(msg); break; &#125; case \"PROFILE\": &#123; dealProfile(msg); break; &#125; case \"GETPROFILE\": &#123; dealGetProfile(msg); break; &#125; case \"GETFRIENDLIST\": &#123; dealGetFriendList(msg); break; &#125; case \"GETGROUPLIST\": &#123; dealGetGroupList(msg); break; &#125; case \"GETFRIENDPROFILE\": &#123; dealGetFriendProfile(msg); break; &#125; case \"STATE\": &#123; dealState(msg); break; &#125; case \"CHATMSG\": &#123; dealChatMsg(msg); break; &#125; case \"USERLIST\": &#123; dealUserList(msg); break; &#125; case \"ADDFRIEND\": &#123; dealAddFriend(msg); break; &#125; case \"GROUPMEMBERLIST\": &#123; dealGroupMemberList(msg); break; &#125; case \"ADDGROUP\": &#123; dealAddGroup(msg); break; &#125; case \"GETALLGROUPLIST\": &#123; dealGetAllGroupList(msg); break;&#125; default : dealError(); break; &#125; &#125;&#125; 服务端的线程是随连接数的增加而增加，所以创建一个线程管理的类（ChatManager）就有必要了，这样我们可以轻松的对消息进行跨进程转发（聊天）。 1234567891011121314151617181920212223242526272829303132333435public class ChatManager &#123; private ChatManager()&#123;&#125;; List&lt;SocketMsg&gt; socketList = new ArrayList&lt;&gt;(); private static final ChatManager chatManager = new ChatManager(); public static ChatManager getChatManager() &#123; return chatManager; &#125; public void add(SocketMsg cs) &#123; socketList.add(cs); &#125; public void remove(SocketMsg cs) &#123; socketList.remove(cs); &#125; &#125;public class SocketMsg &#123; private ChatSocket chatSocket; private String username; public SocketMsg(ChatSocket chatSocket, String username) &#123; this.chatSocket = chatSocket; this.username = username; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public ChatSocket getChatSocket() &#123; return chatSocket; &#125; public void setChatSocket(ChatSocket chatSocket) &#123; this.chatSocket = chatSocket; &#125;&#125; 就是这么简单。 服务端基本就讲到这里。细心的人会发现我们的接收消息和发送消息是不在同一个线程中的，稍微思考思考对客户端的代码编写有好处。 客户端在不考虑信息处理的情况下客户端仿照服务端很容易写出接受发送流的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758server/ServerManager.javapublic class ServerManager extends Thread &#123; private static final String IP = \"192.168.191.1\"; private Socket socket; private String message = null; private BufferedReader bufferedReader; private BufferedWriter bufferedWriter; public static ServerManager getServerManager() &#123; return serverManager; &#125; private ServerManager() &#123; &#125; public void run() &#123; try &#123; socket = new Socket(IP, 27777); bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\")); bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), \"UTF-8\")); String m = null; String line; while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; m += line; &#125; else &#123; Log.d(\"TAG\", \"receive : \" + m); if (ParaseData.getAction(m).equals(\"GETCHATMSG\")) &#123; receiveChatMsg.delChatMsg(m); &#125; else &#123; message = m; &#125; m = null; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bufferedWriter.close(); bufferedReader.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void sendMessage(Context context, String msg) &#123; try &#123; while (socket == null) ; if (bufferedWriter != null) &#123; bufferedWriter.write(msg + \"\\n\"); bufferedWriter.flush(); bufferedWriter.write(\"-1\\n\"); bufferedWriter.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码是不是很熟悉？基本和服务端没什么变化，因为毕竟这是要和服务端建立连接的。 可以看到这是一个线程，所以从哪里开启这个线程呢？我是在这里： 12345678AtyLoginOrRegister.javapublic class AtyLoginOrRegister extends AppCompatActivity implements View.OnClickListener &#123; private ServerManager serverManager = ServerManager.getServerManager(); private void initViews() &#123; serverManager.start(); &#125;&#125; 下面就是进行数据传输处理了，我举两个例子。 数据传输 登录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AtyLoginOrRegister extends AppCompatActivity implements View.OnClickListener &#123; private void initViews() &#123; btnLogin.setOnClickListener(this); btnRegister.setOnClickListener(this); serverManager.start(); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_login: &#123; String username = etLoginUsername.getText().toString(); String password = etLoginPassword.getText().toString(); if (login(username, password)) &#123; serverManager.setUsername(username); Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); &#125; else &#123; etLoginUsername.setText(\"\"); etLoginPassword.setText(\"\"); &#125; break; &#125; case R.id.btn_register: &#123; Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); break; &#125; default: break; &#125; &#125; private boolean login(String username, String password) &#123; // check username and password whether legal if (username == null || username.length() &gt; 10 || password.length() &gt; 20) &#123; return false; &#125; // send msg to servers String msg = \"[LOGIN]:[\" + username + \", \" + password + \"]\"; serverManager.sendMessage(this, msg); // get msg from servers return String ack = serverManager.getMessage(); // deal msg if (ack == null) &#123; return false; &#125; serverManager.setMessage(null); String p = \"\\\\[ACKLOGIN\\\\]:\\\\[(.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(ack); return matcher.find() &amp;&amp; matcher.group(1).equals(\"1\"); &#125;&#125; 既然是登录，那么事件是发生在按钮的点击之后。下面我们来理一下登录过程： 点击登录按钮-&gt;获取登录信息-&gt;封装信息传输-&gt;服务端接收-&gt;解析信息-&gt;从服务器获取信息进行登录验证-&gt;返回验证结果-&gt;客户端获取数据-&gt;解析信息-&gt;进行登录状态调整 这就是一整个流程。下面就具体介绍。 点击登录按钮 1234case R.id.btn_login: &#123; String username = etLoginUsername.getText().toString(); String password = etLoginPassword.getText().toString();&#125; 获取登录信息 12String username = etLoginUsername.getText().toString();String password = etLoginPassword.getText().toString(); 封装信息传输 12345if (username == null || username.length() &gt; 10 || password.length() &gt; 20) &#123; return false;&#125;String msg = \"[LOGIN]:[\" + username + \", \" + password + \"]\";serverManager.sendMessage(this, msg); 服务端接收 1234567891011String line = null;while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; message += line; &#125; else &#123; delMessage(message); System.out.println(\"receive : \" + message); line = null; message = null; &#125;&#125; 解析信息 123456789String iusername = null;String iPassword = null;String p = \"\\\\[LOGIN\\\\]:\\\\[(.*), (.*)\\\\]\";Pattern pattern = Pattern.compile(p);Matcher matcher = pattern.matcher(msg);if (matcher.find()) &#123; iusername = matcher.group(1); iPassword = matcher.group(2);&#125; 从服务器获取信息进行登录验证 &amp;&amp; 返回验证结果 1234567891011121314151617String sql = \"SELECT password FROM USERS WHERE username = '\" + iusername + \"';\";try &#123; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql); if (resultSet.next() &amp;&amp; iPassword.equals(resultSet.getString(1)) ) &#123; sendMsg(\"[ACKLOGIN]:[1]\"); this.username = iusername; MainWindow.getMainWindow().setShowMsg(this.username + \" login in!\"); MainWindow.getMainWindow().addOnlineUsers(this.username); socketMsg = new SocketMsg(this, this.username); ChatManager.getChatManager().add(socketMsg); return ; &#125;&#125; catch (SQLException e) &#123; e.printStackTrace();&#125;sendMsg(\"[ACKLOGIN]:[0]\"); 客户端获取数据 1String ack = serverManager.getMessage(); 解析信息 12345678if (ack == null) &#123; return false;&#125;serverManager.setMessage(null);String p = \"\\\\[ACKLOGIN\\\\]:\\\\[(.*)\\\\]\";Pattern pattern = Pattern.compile(p);Matcher matcher = pattern.matcher(ack);return matcher.find() &amp;&amp; matcher.group(1).equals(\"1\"); 进行登录状态调整 123456789if (login(username, password)) &#123; serverManager.setUsername(username); Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish();&#125; else &#123; etLoginUsername.setText(\"\"); etLoginPassword.setText(\"\");&#125; 发送信息 流程一样只是处理消息的时候复杂一点，因为我们只为聊天设置一个协议。所以要提高信息的区分度而对数据进行的繁复操作是必须的。 发送： 1234567891011121314151617181920212223242526272829303132333435363738394041btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String content = myMsg.getText().toString(); if (!content.isEmpty()) &#123; ChatMsg msg = new ChatMsg(); msg.setContent(content); msg.setUsername(ServerManager.getServerManager().getUsername()); msg.setIconID(ServerManager.getServerManager().getIconID()); msg.setMyInfo(true); msg.setChatObj(chatObj); msg.setGroup(group.equals(\"0\") ? chatObj : \" \"); if (sendToChatObj(msg.getContent())) &#123; ChatMsg.chatMsgList.add(msg); chatMsgList.add(msg); myMsg.setText(\"\"); &#125; else &#123; Toast.makeText(AtyChatRoom.this, \"send failed\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125;);private boolean sendToChatObj(String content) &#123; String msg = \"[CHATMSG]:[\" + chatObj + \", \" + content + \", \" + ServerManager.getServerManager().getIconID() +\", Text]\"; ServerManager serverManager = ServerManager.getServerManager(); serverManager.sendMessage(this, msg); try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String ack = serverManager.getMessage(); if (ack == null) &#123; return false; &#125; String p = \"\\\\[ACKCHATMSG\\\\]:\\\\[(.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(ack); return matcher.find() &amp;&amp; matcher.group(1).equals(\"1\");&#125; 接收： 由于日后扩展可能不只是文本信息，所以在对聊天信息的处理上我们直接再建一个类。 1234567891011121314151617181920212223242526272829303132class ReceiveChatMsg &#123; void delChatMsg(String msg) &#123; String sendName = null; String content = null; String avatarID = null; String fileType = null; String group = null; ServerManager.getServerManager().setMessage(null); String p = \"\\\\[GETCHATMSG\\\\]:\\\\[(.*), (.*), (.*), (.*), (.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(msg); if (matcher.find()) &#123; sendName = matcher.group(1); content = matcher.group(2); avatarID = matcher.group(3); fileType = matcher.group(4); group = matcher.group(5); ChatMsg chatMsg = new ChatMsg(); chatMsg.setMyInfo(false); chatMsg.setContent(content); chatMsg.setChatObj(sendName); chatMsg.setUsername(ServerManager.getServerManager().getUsername()); chatMsg.setGroup(group); chatMsg.setIconID(Integer.parseInt(avatarID)); AtyChatRoom.chatMsgList.add(chatMsg); ChatMsg.chatMsgList.add(chatMsg); &#125; &#125;&#125; 细节就不多说了，注意区分同一个对象发信息给你是通过群还是私人。 还有就是当聊天窗口关闭后在再次打开聊天信息怎么加载？大家自己想想。不同可以看代码或者留言。 下面看下服务器的数据转发代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void dealChatMsg(String msg) &#123; String chatObj = null; String content = null; String avatarID = null; String msgType = null; String p = \"\\\\[CHATMSG\\\\]:\\\\[(.*), (.*), (.*), (.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(msg); if (matcher.find()) &#123; chatObj = matcher.group(1); content = matcher.group(2); avatarID = matcher.group(3); msgType = matcher.group(4); &#125; else &#123; return; &#125; String out = null; String sqlGroup = \"SELECT * FROM GROUPS WHERE groupName = '\" + chatObj+ \"';\"; try &#123; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sqlGroup); // gruop chat if (resultSet.next()) &#123; // find all group members to send msg String sql = \"SELECT groupMemberName FROM GROUPINFO WHERE groupName = '\" + chatObj + \"';\"; resultSet = statement.executeQuery(sql); while (resultSet.next()) &#123; // if user is online , then send. for (SocketMsg SocketMsg : ChatManager.getChatManager().socketList) &#123; if (SocketMsg.getUsername().equals(resultSet.getString(1)) &amp;&amp; !SocketMsg.getUsername().equals(username)) &#123; out = \"[GETCHATMSG]:[\" + username + \", \" + content + \", \" + avatarID + \", Text, \" + chatObj + \"]\"; SocketMsg.getChatSocket().sendMsg(out); &#125; &#125; &#125; // private chat &#125; else &#123; for (SocketMsg socketManager : ChatManager.getChatManager().socketList) &#123; if (socketManager.getUsername().equals(chatObj)) &#123; out = \"[GETCHATMSG]:[\" + username + \", \" + content + \", \" + avatarID + \", Text, ]\"; socketManager.getChatSocket().sendMsg(out); &#125; &#125; &#125; out = \"[ACKCHATMSG]:[1]\"; sendMsg(out); &#125; catch (SQLException e) &#123; out = \"[ACKCHATMSG]:[0]\"; sendMsg(out); e.printStackTrace(); &#125;&#125; 其实逻辑不是很复杂，慢慢看很容易懂的。其他的实现自己慢慢摸索可以实现。不想再拖长篇幅了，看代码可能比我讲的效率更高，理解更加深刻。在这个过程中可能你会遇到一个小 Bug 卡了一天，但是每个人都是这么成长过来的，一起加油! 到这里目前的就算完了，这个系列 Blog 可能不会更新了。但是 GitHub 上会对代码继续更新的。此外这个 Lab 版还有很多 Bug 欢迎大家提建议，很希望和大家一起交流学习。 多谢阅读。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-3","date":"2017-04-14T05:00:00.000Z","path":"2017/04/14/ZZChatApp3/","text":"GitHub 实现一个类似QQ的社交聊天工具-3准备做好【ZZChatApp2】中的内容并且下载了实现一个类似QQ的社交聊天工具-1中的资料就可以开始下面的了 实现目标看演示效果就知道，这次主要的任务是实现两个界面，一个是 Dressup 选图片的，另一个是聊天界面。如果你对 RecyclerView 有一定认识了，可以自己自行编写 Dressup 界面。我们的聊天信息使用的是 listview ，尝试尽可能多的控件。好消息是这次 lab 之后基本的界面工作就完成了，下次 lab 我们开始进行网络编程。 实现过程 Profile 界面就不讲了，自己参照源码或者自己写，这里为了方便就直接把 username 作为 id 和 nickname 主要是为了后期数据库的建立不太麻烦，毕竟是个小练习。数据处理不是我们关注的重点，重点是整个开发流程。 Dressup实现 我的习惯是先写界面 123456789101112131415161718192021aty_dress_up.xml&lt;LinearLayout &gt; &lt;org.fitzeng.zzchat.view.TitleBar android:id=\"@+id/tb_dress_up\" &gt; &lt;/org.fitzeng.zzchat.view.TitleBar&gt; &lt;TextView android:text=\"Choose an avatar\" /&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_avatar\" &gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;TextView android:text=\"Choose a background\" /&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_background\" &gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;Button android:id=\"@+id/btn_save\" /&gt;&lt;/LinearLayout&gt; 布局很简单，接下来就是建一个Aty去加载布局。布局好了，这是应该是加载资源，而加载资源又不得不用到我们的适配器。所以先写适配器。 下面以加载 Avatar 为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859adapter/AdapterAvatar.javapublic class AdapterAvatar extends RecyclerView.Adapter&lt;AdapterAvatar.BaseViewHoder&gt;&#123; private List&lt;ImageMsg&gt; imageViews; private Context context; private LayoutInflater inflater; private static int selectedImageAvatar = 0; private List&lt;RelativeLayout&gt; imageContainer = new ArrayList&lt;&gt;(); private Drawable bgImageDrawable; @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public AdapterAvatar(Context context, List&lt;ImageMsg&gt; imageViews) &#123; this.context = context; this.imageViews = imageViews; this.inflater = LayoutInflater.from(context); selectedImageAvatar = 0; bgImageDrawable = context.getResources().getDrawable(R.drawable.bgimage, null); &#125; @Override public BaseViewHoder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = inflater.inflate(R.layout.choose_image, parent, false); return new BaseViewHoder(view); &#125; @Override public void onBindViewHolder(final BaseViewHoder holder, final int position) &#123; holder.imageView.setImageResource(imageViews.get(position).getImageID()); imageContainer.get(selectedImageAvatar).setBackground(bgImageDrawable); holder.imageView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (position != selectedImageAvatar) &#123; imageContainer.get(position).setBackground(bgImageDrawable); imageContainer.get(selectedImageAvatar).setBackgroundColor(0); selectedImageAvatar = position; &#125; &#125; &#125;); &#125; @Override public int getItemCount() &#123; return imageViews == null ? 0 : imageViews.size(); &#125; class BaseViewHoder extends RecyclerView.ViewHolder &#123; ImageView imageView; BaseViewHoder(View itemView) &#123; super(itemView); imageView = (ImageView) itemView.findViewById(R.id.image); RelativeLayout layout = (RelativeLayout) itemView.findViewById(R.id.imageContainer); imageContainer.add(layout); &#125; &#125;&#125; 代码很简洁，都是套路。唯一注意的一点是点击的逻辑处理。还有就是把图片资源（util/ImageManager）用一个类封装一下，和创建一个对象（util/ImageMsg）用来存储加载数据的信息。用起来就比较方便了。适配器好了，下面利用适配器把数据加载进 RecyclerView 。思路还是比较清晰的。 具体实现看代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)private void initViews() &#123; titleBar = (TitleBar) findViewById(R.id.tb_dress_up); rvAvatar = (RecyclerView) findViewById(R.id.rv_avatar); rvBackground = (RecyclerView) findViewById(R.id.rv_background); btnSave = (Button) findViewById(R.id.btn_save); addAvatarView(); titleBar.setTitleBarClickListetner(new TitleBar.titleBarClickListener() &#123; @Override public void leftButtonClick() &#123; finish(); &#125; @Override public void rightButtonClick() &#123; &#125; &#125;); btnSave.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(AtyDressUp.this, \"saved\", Toast.LENGTH_SHORT).show(); finish(); &#125; &#125;);&#125;private void addAvatarView() &#123; List&lt;ImageMsg&gt; imageMsgs = new ArrayList&lt;&gt;(); for (int anImagesAvatar : ImageManager.imagesAvatar) &#123; ImageMsg imagemsg = new ImageMsg(); imagemsg.setImageID(anImagesAvatar); imageMsgs.add(imagemsg); &#125; AdapterAvatar avatarAdapter = new AdapterAvatar(this, imageMsgs); LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false); rvAvatar.setLayoutManager(layoutManager); rvAvatar.setAdapter(avatarAdapter);&#125; 之后加载 Background 的代码自己写吧,这一部分就算完成了，不懂的可以参照源码。 聊天界面看过第一行代码的应该有点了解，大家可以先上网搜搜其他资源。 主要问题是怎么让消息自适应气泡。有一种图片时.9.png格式，至于如何制作，很简单。选中图片右键，在最下面的选项中有一个Create 9-Patch file…点击之后就会弹出界面，自己把要缩放的区域集中在黑线的交汇区域。 聊天界面布局如下，这里有一个Bug，下面会陈述。 1234567891011121314151617181920&lt;LinearLayout &gt; &lt;org.fitzeng.zzchat.view.TitleBar android:id=\"@+id/tb_chat_room\" &gt; &lt;/org.fitzeng.zzchat.view.TitleBar&gt; &lt;ScrollView &gt; &lt;LinearLayout &gt; &lt;ListView android:id=\"@+id/lv_chat_room\" &gt; &lt;/ListView&gt; &lt;LinearLayout &gt; &lt;Button android:text=\"emoji\" /&gt; &lt;Button android:text=\"draw\" /&gt; &lt;Button android:text=\"file\" /&gt; &lt;Button android:text=\"call\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout&gt; &lt;EditText android:id=\"@+id/myMsg\"/&gt; &lt;Button android:id=\"@+id/btnSend\"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 接下来就是消息界面的设计，也就是适配器加载的布局。一个头像，一个 username 一个内容。OK。但是要区分是自己发送的消息还是别人发送的消息。所以有两个布局。 这时我们要建立一个聊天信息的Msg 12345private boolean myInfo;private int iconID;private String username;private String content;private String chatObj; 数据什么的都贮备好了，下面进行是适配器的编写。由于 ListView 没有实现 ViewHolder 所以要自己实现。主要是为了视图缓存，减小视图加载时的资源消耗。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859adaptar/AdapterChatMsg.javapublic class AdapterChatMsg extends ArrayAdapter&lt;ChatMsg&gt; &#123; private LayoutInflater inflater; private List&lt;ChatMsg&gt; chatMsgs; public AdapterChatMsg(@NonNull Context context, @LayoutRes int resource, List&lt;ChatMsg&gt; chatMsgs) &#123; super(context, resource); this.inflater = LayoutInflater.from(context); this.chatMsgs = chatMsgs; &#125; @Override public int getCount() &#123; return chatMsgs.size(); &#125; @Nullable @Override public ChatMsg getItem(int position) &#123; return chatMsgs.get(position); &#125; @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; ChatMsg msg = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; assert msg != null; if (msg.isMyInfo()) &#123; view = inflater.inflate(R.layout.chat_me, parent, false); &#125; else &#123; view = inflater.inflate(R.layout.chat_other, parent, false); &#125; viewHolder = new ViewHolder(); viewHolder.icon = (ImageView) view.findViewById(R.id.icon); viewHolder.username = (TextView) view.findViewById(R.id.username); viewHolder.content = (TextView) view.findViewById(R.id.content); view.setTag(viewHolder); &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; viewHolder.icon.setImageResource(chatMsgs.get(position).getIconID()); viewHolder.username.setText(chatMsgs.get(position).getUsername()); viewHolder.content.setText(chatMsgs.get(position).getContent()); return view; &#125; private class ViewHolder &#123; ImageView icon; TextView username; TextView content; &#125;&#125; 其中通过 12345if (msg.isMyInfo()) &#123; view = inflater.inflate(R.layout.chat_me, parent, false);&#125; else &#123; view = inflater.inflate(R.layout.chat_other, parent, false);&#125; 来加载聊天左右视图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667AtyChatRoom.javapublic class AtyChatRoom extends AppCompatActivity&#123; private TitleBar titleBar; private ListView listView; private EditText myMsg; private Button btnSend; private List&lt;ChatMsg&gt; chatMsgList; private AdapterChatMsg adapterChatMsgList; private String chatObj; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getSupportActionBar().hide();// getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.aty_chat_room); getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE | WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);// AndroidBug5497Workaround.assistActivity(this); initViews(); &#125; private void initViews() &#123; titleBar = (TitleBar) findViewById(R.id.tb_chat_room); listView = (ListView) findViewById(R.id.lv_chat_room); myMsg = (EditText) findViewById(R.id.myMsg); btnSend = (Button) findViewById(R.id.btnSend); chatMsgList = new ArrayList&lt;&gt;(); chatObj = getIntent().getStringExtra(\"username\"); titleBar.setTitleText(chatObj); adapterChatMsgList = new AdapterChatMsg(AtyChatRoom.this, R.layout.chat_other, chatMsgList); listView.setAdapter(adapterChatMsgList); btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String content = myMsg.getText().toString(); if (!content.isEmpty()) &#123; ChatMsg msg = new ChatMsg(); msg.setContent(content); msg.setUsername(\"hello\"); msg.setIconID(R.drawable.avasterwe); msg.setMyInfo(true); msg.setChatObj(chatObj); chatMsgList.add(msg); myMsg.setText(\"\"); &#125; &#125; &#125;); titleBar.setTitleBarClickListetner(new TitleBar.titleBarClickListener() &#123; @Override public void leftButtonClick() &#123; finish(); &#125; @Override public void rightButtonClick() &#123; &#125; &#125;); &#125;&#125; 这次我把整个Aty都贴出来了，主要是为了说明一个Bug。点击输入框软键盘弹出时 TitleBar 会被顶上去。为了解决这个问题，在onCreate函数中，加 SOFT_INPUT_ADJUST_RESIZE ，但是在全屏下同时设置 SOFT_INPUT_ADJUST_RESIZE 这个属性，TitleBar 又会被顶上去。所以，在 Stack Overflow 有大神给出了解决方案。就是 util 多出的那个 AndroidBug5497Workaround.java 文件。讲道理在 setContentView() 之后添加一句 AndroidBug5497Workaround.assistActivity(this); 就可以解决。。。。。。但是。。。可能是我的手机太渣，还是没能实现效果。据说这个是适合市面上大部分手机的。。。希望在你的手机上能行，所以我就保留了这些文件。为了取舍，我只能不实现全屏了。。。日后找到好的解决方案会在github更新。 目前好像。。完了。。。。看着少，其实里面的有些东西是值得深究的。至于如何实现 Moments 和 Contacts 滑动的留给大家自己探索了。 感谢大家的耐心阅读和支持，再下次开始之前，希望你已经搭建好了本地服务器。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-2","date":"2017-04-14T04:00:00.000Z","path":"2017/04/14/ZZChatApp2/","text":"GitHub 实现一个类似QQ的社交聊天工具-2准备做好【ZZChatApp1】中的内容并且下载了实现一个类似QQ的社交聊天工具-1中的资料就可以开始下面的了 实现目标前面只是实现一个基本的框架，这次我们要往主界面里面添加内容，代码较多，最好自己看这篇文章时也参考我提供的第二阶段源码。主要练习的是自定义控件 实现过程 这次的文件比上次多了，所以文件管理和控件ID的命名不能太随意，这是要注意的一点。代码难度不高，只要命名好了，不写注释其实也能看懂的。 TitleBar在开始写三个页面和一个侧滑视图之前，我们先做个自定义控件。其实这此实验总共用到了两个，我在这只叙述复杂的那个，剩下的可以参考源码自己实现。在学习之前推荐观看慕课，时间不是很长，但是对理清思路视频讲解更直接。 设计属性 其实就是两个button加一个textView。属性设计如下 123456789101112131415161718values/atts.xml&lt;declare-styleable name=\"TitleBar\"&gt; &lt;attr name=\"titleText\" format=\"string\" /&gt; &lt;attr name=\"titleTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"titleTextColor\" format=\"color\" /&gt; &lt;attr name=\"titleBackground\" format=\"reference|color\" /&gt; &lt;attr name=\"leftText\" format=\"string\" /&gt; &lt;attr name=\"leftTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"leftTextColor\" format=\"color\" /&gt; &lt;attr name=\"leftBackground\" format=\"reference|color\" /&gt; &lt;attr name=\"rightText\" format=\"string\" /&gt; &lt;attr name=\"rightTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"rightTextColor\" format=\"color\" /&gt; &lt;attr name=\"rightBackground\" format=\"reference|color\" /&gt;&lt;/declare-styleable&gt; 绑定属性 可以根据前面设计的属性来判断需要哪些变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private Button btnLeft;private Button btnRight;private TextView tvTitle;private String leftText;private float leftTextSize;private int leftTextColor;private Drawable leftBackground;private String rightText;private float rightTextSize;private int rightTextColor;private Drawable rightBackground;private String titleText;private float titleTextSize;private int titleTextColor;private Drawable titleBackground;/** * @param attrs this is titlebar's attribute set for binding with widgets */private void findAttrs(AttributeSet attrs) &#123; TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TitleBar); leftText = typedArray.getString(R.styleable.TitleBar_leftText); leftTextSize = typedArray.getDimension(R.styleable.TitleBar_leftTextSize, 24); leftTextColor = typedArray.getColor(R.styleable.TitleBar_leftTextColor, 0); leftBackground = typedArray.getDrawable(R.styleable.TitleBar_leftBackground); titleText = typedArray.getString(R.styleable.TitleBar_titleText); titleTextSize = typedArray.getDimension(R.styleable.TitleBar_titleTextSize, 24); titleTextColor = typedArray.getColor(R.styleable.TitleBar_titleTextColor, 0); titleBackground = typedArray.getDrawable(R.styleable.TitleBar_titleBackground); rightText = typedArray.getString(R.styleable.TitleBar_rightText); rightTextSize = typedArray.getDimension(R.styleable.TitleBar_rightTextSize, 24); rightTextColor = typedArray.getColor(R.styleable.TitleBar_rightTextColor, 0); rightBackground = typedArray.getDrawable(R.styleable.TitleBar_rightBackground); typedArray.recycle();&#125;/** * Init titlebar's widgets */private void initViews() &#123; btnLeft = new Button(context); btnRight = new Button(context); tvTitle = new TextView(context); btnLeft.setText(leftText); btnLeft.setTextSize(leftTextSize); btnLeft.setTextColor(leftTextColor); btnLeft.setBackground(leftBackground); btnRight.setText(rightText); btnRight.setTextSize(rightTextSize); btnRight.setTextColor(rightTextColor); btnRight.setBackground(rightBackground); tvTitle.setText(titleText); tvTitle.setTextSize(titleTextSize); tvTitle.setTextColor(titleTextColor); tvTitle.setBackground(titleBackground); tvTitle.setGravity(Gravity.CENTER); setBackgroundColor(0xFF01AAFF);&#125;/** * Setting titlebar's layout */private void setTitleBarLayoutParams() &#123; btnLeft.setAllCaps(false); btnRight.setAllCaps(false); LayoutParams btnLeftLayoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); btnLeftLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT, TRUE); addView(btnLeft, btnLeftLayoutParams); LayoutParams btnRightLayoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); btnRightLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, TRUE); addView(btnRight, btnRightLayoutParams); LayoutParams titleLayoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT); titleLayoutParams.addRule(RelativeLayout.CENTER_IN_PARENT, TRUE); addView(tvTitle, titleLayoutParams);&#125; 其实从使用角度来说，可以理出一条我们为什么这么做的线。因为在 XML 中我们使用一般都是 android : layout_width = “match_parent”很明显 layout_width 可以看做一个 Key ，而 match_parent 是一个 Value.所以 findAttrs(AttributeSet attrs) 就是把之前设计属性是所能识别的 Key 的值取出来，也就是 “XXX” 中的 XXX 数据，但是仅仅取出数据并没有什么用，最终还是要把数据赋值到控件上去，数据才能显示我们想要的效果。所以 initViews() 便是做这件事的。接下来的 setTitleBarLayoutParams() 只是对里面控件的属性的一个约束。 对于 Key-Value 的理解，其实可以这样看，如果声明了一个 app:no_name=”12” 在 xml 中，而实际你并没有声明这个属性在 atts.xml 中，所以编译器知道的是找不到 Key ，而不是判定 Value 的对错。所以对于属性文件 atts.xml 就自然而然有了存在的意义。我理解为就是规范作用，而之后的值传递给 TextView 或者其他已有控件，就是之后的绑定属性值的操作就顺理成章了。 文笔不好，不知道讲清了没。。。大家还是好好看看前面推荐的视频和自己写一个小控件实现一下加深理解。 目前这个控件只是静态的，不能响应点击事件。可以参考之前的 Button 怎么实现的。一般 Button.setOnClickListener()所以可以在控件中加一个 setTitleBarClickListetner() 方法。接下来就是有点难度的了。Button 自己的点击事件响应其实是由自己在 onClick() 方法中实现自己的逻辑的。 所以此时自定义控件就要对外提供一个接口，让实现者自己定义自己的点击事件。讲到这估计差不多了，看看代码就理解了。 12345678910111213141516171819202122232425262728293031323334view/TitleBar.javaprivate titleBarClickListener listener;/** * implement click events */public interface titleBarClickListener &#123; // 这两个方法相当于 Button 的 onCLick() void leftButtonClick(); void rightButtonClick();&#125;// 类似于 Button 的setOnClickListener();public void setTitleBarClickListetner(titleBarClickListener listetner) &#123; this.listener = listetner;&#125;// 内部设置按钮点击监听private void setButtonClickListener() &#123; btnLeft.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.leftButtonClick(); &#125; &#125;); btnRight.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.rightButtonClick(); &#125; &#125;);&#125; 下面剩下的一个 PicAndTextBtn 大家可以自己实现，就是作为左侧滑动视图中的小控件，一个 ImageView 和 TextView组成的。 侧滑界面如果前面都写好了下面就使用上面的控件来写滑动界面，布局很简单。 12345678910111213141516171819202122232425262728&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;RelativeLayout&gt; &lt;LinearLayout&gt; &lt;LinearLayout&gt; &lt;ImageView/&gt; Avatar &lt;TextView/&gt; Username &lt;/LinearLayout&gt; &lt;TextView/&gt; Sign &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;Dress Up&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;Profile&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;/LinearLayout&gt; &lt;LinearLayout&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;setting&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;night&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 接下来就是实现其逻辑了，这次主要实现以下setting，dressup和profile下次实验实现。实现控件的点击，虽然这个点击事件是你们自己写的，为了后面的实验一致，推荐命名最好和我一致。。。虽然我的命名也很烂。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647view/LayoutSlide.javaprivate void initViews() &#123; this.addView(LayoutInflater.from(context).inflate(R.layout.layout_slide, null)); dressUp = (PicAndTextBtn) findViewById(R.id.patb_dressup); profile = (PicAndTextBtn) findViewById(R.id.patb_profile); setting = (PicAndTextBtn) findViewById(R.id.patb_setting); night = (PicAndTextBtn) findViewById(R.id.patb_night); dressUp.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, AtyDressUp.class); context.startActivity(intent); &#125; &#125;); profile.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, AtyProfile.class); context.startActivity(intent); &#125; &#125;); setting.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, AtySetting.class); context.startActivity(intent); &#125; &#125;); night.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; if (nightMode) &#123; findViewById(R.id.layout_slide).setBackgroundColor(0xff878787); nightMode = false; &#125; else &#123; findViewById(R.id.layout_slide).setBackgroundColor(0xffe9e9e9); nightMode = true; &#125; &#125; &#125;);&#125; setting 界面的布局就不贴代码了，很简单。只分析 java 代码，其实目前也很水，也就实现了一个 Guide View 是否播放的功能。但是在之前的 Welcome 页面中还要做一点小小的修改。大家可以试验不该会怎么样。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768AtySetting.javaprivate void initViews() &#123; titleBar = (TitleBar) findViewById(R.id.tb_setting); guide = (ImageView) findViewById(R.id.iv_setting_guide); password = (ImageView) findViewById(R.id.iv_setting_password); offline = (ImageView) findViewById(R.id.iv_setting_offline); guideMode = getSharedPreferences(\"zzchat\", MODE_PRIVATE).getBoolean(\"guide\", true); guide.setImageResource(guideMode ? R.drawable.btnselected : R.drawable.btnunselected); password.setImageResource(passwordMode ? R.drawable.btnselected : R.drawable.btnunselected); offline.setImageResource(offlineMode ? R.drawable.btnselected : R.drawable.btnunselected); guide.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (guideMode) &#123; guide.setImageResource(R.drawable.btnunselected); guideMode = false; &#125; else &#123; guide.setImageResource(R.drawable.btnselected); guideMode = true; &#125; &#125; &#125;); password.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (passwordMode) &#123; password.setImageResource(R.drawable.btnunselected); passwordMode = false; &#125; else &#123; password.setImageResource(R.drawable.btnselected); passwordMode = true; &#125; &#125; &#125;); offline.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (offlineMode) &#123; offline.setImageResource(R.drawable.btnunselected); offlineMode = false; &#125; else &#123; offline.setImageResource(R.drawable.btnselected); offlineMode = true; &#125; &#125; &#125;); titleBar.setTitleBarClickListetner(new TitleBar.titleBarClickListener() &#123; @Override public void leftButtonClick() &#123; SharedPreferences sharedPreferences = getSharedPreferences(\"zzchat\", MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putBoolean(\"guide\", guideMode); editor.apply(); finish(); &#125; @Override public void rightButtonClick() &#123; &#125; &#125;);&#125; night 功能也基本没有实现，留给大家完善了。。。 chats下面开始 Chat 页面的设计。同理后面的 Contact 和 Moment 也是和这个类似，大家参考源码可以把代码写了，当做练习。有些坑自己不踩不知道多深。 把 titleBar 引进来是很简单的。直接在主界面中加就是了。 实现 Chats 这个列表功能我们使用更加易用的 RecyclerView 下次实验实现的聊天界面我们可以试试 ListView。好了，都决定好了就开始写代码吧。 和前面一样，一个 RecyclerView 怎么加载数据？答案就是通过 Adapter ，问题又来了，那么加载的怎样的数据呢？所以现在目的很明确，就是设计数据 Item 布局是一个头像，一个Username, 一个签名 123456789item_user.xml&lt;LinearLayout&gt; &lt;ImageView android:id=\"@+id/iv_item_avatar\" /&gt; &lt;LinearLayout&gt; &lt;TextView android:id=\"@+id/tv_item_username\" /&gt; &lt;TextView android:id=\"@+id/tv_item_sign\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 有了布局，接下来就是自己构造适配器加载布局。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950adapter/AdapterUserItem.javapublic class AdapterUserItem extends RecyclerView.Adapter&lt;AdapterUserItem.BaseViewHolder&gt; &#123; private Context context; private List&lt;UserItemMsg&gt; userItemMsgList; public AdapterUserItem(Context context, List&lt;UserItemMsg&gt; userItemMsgList) &#123; this.context = context; this.userItemMsgList = userItemMsgList; &#125; @Override public BaseViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new BaseViewHolder(LayoutInflater.from(context).inflate(R.layout.item_user, parent, false)); &#125; @Override public void onBindViewHolder(BaseViewHolder holder, int position) &#123; holder.ivAvatar.setImageResource(userItemMsgList.get(position).getIconID()); holder.tvUsername.setText(userItemMsgList.get(position).getUsername()); holder.tvSign.setText(userItemMsgList.get(position).getSign()); &#125; @Override public int getItemCount() &#123; return (userItemMsgList == null ? 0 : userItemMsgList.size()); &#125; class BaseViewHolder extends RecyclerView.ViewHolder&#123; private ImageView ivAvatar; private TextView tvUsername; private TextView tvSign; BaseViewHolder(View itemView) &#123; super(itemView); ivAvatar = (ImageView) itemView.findViewById(R.id.iv_item_avatar); tvUsername = (TextView) itemView.findViewById(R.id.tv_item_username); tvSign = (TextView) itemView.findViewById(R.id.tv_item_sign); itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, tvUsername.getText().toString(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; &#125;&#125; 我把代码全贴上来了，其实这算是一个经常用的模板了吧。RecyclerView 内部自己实现了 ViewHolder 类，所以说使用方便。 下面就是比较有代表性的 recyclerView 代码实现，可以注意注意 setLayoutManager() 函数。 1234567891011private void initViews() &#123; context = getContext(); recyclerView = (RecyclerView) rootView.findViewById(R.id.chatsRecycleView); loadData(); adapterUserItem = new AdapterUserItem(context, userItemMsgList); recyclerView.setLayoutManager(new LinearLayoutManager(context)); recyclerView.setAdapter(adapterUserItem);&#125; 怕篇幅过多，细的知识点不会太陈述，主要是对整个一个 App 实现过程中思考的一个介绍，不会觉得自己无从下手。 。。。。。。。。好像篇幅有点长了，还没有涉及服务端就这么多了。。。剩下的效果大家可以按动图显示的自己实现，方法其实全概括了。 最后说下 TabHost 的一点东西 1234567891011121314151617181920tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; tabList.get(tab.getPosition()).setIcon(ImageManager.imageID[tab.getPosition() + 3]); tabLayout.setTabTextColors( ContextCompat.getColor(AtyMain.this, R.color.colorBlack), ContextCompat.getColor(AtyMain.this, R.color.colorBlue) ); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; tabList.get(tab.getPosition()).setIcon(ImageManager.imageID[tab.getPosition()]); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125;&#125;); 为什么要把下面的代码放在监听中执行，而不是在外面。大家可以做做实验，点击Tab和滑动ViewPager就能发现异同。 1234tabLayout.setTabTextColors( ContextCompat.getColor(AtyMain.this, R.color.colorBlack), ContextCompat.getColor(AtyMain.this, R.color.colorBlue)); 还有前面遗留的登录界面 Tab 上面的字母是大写，怎么解决？大家可以自己查资料，再看看我提供的源码。这次就这样，下次实现剩下的 DressUp，Profile 和聊天界面。再下次就是网络编程啦！","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-1","date":"2017-04-14T03:00:00.000Z","path":"2017/04/14/ZZChatApp1/","text":"GitHub 实现一个类似QQ的社交聊天工具-1准备 AndroidStudio 模拟器 资料 密码: jme4大家将图片复制到drawable供接下来的使用，部分图片源于网络，不做商业用途应该不算侵权吧。如果有，我会删除资源的。 实现目标按照最先开始的计划，我们只实现一个静态的ZZChat界面，考验的就是Android控件的基本知识。如果碰到没见到过的控件可以去Google看开发文档。 实现过程 在看到实现的设计下，我们最先想到的是有四的Activity（欢迎界面，引导页，登录注册，主界面），同时对应四个布局 修改Manifest12345678910111213141516171819AndroidManifest.xml&lt;application android:allowBackup=\"true\" android:icon=\"@drawable/icon\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".aty.AtyWelcome\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".aty.AtyGuide\" /&gt; &lt;activity android:name=\".aty.AtyLoginOrRegister\" /&gt; &lt;activity android:name=\".aty.AtyMain\" /&gt;&lt;/application&gt; 欢迎界面 全屏 1234onCreate()getSupportActionBar().hide();getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); 引导界面只在首次开启时显示 123456789101112131415161718192021222324252627282930313233AtyWelcome.javaprivate void initLoad() &#123; SharedPreferences sharedPreferences = getSharedPreferences(\"zzchat\", MODE_PRIVATE); boolean welcome = sharedPreferences.getBoolean(\"welcome\", true); if (!welcome) &#123; handler.sendEmptyMessageDelayed(GO_HOME, DELAY); &#125; else &#123; handler.sendEmptyMessageDelayed(GO_GUIDE, DELAY); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putBoolean(\"welcome\", false); editor.apply(); &#125;&#125;Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case GO_GUIDE: &#123; goGuide(); break; &#125; case GO_HOME: &#123; goHome(); break; &#125; default: break; &#125; &#125;&#125;; 引导页引导页我们使用一个ViewPager实现，如果之前不熟悉的可以看我的另一个利用ViewPager做的轮播图。 布局 相信看了前面动图的效果对布局实现应该是有底了 123456789101112131415161718192021222324252627282930313233343536373839404142434445aty_guide.xml&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/vp_guide\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;LinearLayout android:orientation=\"horizontal\" android:layout_centerHorizontal=\"true\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"20dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;ImageView android:id=\"@+id/iv_indicator_dot1\" android:src=\"@drawable/selected\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_width=\"10dp\" android:layout_height=\"10dp\" /&gt; &lt;ImageView android:id=\"@+id/iv_indicator_dot2\" android:src=\"@drawable/unselected\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_width=\"10dp\" android:layout_height=\"10dp\" /&gt; &lt;ImageView android:id=\"@+id/iv_indicator_dot3\" android:src=\"@drawable/unselected\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_width=\"10dp\" android:layout_height=\"10dp\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 适配布局 到这了，如何实现ViewPager加载布局就是我们现在应该想的事了。目前可以最先想到和做到的是实现三个加载的布局，为了方便我们只使用一个ImageView来实现，同理其他三个页面也是类似，第三个多加一个Enter入口进入主页。 1234567891011guide_page1.xml&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:src=\"@drawable/shot2\" android:scaleType=\"centerCrop\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; 适配器 现在的情况是有了布局和资源页面，怎么把资源页面加载进布局，这时就要用到Adapter了，也就是适配器。新建一个adapter资源包新建一个AdapterGuideViewPager类继承PagerAdapter 123456789101112131415161718192021222324252627282930313233adapter/AdapterGuideViewPager.javapublic class public class AdapterGuideViewPager extends PagerAdapter&#123; private Context context; private List&lt;View&gt; viewList; public AdapterGuideViewPager(Context context, List&lt;View&gt; viewList) &#123; this.context = context; this.viewList = viewList; &#125; @Override public int getCount() &#123; return viewList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return (view == object); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(viewList.get(position)); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(viewList.get(position)); return viewList.get(position); &#125;&#125; 一定要注意getCount()和isViewFromObject()函数的实现。 有了适配器，只要给adapter添加之前的guide视图作为资源，再给viewPager设置资源适配器。基本效果就实现了。 12345678910111213141516171819202122232425262728293031AtyGuide.javaprivate void initViews() &#123; // load view final LayoutInflater inflater = LayoutInflater.from(this); viewList = new ArrayList&lt;&gt;(); viewList.add(inflater.inflate(R.layout.guide_page1, null)); viewList.add(inflater.inflate(R.layout.guide_page2, null)); viewList.add(inflater.inflate(R.layout.guide_page3, null)); // bind Id with imageView for (int i = 0; i &lt; indicatorDotIds.length; i++) &#123; imageViews[i] = (ImageView) findViewById(indicatorDotIds[i]); &#125; adapterGuideViewPager = new AdapterGuideViewPager(this, viewList); viewPager = (ViewPager) findViewById(R.id.vp_guide); viewPager.setAdapter(adapterGuideViewPager); viewPager.addOnPageChangeListener(this); btnToMain = (Button) (viewList.get(2)).findViewById(R.id.btn_to_main); btnToMain.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(AtyGuide.this, AtyLoginOrRegister.class); startActivity(intent); &#125; &#125;);&#125; 指示器实现 当前页面是第几页，要给用户一个比较明显的提示，可以利用两个不同颜色的小圆点。但是要想知道移动的改变就要实现监听事件 实现onPageSelected()方法就可以了。 1234567891011AtyGuide.javapublic void onPageSelected(int position) &#123; for (int i = 0; i &lt; indicatorDotIds.length; i++) &#123; if (i != position) &#123; imageViews[i].setImageResource(R.drawable.unselected); &#125; else &#123; imageViews[i].setImageResource(R.drawable.selected); &#125; &#125;&#125; 登录注册 界面 这里可以自己设计，我使用TabHost实现，学习使用不同控件，不过布局值得主页的是ID的设置，自己可以试试如果不这样会出现什么效果。 12345678910111213141516&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:background=\"@drawable/shot1\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TabHost android:id=\"@+id/tabHost\"&gt; &lt;TabWidget android:id=\"@android:id/tabs\"&gt; &lt;/TabWidget&gt; &lt;FrameLayout android:id=\"@android:id/tabcontent\"&gt; &lt;LinearLayout&gt; Login Layout &lt;/LinearLayout&gt; &lt;LinearLayout&gt; Register Layout &lt;/LinearLayout&gt; &lt;/FrameLayout&gt; &lt;/TabHost&gt;&lt;/RelativeLayout&gt; 跳转 目前还没进行数据处理，所以我们直接跳转进入界面 123456789101112131415161718192021222324252627282930313233343536373839private void initViews() &#123; tabHost = (TabHost) findViewById(R.id.tabHost); btnLogin = (Button) findViewById(R.id.btn_login); etLoginUsername = (EditText) findViewById(R.id.et_login_username); etLoginPassword = (EditText) findViewById(R.id.et_login_password); btnRegister = (Button) findViewById(R.id.btn_register); etRegisterUsername = (EditText) findViewById(R.id.et_register_username); etRegisterPassword = (EditText) findViewById(R.id.et_register_password); etInsurePassword = (EditText) findViewById(R.id.et_insure_password); tabHost.setup(); tabHost.addTab(tabHost.newTabSpec(\"Login\").setIndicator(\"Login\").setContent(R.id.layout_login)); tabHost.addTab(tabHost.newTabSpec(\"Register\").setIndicator(\"Register\").setContent(R.id.layout_register)); btnLogin.setOnClickListener(this); btnRegister.setOnClickListener(this);&#125;@Overridepublic void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_login: &#123; Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); break; &#125; case R.id.btn_register: &#123; Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); break; &#125; default: break; &#125;&#125; 添加依赖库 如果你遇到上面的bug，说明到现在我们的TabHost是无法工作的，因为缺少一个依赖库。compile ‘com.android.support:design:2x.x.x’ 添加方式是在File-&gt;Project Structure 在弹出的窗口中选择app,之后操作看图此时需要重新Gradle, 这时可能一个错误在build.gradle。按Alt + Enter, 选择忽略就好。 12345678910dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.1' testCompile 'junit:junit:4.12' compile 'com.android.support:design:26.0.0-alpha1'&#125; 主界面之前的页面基本实现，那么主界面如何实现，参考QQ，为了避免控件上的使用难度，我们直接用google提供的DrawerLayout写代码之前先理清思路，这个主界面明显是包含三个页面加一个侧换页面，也就是四个。新建一个view资源文件，创建四个视图类接着新建四个布局供类加载 布局 这个布局有要主页的地方侧滑视图要设置android:layout_gravity=”start” 属性。DrawerLayout最好为根容器推荐如下布局最外层就是DrawerLayout，中间只有一个主内容和一个侧滑布局。你要添加的内容全部在主内容中实现。 这里采用ViewPager + TabLayout 来实现，不熟悉的点这里 123456789101112aty_main.xml&lt;android.support.v4.widget.DrawerLayout &gt; &lt;LinearLayout &gt; &lt;android.support.v4.view.ViewPager &gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;android.support.design.widget.TabLayout &gt; &lt;/android.support.design.widget.TabLayout&gt; &lt;/LinearLayout&gt; &lt;org.fitzeng.zzchat.view.SlideLayout android:layout_gravity=\"start\"&gt;侧换视图&lt;/org.fitzeng.zzchat.view.SlideLayout&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 加载页面 以Chats为例 123456&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:background=\"#09868f\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/LinearLayout&gt; 1234567891011public class LayoutChats extends Fragment &#123; private View rootView; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; rootView = inflater.inflate(R.layout.layout_chats, container, false); return rootView; &#125;&#125; 十分简单，看代码就能懂 之前已经使用了侧滑视图，接下来的三个视图分别对应加载进了三个类。如何将这些视图加载进主界面，前面已经说过如何加载经viewPager了，这里也是一样的。实现一个适配器。 适配器 和前面不一样的是前面直接inflate一个布局进资源列表，而这里是把布局加载进类中了。所以实现方式稍微有点不一样, 这样对布局的内容控制性个人认为较好,因为布局中的子控件逻辑可以在各自的类中实现。看代码就懂了。 123456789101112131415161718192021222324adapter/AdapterMainViewPager.javapublic class AdapterMainViewPager extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); public AdapterMainViewPager(FragmentManager fragmentManager) &#123; super(fragmentManager); &#125; public void addFragment(Fragment fragment) &#123; fragmentList.add(fragment); &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentList.size(); &#125;&#125; 123456789101112131415161718192021222324private void initViews() &#123; drawable = (DrawerLayout) findViewById(R.id.dl_main); viewPager = (ViewPager) findViewById(R.id.vp_main); tabLayout = (TabLayout) findViewById(R.id.tl_main); tabList = new ArrayList&lt;&gt;(); AdapterMainViewPager adapter = new AdapterMainViewPager(getSupportFragmentManager()); adapter.addFragment(new LayoutChats()); adapter.addFragment(new LayoutContacts()); adapter.addFragment(new LayoutMoments()); viewPager.setAdapter(adapter); tabLayout.setupWithViewPager(viewPager); tabList.add(tabLayout.getTabAt(0)); tabList.add(tabLayout.getTabAt(1)); tabList.add(tabLayout.getTabAt(2)); tabList.get(0).setIcon(R.drawable.icon).setText(\"Chats\"); tabList.get(1).setIcon(R.drawable.icon).setText(\"Contacts\"); tabList.get(2).setIcon(R.drawable.icon).setText(\"Moments\");&#125; 代码比较简洁，不知道意思的可以按ctrl点击类名或方法名看源码注释。 到这里基本的效果实现了，不清楚了可以参考阶段性源码。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-0","date":"2017-04-14T02:00:00.000Z","path":"2017/04/14/ZZChatApp0/","text":"GitHub 实现一个类似QQ的社交聊天工具-0 实现效果 原因由于在间间断断的学Android，所以学的知识比较杂，想做个小项目来复习复习。所以之前在课后十天左右的时间完成了一个刚刚具备聊天功能的App，由于这几天拼命的搜寻资料，发现网上并没有一个完整的开发过程的文章。平时也就是看看大牛们的博客学习，现在觉得也要多和大家分享自己学到的知识，共同进步。可能你在这学不到技术深度的东西，但是说不定可以扩展你的技术广度。 目标人群推荐给正处于Android进阶的人群，想写一个App却不知道如何开始。希望我的这些文字对你能有帮助。最少基本过了一遍《第一行代码》，读过《Android群英传》就更好了。由于我是以一个遇到问题解决问题的视角来写的，所以基本会让你的开发过程思路清晰，知道这么做的目的和好处。同时这也是一个开始完全不知道怎么写到实现基本功能的心路历程描述。所以应该会有点价值吧。当然涉及的东西确实有点多，所以不可能一一叙述，欢迎大家留言讨论。 知识数据库相关知识（基本的增删改查）Java（Java可视化界面编程，Socket网络通信）Android 软件Android: Android Studio本地服务器搭建： XAMPP（Apache + MySQL）服务器界面：Eclipse JavaEE 实现思路在电脑上利用Apache + MySQL搭建一个供服务端访问的数据库，有了数据库，就要写一个服务端在电脑上运行，读写数据库数据。开启一个线程一直检测是否有客户发送连接请求，有的话accept，并且给这个连接的用户开一个单独线程供客户端进行通讯。而客户端发送请求给服务器，所以客户端要有一个Action来激活发送请求，也就是我们的点击滑动等事件。但是同时又要接受来自服务端的数据，所以我们要使客户端的Action操作和与服务端通讯分别用两个不同的线程管理。不知道我讲没讲请，下面用图来描述一下。 实现程度由于学业较忙，博客只会更新到目前程度，接下的过程大家可以定制属于你自己的聊天软件。逻辑框架完成度：60%界面设计完成度：40%已实现：服务端，通讯协议，登录，聊天。接下来的功能基本可以根据上面的功能实现。 建议1 使用真机调试2 在整个过程中一定会遇到各种问题 Log + 断点 -&gt; StackOverflow 基本可以解决初学者99%的问题。 开始学习实现一个类似QQ的社交聊天工具-1实现一个类似QQ的社交聊天工具-2实现一个类似QQ的社交聊天工具-3实现一个类似QQ的社交聊天工具-4 最后这个App我会继续在GitHub完善，Blog是否更看课余时间，欢迎大家关注。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个表情键盘控件","date":"2017-04-07T05:00:00.000Z","path":"2017/04/07/EmojiKeyboard/","text":"GitHub 任务目的 学习android控件的封装，viewPager的使用，以及SpannableString对文字加图片的处理 任务描述 能进行表情的输入，删除 表情大于一页，且可以翻页 表情键盘和输入法键盘的弹出逻辑要正确 结果演示 实现过程 一开始，其实也不知道从哪里下手，开始在网上浏览了一些博客，大概有了解决的思路，下面就从我个人的解决思路出发实现一个一个小功能。 step 1: 设计总体布局 采用LinearLayout基本上是上(textView)中(func Bar)下(keyboard)的设计，为了方便控制，keyboard的布局采用自定义，布局代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;org.fitzeng.emojikeyboard.simpleemojikeyboard.SimpleEmojiEditLayout android:id=\"@+id/etSimpleEmojiEdit\" android:hint=\"@string/typeing_something_here\" android:maxLines=\"30\" android:textSize=\"24sp\" android:gravity=\"top\" android:background=\"@null\" android:layout_margin=\"8dp\" android:layout_weight=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" /&gt;&lt;RelativeLayout android:background=\"@color/colorPrimary\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\"&gt; &lt;ImageView android:id=\"@+id/touchIcon\" android:src=\"@mipmap/ic_launcher\" android:layout_centerInParent=\"true\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:contentDescription=\"@string/an_icon_button\" /&gt; &lt;ImageView android:id=\"@+id/btnDelete\" android:src=\"@drawable/icon_delete_normal\" android:layout_alignParentRight=\"true\" android:layout_centerVertical=\"true\" android:layout_width=\"wrap_content\" android:layout_height=\"@dimen/dp40\" android:contentDescription=\"@string/delete\" /&gt;&lt;/RelativeLayout&gt;&lt;org.fitzeng.emojikeyboard.simpleemojikeyboard.SimpleEmojiKeyboardLayout android:id=\"@+id/simpleEmojiKeyboardLayout\" android:visibility=\"gone\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\"&gt;&lt;/org.fitzeng.emojikeyboard.simpleemojikeyboard.SimpleEmojiKeyboardLayout&gt; step 2：大概实现布局控件 设计好控件，就进行实现，通过对func Bar的设计，实现键盘的收缩功能。 1234567891011121314151617181920212223242526272829303132// Click icon to make keyboard hide or appeartouchIcon.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (simpleEmojiKeyboardLayout.getVisibility() == View.GONE) &#123; simpleEmojiKeyboardLayout.setVisibility(View.VISIBLE); simpleEmojiKeyboardLayout.slipUp(); &#125; else &#123; simpleEmojiKeyboardLayout.setVisibility(View.GONE); &#125; &#125;&#125;);// Make keyboard appear when click to editsimpleEmojiEditLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (simpleEmojiKeyboardLayout.getVisibility() == View.GONE) &#123; simpleEmojiKeyboardLayout.slipUp(); simpleEmojiKeyboardLayout.setVisibility(View.VISIBLE); &#125; &#125;&#125;);/** * keyboard slip out */public void slipUp() &#123; LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) this.getLayoutParams(); layoutParams.height = (int) (getMeasuredWidth() * 0.7); this.setLayoutParams(layoutParams);&#125; step 3: 封装表情加入keyboard 将emoji封装成一个对象 1234567891011121314151617181920212223242526public class Smile &#123; private int resId; private String info; public Smile(int resId, String info) &#123; this.resId = resId; this.info = info; &#125; public int getResId() &#123; return resId; &#125; public void setResId(int resId) &#123; this.resId = resId; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125;&#125; 为了方便管理，把表情资源都添加进一个Manager类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class EmojiManager &#123; private static List&lt;Smile&gt; smileList; private static Context context; public EmojiManager(Context context) &#123; this.context = context; &#125; public static List&lt;Smile&gt; getSmileList() &#123; if(smileList==null)&#123; smileList=new ArrayList&lt;&gt;(); smileList.add(new Smile(R.drawable.emotion_1001,\"[e]1001[/e]\")); smileList.add(new Smile(R.drawable.emotion_1002,\"[e]1002[/e]\")); smileList.add(new Smile(R.drawable.emotion_1003,\"[e]1003[/e]\")); smileList.add(new Smile(R.drawable.emotion_1004,\"[e]1004[/e]\")); smileList.add(new Smile(R.drawable.emotion_1005,\"[e]1005[/e]\")); smileList.add(new Smile(R.drawable.emotion_1006,\"[e]1006[/e]\")); smileList.add(new Smile(R.drawable.emotion_1007,\"[e]1007[/e]\")); smileList.add(new Smile(R.drawable.emotion_1008,\"[e]1008[/e]\")); smileList.add(new Smile(R.drawable.emotion_1009,\"[e]1009[/e]\")); smileList.add(new Smile(R.drawable.emotion_1010,\"[e]1010[/e]\")); smileList.add(new Smile(R.drawable.emotion_1011,\"[e]1011[/e]\")); smileList.add(new Smile(R.drawable.emotion_1012,\"[e]1012[/e]\")); smileList.add(new Smile(R.drawable.emotion_1013,\"[e]1013[/e]\")); smileList.add(new Smile(R.drawable.emotion_1014,\"[e]1014[/e]\")); smileList.add(new Smile(R.drawable.emotion_1015,\"[e]1015[/e]\")); smileList.add(new Smile(R.drawable.emotion_1016,\"[e]1016[/e]\")); smileList.add(new Smile(R.drawable.emotion_1017,\"[e]1017[/e]\")); smileList.add(new Smile(R.drawable.emotion_1018,\"[e]1018[/e]\")); smileList.add(new Smile(R.drawable.emotion_1019,\"[e]1019[/e]\")); smileList.add(new Smile(R.drawable.emotion_1020,\"[e]1020[/e]\")); smileList.add(new Smile(R.drawable.emotion_1021,\"[e]1021[/e]\")); smileList.add(new Smile(R.drawable.emotion_1022,\"[e]1022[/e]\")); smileList.add(new Smile(R.drawable.emotion_1023,\"[e]1023[/e]\")); smileList.add(new Smile(R.drawable.emotion_1024,\"[e]1024[/e]\")); smileList.add(new Smile(R.drawable.emotion_1025,\"[e]1025[/e]\")); smileList.add(new Smile(R.drawable.emotion_1026,\"[e]1026[/e]\")); smileList.add(new Smile(R.drawable.emotion_1027,\"[e]1027[/e]\")); smileList.add(new Smile(R.drawable.emotion_1028,\"[e]1028[/e]\")); smileList.add(new Smile(R.drawable.emotion_1029,\"[e]1029[/e]\")); smileList.add(new Smile(R.drawable.emotion_1030,\"[e]1030[/e]\")); smileList.add(new Smile(R.drawable.emotion_1031,\"[e]1031[/e]\")); smileList.add(new Smile(R.drawable.emotion_1032,\"[e]1032[/e]\")); smileList.add(new Smile(R.drawable.emotion_1033,\"[e]1033[/e]\")); smileList.add(new Smile(R.drawable.emotion_1034,\"[e]1034[/e]\")); smileList.add(new Smile(R.drawable.emotion_1035,\"[e]1035[/e]\")); smileList.add(new Smile(R.drawable.emotion_1036,\"[e]1036[/e]\")); smileList.add(new Smile(R.drawable.emotion_1037,\"[e]1037[/e]\")); smileList.add(new Smile(R.drawable.emotion_1038,\"[e]1038[/e]\")); smileList.add(new Smile(R.drawable.emotion_1039,\"[e]1039[/e]\")); smileList.add(new Smile(R.drawable.emotion_1040,\"[e]1040[/e]\")); smileList.add(new Smile(R.drawable.emotion_1041,\"[e]1041[/e]\")); smileList.add(new Smile(R.drawable.emotion_1042,\"[e]1042[/e]\")); smileList.add(new Smile(R.drawable.emotion_1043,\"[e]1043[/e]\")); smileList.add(new Smile(R.drawable.emotion_1044,\"[e]1044[/e]\")); smileList.add(new Smile(R.drawable.emotion_1045,\"[e]1045[/e]\")); smileList.add(new Smile(R.drawable.emotion_1046,\"[e]1046[/e]\")); smileList.add(new Smile(R.drawable.emotion_1047,\"[e]1047[/e]\")); smileList.add(new Smile(R.drawable.emotion_1048,\"[e]1048[/e]\")); smileList.add(new Smile(R.drawable.emotion_1049,\"[e]1049[/e]\")); smileList.add(new Smile(R.drawable.emotion_1050,\"[e]1050[/e]\")); smileList.add(new Smile(R.drawable.emotion_1051,\"[e]1051[/e]\")); smileList.add(new Smile(R.drawable.emotion_1052,\"[e]1052[/e]\")); smileList.add(new Smile(R.drawable.emotion_1053,\"[e]1053[/e]\")); smileList.add(new Smile(R.drawable.emotion_1054,\"[e]1054[/e]\")); smileList.add(new Smile(R.drawable.emotion_1055,\"[e]1055[/e]\")); smileList.add(new Smile(R.drawable.emotion_1056,\"[e]1056[/e]\")); smileList.add(new Smile(R.drawable.emotion_1057,\"[e]1057[/e]\")); smileList.add(new Smile(R.drawable.emotion_1058,\"[e]1058[/e]\")); smileList.add(new Smile(R.drawable.emotion_1059,\"[e]1059[/e]\")); smileList.add(new Smile(R.drawable.emotion_1060,\"[e]1060[/e]\")); smileList.add(new Smile(R.drawable.emotion_1061,\"[e]1061[/e]\")); smileList.add(new Smile(R.drawable.emotion_1062,\"[e]1062[/e]\")); smileList.add(new Smile(R.drawable.emotion_1063,\"[e]1063[/e]\")); smileList.add(new Smile(R.drawable.emotion_1064,\"[e]1064[/e]\")); smileList.add(new Smile(R.drawable.emotion_1065,\"[e]1065[/e]\")); smileList.add(new Smile(R.drawable.emotion_1066,\"[e]1066[/e]\")); smileList.add(new Smile(R.drawable.emotion_1067,\"[e]1067[/e]\")); smileList.add(new Smile(R.drawable.emotion_1068,\"[e]1068[/e]\")); smileList.add(new Smile(R.drawable.emotion_1069,\"[e]1069[/e]\")); smileList.add(new Smile(R.drawable.emotion_1070,\"[e]1070[/e]\")); smileList.add(new Smile(R.drawable.emotion_1071,\"[e]1071[/e]\")); smileList.add(new Smile(R.drawable.emotion_1072,\"[e]1072[/e]\")); smileList.add(new Smile(R.drawable.emotion_1073,\"[e]1073[/e]\")); smileList.add(new Smile(R.drawable.emotion_1074,\"[e]1074[/e]\")); smileList.add(new Smile(R.drawable.emotion_1075,\"[e]1075[/e]\")); smileList.add(new Smile(R.drawable.emotion_1076,\"[e]1076[/e]\")); smileList.add(new Smile(R.drawable.emotion_1077,\"[e]1077[/e]\")); smileList.add(new Smile(R.drawable.emotion_1078,\"[e]1078[/e]\")); smileList.add(new Smile(R.drawable.emotion_1079,\"[e]1079[/e]\")); smileList.add(new Smile(R.drawable.emotion_1080,\"[e]1080[/e]\")); smileList.add(new Smile(R.drawable.emotion_1081,\"[e]1081[/e]\")); smileList.add(new Smile(R.drawable.emotion_1082,\"[e]1082[/e]\")); smileList.add(new Smile(R.drawable.emotion_1083,\"[e]1083[/e]\")); smileList.add(new Smile(R.drawable.emotion_1084,\"[e]1084[/e]\")); smileList.add(new Smile(R.drawable.emotion_1085,\"[e]1085[/e]\")); smileList.add(new Smile(R.drawable.emotion_1086,\"[e]1086[/e]\")); smileList.add(new Smile(R.drawable.emotion_1087,\"[e]1087[/e]\")); smileList.add(new Smile(R.drawable.emotion_1088,\"[e]1088[/e]\")); smileList.add(new Smile(R.drawable.emotion_1089,\"[e]1089[/e]\")); smileList.add(new Smile(R.drawable.emotion_1090,\"[e]1090[/e]\")); smileList.add(new Smile(R.drawable.emotion_1091,\"[e]1091[/e]\")); smileList.add(new Smile(R.drawable.emotion_1092,\"[e]1092[/e]\")); smileList.add(new Smile(R.drawable.emotion_1093,\"[e]1093[/e]\")); smileList.add(new Smile(R.drawable.emotion_1094,\"[e]1094[/e]\")); smileList.add(new Smile(R.drawable.emotion_1095,\"[e]1095[/e]\")); &#125; return smileList; &#125;&#125; 表情资源基本准备好，现在要实现的功能是把表情添加进keyboard。可以通过GridView添加资源。 但是在添加资源时，需要借助适配器，所以还要自己构造一个表情的适配器，基本实现是将一个imageView(表情)添加进LinearLayout作为一个布局元素。 12345678910111213141516171819202122232425262728293031323334353637383940public class EmojiAdapter extends BaseAdapter &#123; private static List&lt;Smile&gt; smileList; private static Context context; public EmojiAdapter(Context context, List&lt;Smile&gt; list) &#123; EmojiAdapter.context = context; smileList = list; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ImageView imageView = new ImageView(context); imageView.setImageResource(smileList.get(position).getResId()); LinearLayout layout = new LinearLayout(context); layout.setGravity(Gravity.CENTER); layout.addView(imageView, dp2px(28), dp2px(28 + 20)); return layout; &#125; private static int dp2px(float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; @Override public int getCount() &#123; return smileList.size(); &#125; @Override public Object getItem(int position) &#123; return smileList.get(position); &#125; @Override public long getItemId(int position) &#123; return smileList.get(position).getResId(); &#125;&#125; 构造好了资源适配器就可以往GridView中加载资源了，再把GridView添加进键盘这个视图 1234567891011private void addEmojiToKeyBoard() &#123; gridView.setNumColumns(8); gridView.setId(R.id.gridView); EmojiAdapter adapter = new EmojiAdapter(getContext(), EmojiManager.getSmileList()); gridView.setAdapter(adapter);&#125;private void init() &#123; addEmojiToKeyBoard(); this.addView(gridView, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);&#125; step 4：实现编辑相关功能模块 现在基本UI已经实现，接下来就是实现对emoji的点击事件监听，从而实现在EditText中显示表情元素 表情的添加，在主Activity实现监听 参考: 在EditText中添加QQ表情 android EditText获取光标位置并插入字符删除字符 1234567891011121314151617181920212223// Called by click an emojigridView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; // Calc lineHeight for ensure icon size int lineHeight = simpleEmojiEditLayout.getLineHeight(); // Create a bitmap Bitmap bitmap = BitmapFactory.decodeResource(getResources(), (int) id); // Set width and height bitmap = Bitmap.createScaledBitmap(bitmap, lineHeight - 10, lineHeight - 10, true); // ImageSpan imageSpan = new ImageSpan(SimpleEmojiKeyboardActivity.this, bitmap); SpannableString spannableString = new SpannableString(\"e\"); spannableString.setSpan(imageSpan, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); // Get texts from textView content = simpleEmojiEditLayout.getText(); // Get cursor location location = simpleEmojiEditLayout.getSelectionStart(); // Insert text content.insert(location, spannableString); &#125;&#125;); 接下来实现func Bar的delete功能 123456789101112btndelete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; content = simpleEmojiEditLayout.getText(); location = simpleEmojiEditLayout.getSelectionStart(); if (location != 0) &#123; content.delete(location - 1, location); &#125; else &#123; Toast.makeText(SimpleEmojiKeyboardActivity.this, \"Nothing to delete\", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;); 到这一个简单的表情键盘就实现了，其中还有很多小bug需要优化，最后把文件名列出来熟悉下这个过程。 emoji Smile EmojiManager EmojiAdapter SimpleEmojiKeyboard SimpleEmojiEditLayout SimpleEmojiKeyboardLayout SimpleEmojiKeyboardActivity 推荐阅读： Android 软键盘和emoji表情切换方案，和微信几乎一样的体验 The handler for the keyboard and panel layout conflict in Android 有机会要写一个更加完善的^_^ Tips: 作为一个Android小白，自然有很多不知道不理解的地方。如果文中有错或者有哪些值得改进的地方，欢迎大家提意见，我很开心能和大家一起交流学习，共同进步。 多谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"实现一个自动无线循环轮播图","date":"2017-04-07T04:00:00.000Z","path":"2017/04/07/SlideShow/","text":"GitHub 任务描述 每隔3秒轮播图自动滚动触摸改轮播图的时候，轮播图停止自动滚动轮播图能够循环滚动，并且第一幅图向左滚动的效果和其他图片滚动的效果要求一致。同理，最后一幅图向右滚动的效果也要求和其他图片的效果一致demo的轮播图至少包含3幅图 实现效果 实现过程 界面设计 首先要知道我们的UI界面是怎么样的，此处的设计如下图所示 代码： 1234567891011121314151617&lt;android.support.v4.view.ViewPager android:id=\"@+id/vpWallpaper\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;LinearLayout android:id=\"@+id/dotLayout\" android:gravity=\"center\" android:orientation=\"horizontal\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"28dp\" android:layout_centerInParent=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\"&gt;&lt;/LinearLayout&gt; 绘制UI(先设计滚动的页面，再设计指示器) 要给ViewPager添加图片，就要设置适配器和资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Set ViewPager Fragment */public static class ViewPagerFragment extends Fragment &#123; private ImageView image; private int id; public ViewPagerFragment(int id) &#123; this.id = id; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_adapter, container, false); image = (ImageView) rootView.findViewById(R.id.image); image.setImageResource(id); return rootView; &#125;&#125;// fragement layout(fragment_adapter)&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:id=\"@+id/image\" android:scaleType=\"fitXY\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:contentDescription=\"@string/image\" /&gt;&lt;/LinearLayout&gt;/** * Set ViewPager Adapter */private class ViewPagerAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); // Add pages to ViewPager private void addPage(Fragment fragment) &#123; fragmentList.add(fragment); &#125; ViewPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentList.size(); &#125;&#125; 添加资源 123456789101112131415161718private static final int[] srcId = &#123; R.drawable.pic0, R.drawable.pic1, R.drawable.pic2, R.drawable.pic3, R.drawable.pic4, R.drawable.pic5, R.drawable.pic6&#125;;ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager());// Add Fragmentsfor (int i = 0; i &lt; 7; i++) &#123; ViewPagerFragment fragment = new ViewPagerFragment(srcId[i]); adapter.addPage(fragment);&#125;viewPager.setAdapter(adapter); 设置循环效果 这里就是难点，要想实现两端的平缓循环滚动可以在两端添加一个cache page，[ 0 ( 1 2 3 4 0) 1]，只显示（）中的页，但是一旦出现cache page立马进行跳转。这样就能实现循环。接下来就是设置计时器了。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Set page change timer */@RequiresApi(api = Build.VERSION_CODES.KITKAT)private void setTimer() &#123; timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; handler.sendEmptyMessage(viewPager.getCurrentItem()); &#125; &#125;, 2000, 2000);&#125;private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 1: case 2: case 3: case 4: case 5: &#123; viewPager.setCurrentItem(msg.what + 1, true); break; &#125; // To make start or end slip smoothly case 0: &#123; viewPager.setCurrentItem(5, false); viewPager.setCurrentItem(6, true); break; &#125; case 6: &#123; viewPager.setCurrentItem(1, false); viewPager.setCurrentItem(2, true); break; &#125; default: break; &#125; &#125;&#125;; 设置平缓的滑动效果但是这种效果不能满足要求,我们可以设计一个滑动延时 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Set Duration */@RequiresApi(api = Build.VERSION_CODES.KITKAT)private void setDuration() &#123; try &#123; Field field = ViewPager.class.getDeclaredField(\"mScroller\"); field.setAccessible(true); FixSpeedScroller scroller = new FixSpeedScroller(this, new AccelerateInterpolator()); scroller.setDuration(500); field.set(viewPager, scroller); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125;/** * Set scroller duration, make it smoothly */class FixSpeedScroller extends Scroller &#123; private int _duration = 1000; FixSpeedScroller(Context context, Interpolator interpolator) &#123; super(context, interpolator); &#125; @Override public void startScroll(int startX, int startY, int dx, int dy) &#123; super.startScroll(startX, startY, dx, dy, _duration); &#125; @Override public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; super.startScroll(startX, startY, dx, dy, _duration); &#125; public void setDuration(int duration) &#123; _duration = duration; &#125;&#125; 基本效果就已经实现了，但是如果有触摸事件发生，我们要另行处理 添加点击监听 123456789101112131415161718viewPager.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; // Cancel the timer if (timer != null) &#123; timer.cancel(); timer = null; &#125; // when slip out cache view(page0, page6), set an another same page instantly if (viewPager.getCurrentItem() == 0) &#123; viewPager.setCurrentItem(5, false); &#125; if (viewPager.getCurrentItem() == 6) &#123; viewPager.setCurrentItem(1, false); &#125; return false; &#125;&#125;); 在滑动监听中恢复计时 12345678910111213141516171819viewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @RequiresApi(api = Build.VERSION_CODES.KITKAT) @Override public void onPageSelected(int position) &#123; &#125; @RequiresApi(api = Build.VERSION_CODES.KITKAT) @Override public void onPageScrollStateChanged(int state) &#123; // if this page was showed by figure slip, then set timer to continue auto slip for next page if (timer == null) &#123; setTimer(); &#125; &#125;&#125;); ViewPager的效果已经实现。下面开始实现指示器 指示器UI 利用两张图片实现选中和没选中效果，每张图片添加进一个LinearLayout，把所有的LinearLayout排列经另一个LinearLayout就可以实现效果 值得注意的是，在添加视图时，要加判断 123if (viewSelected.getParent() != null) &#123; ((ViewGroup) viewSelected.getParent()).removeView(viewSelected);&#125; 否则在有父布局的情况下添加不进别的视图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Create a dot view for an select view * @return view */private View createViewSelected() &#123; LinearLayout view = new LinearLayout(this); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(10, 0, 10, 0); view.setLayoutParams(lp); ImageView imageView = new ImageView(this); imageView.setImageResource(R.drawable.dot_selected); imageView.setLayoutParams(new LinearLayout.LayoutParams(30, 30)); imageView.setScaleType(ImageView.ScaleType.FIT_XY); view.addView(imageView); return view;&#125;/** * Create a dot view for an unselected view * @return view */private View createViewUnselected() &#123; LinearLayout view = new LinearLayout(this); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(10, 0, 10, 0); view.setLayoutParams(lp); ImageView imageView = new ImageView(this); imageView.setImageResource(R.drawable.dot_unselect); imageView.setLayoutParams(new LinearLayout.LayoutParams(30, 30)); imageView.setScaleType(ImageView.ScaleType.FIT_XY); view.addView(imageView); return view;&#125;/** * Refresh the Dot View when sliped * @param selectId current Id */private void refreshDotView(int selectId) &#123; dotLayout.removeAllViews(); for (int i = 1; i &lt; 6; i++) &#123; if (selectId != i) &#123; View viewUnselect = createViewUnselected(); if (viewUnselect.getParent() != null) &#123; ((ViewGroup) viewUnselect.getParent()).removeView(viewUnselect); &#125; dotLayout.addView(viewUnselect); &#125; else &#123; View viewSelected = createViewSelected(); if (viewSelected.getParent() != null) &#123; ((ViewGroup) viewSelected.getParent()).removeView(viewSelected); &#125; dotLayout.addView(viewSelected); &#125; &#125;&#125; 实现指示器功能 UI实现了之后就是实现指示功能就是直接在PageChange监听处加码就可以了，逻辑很简单，不过注意在恶劣环境下有可能会滑到cache page，这是传入的page ID要进行相应的变换 123456789101112131415161718192021222324252627282930313233// Delay to change dotviewTimer timer = new Timer();timer.schedule(new TimerTask() &#123; @Override public void run() &#123; handler.sendEmptyMessage(DOT_VIEW_CHANGE_SELECTED); &#125;&#125;, 500);// Refresh the dotView when page was loadedcase DOT_VIEW_CHANGE_SELECTED: int currentId = viewPager.getCurrentItem(); switch (currentId) &#123; case 0: &#123; refreshDotView(5); break; &#125; case 1: case 2: case 3: case 4: case 5: &#123; refreshDotView(currentId); break; &#125; case 6: &#123; refreshDotView(1); break; &#125; default: break; &#125; onCreate()调用顺序如下 12345678910public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_wallpaper); init(); listener(); setTimer(); setDuration();&#125; 不足不足比较多，在极端的操作下不流畅，比如在设置的延时中滑动次数过多会造成切换不自然，在手指滑动时更好的做法是直接监听手机的移动速度进行相关图片的移动。还有就是耗内存，内存溢出的话，可以自己在Manifest文件加两句代码 12android:hardwareAccelerated=\"false\"android:largeHeap=\"true\"","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"自定义滑动删除列表","date":"2017-04-07T03:00:00.000Z","path":"2017/04/07/SlideDeleteList/","text":"GitHub 任务描述 实现一个可以滑动删除的ListView列表，列表中的每一行可以通过从左向右滑动显示出删除按钮，点击该按钮之后删除该行 实现效果 实现过程 最开始还是要设计layout，这决定着你的代码写法。 layout activity_listview listitem content_view menu_view 我们可以把每一个Item设为一个布局控件，也就是listitem 1234567891011121314151617&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\"&gt; &lt;LinearLayout android:id=\"@+id/content\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/menu\" android:orientation=\"horizontal\" android:layout_width=\"80dp\" android:layout_height=\"match_parent\" &gt; &lt;/LinearLayout&gt;&lt;/merge&gt; 接着分别连个布局设置content和menu 12345678910111213141516171819202122232425262728content_view&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/textView\" android:text=\"@string/init_text\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:gravity=\"center_vertical\" android:layout_marginLeft=\"20dp\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt;menu_view&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/delete\" android:text=\"@string/delete\" android:textAllCaps=\"false\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:background=\"@color/colorAccent\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; 接下来就很清楚了。利用listview添加控件listitem作为适配器的布局。 ViewHolder缓存加载 避免重复加载控件，采用缓存机制是比较合理的下面我们看看adapter的getView() 1234567891011121314151617181920212223242526272829303132333435363738394041public View getView(final int position, View convertView, ViewGroup parent) &#123; ViewHolder holder; SlideItemView slideItemView = (SlideItemView) convertView; if (convertView == null) &#123; // get content and menu view View contentView = inflater.inflate(R.layout.content_view, null); View menuView = inflater.inflate(R.layout.menu_view, null); // add content and menu to slideItemView slideItemView = new SlideItemView(context); slideItemView.setContentView(contentView); slideItemView.setMenuView(menuView); // setting widgets holder = new ViewHolder(contentView, menuView); // setting slide listener slideItemView.setOnSlideListener((SlideItemView.OnSlideListener) context); slideItemView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; // init widgets ItemMsg itemMsg = itemMsgList.get(position); itemMsg.setSlideItemView(slideItemView); itemMsg.getSlideItemView().shrink(); holder.text.setText(itemMsg.getContent()); holder.btnDel.setText(R.string.delete); holder.btnDel.setOnClickListener((View.OnClickListener) context); return slideItemView;&#125;private final class ViewHolder &#123; TextView text; Button btnDel; ViewHolder(View content, View menu) &#123; text = (TextView) content.findViewById(R.id.textView); btnDel = (Button) menu.findViewById(R.id.delete); &#125;&#125; 代码基本都有注释，逻辑比较清晰，主要是对适配器的控件初始化。注意返回的是slideItemView，同时也设置了监听，所以此处是加载两个布局（content,menu）合成一个slideItemView，这样便于以后的布局更改。也方便视图的添加和控件的监测。 构造slideItemView 部分函数 12345678910111213141516private void initView() &#123; Context context = getContext(); scroller = new Scroller(context); // inflate layout View.inflate(context, R.layout.listitem, this); contentView = (LinearLayout) findViewById(R.id.content); menuView = (LinearLayout) findViewById(R.id.menu);&#125;public void setContentView(View content) &#123; contentView.addView(content);&#125;public void setMenuView(View menu) &#123; menuView.addView(menu);&#125; 滑动监听 这个才是重点难点代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public boolean onTouchEvent(MotionEvent event) &#123; // Get event start coordinate int x = (int) event.getX(); int y = (int) event.getY(); int scrollX = getScrollX(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; // if another event unfinished, then finished if (!scroller.isFinished()) &#123; scroller.abortAnimation(); &#125; // get menu width btnWidth = menuView.getMeasuredWidth(); if (onSlideListener != null) &#123; onSlideListener.onSlide(this, OnSlideListener.STATUS_SLIDE_SCROLL); &#125; // represent the event was handled or consumed, see the resource code return true; &#125; case MotionEvent.ACTION_MOVE: &#123; // get offset int offsetX = x - lastX; int offsetY = y - lastY; // if offsetX miner than offsetY or offsetY more than 20, then cancel this event if (offsetY &gt; 20) &#123; break; &#125; int newScrollX = scrollX - offsetX; if (offsetX != 0) &#123; if (newScrollX &lt; 0) &#123; newScrollX = 0; &#125; else if (newScrollX &gt; btnWidth)&#123; newScrollX = btnWidth; &#125; scrollTo(newScrollX, 0); &#125; break; &#125; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: &#123; int newScroll = 0; // more than half of button width, scroll out. otherwise scroll in. if (scrollX - btnWidth * 0.7 &gt; 0) &#123; newScroll = btnWidth; &#125; smoothScrollTo(newScroll); // set item slide status if (onSlideListener != null) &#123; onSlideListener.onSlide(this, newScroll == 0 ? OnSlideListener.STATUS_SLIDE_OFF : OnSlideListener.STATUS_SLIDE_ON); &#125; break; &#125; &#125; lastX = x; lastY = y; return super.onTouchEvent(event);&#125;private void smoothScrollTo(int x) &#123; int scrollX = getScrollX(); int offsetX = x - scrollX; scroller.startScroll(scrollX, 0, offsetX, 0, Math.abs(offsetX)); invalidate();&#125;@Overridepublic void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; scrollTo(scroller.getCurrX(), scroller.getCurrY()); postInvalidate(); &#125;&#125;public void shrink() &#123; if (getScaleX() != 0) &#123; this.smoothScrollTo(0); &#125;&#125; 参考 列表滑动删除效果 Android触摸屏事件派发机制详解与源码分析一(View篇) android中的dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent 后两篇主要是讲Android中的事件分发，也就是为什么在MotionEvent.ACTION_DOWN中return true才能实现滑动效果。看了源码我们知道true代表这个控件的函数消耗这个事件，不会再分发，所以我们后面的处理事件的代码才能够执行。 设置接口 123456789101112131415161718192021222324interface OnSlideListener &#123; int STATUS_SLIDE_OFF = 0; int STATUS_SLIDE_ON = 1; int STATUS_SLIDE_SCROLL = 2; void onSlide(View view, int status);&#125;public void setOnSlideListener(OnSlideListener onSlideListener) &#123; this.onSlideListener = onSlideListener;&#125;@Overridepublic void onSlide(View view, int status) &#123; // if last slide item is on, close it if (mLastSlideViewWithStatusOn != null &amp;&amp; mLastSlideViewWithStatusOn != view) &#123; mLastSlideViewWithStatusOn.shrink(); &#125; // if a new item slide out, mark it if (status == STATUS_SLIDE_ON) &#123; mLastSlideViewWithStatusOn = (SlideItemView) view; &#125;&#125; 这个接口的主要目的是对这个ListView中Item的管理，保证当前只有一个侧滑出来。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"实现一个TAB布局","date":"2017-04-07T02:30:00.000Z","path":"2017/04/07/TabLayout/","text":"GitHub 任务描述 实现常见的标签tab，并且点击tab跳转至对应页面实现页面滑动效果 实现效果 TabLayout + ViewPager（GIF） 实现过程 绘制页面 12345678910111213141516171819&lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPager\" android:scrollbars=\"none\" android:layout_weight=\"8\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;android.support.design.widget.TabLayout android:id=\"@+id/tabLayout\" android:layout_weight=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" app:tabGravity=\"fill\" app:tabIndicatorHeight=\"0dp\" app:tabMode=\"fixed\" app:tabSelectedTextColor=\"#FF4081\" app:tabTextColor=\"#000\"&gt;&lt;/android.support.design.widget.TabLayout&gt; 需要在配置文件中添加 compile ‘com.android.support:design:23.2.0’ 准备Adapter 1234567891011121314151617181920212223242526272829class ViewPagerAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); private List&lt;String&gt; fragmentTitleList = new ArrayList&lt;&gt;(); ViewPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; void addPage(Fragment fragment, String title) &#123; fragmentList.add(fragment); fragmentTitleList.add(title); &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentTitleList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return fragmentTitleList.get(position); &#125;&#125; 准备Fragment布局 1234567891011121314151617181920public class ViewPagerFragment extends Fragment &#123; private String content; public ViewPagerFragment(String content) &#123; this.content = content; &#125; public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_view_pager, container, false); TextView tvContent = (TextView) rootView.findViewById(R.id.tvContent); tvContent.setText(content); return rootView; &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125;&#125; 12345678&lt;TextView android:id=\"@+id/tvContent\" android:textSize=\"30sp\" android:hint=\"@string/default_text\" android:layout_gravity=\"center\" android:textAlignment=\"center\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 为了方便，此处所有Fragment共用一个 初始化布局 123456789101112131415161718192021222324252627/** * Init Layout, Load Fragments and draw Layouts. */private void initLayout() &#123; viewPager = (ViewPager) findViewById(R.id.viewPager); tabLayout = (TabLayout) findViewById(R.id.tabLayout); ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager()); // Add Fragments for (int i = 0; i &lt; 4; i++) &#123; adapter.addPage(new ViewPagerFragment(\"PAGE\" + i), \"PAGE\" + i); &#125; viewPager.setAdapter(adapter); // Connect TabLayout and ViewPage tabLayout.setupWithViewPager(viewPager); // Draw Tab View for (int i = 0; i &lt; 4; i++) &#123; tabListView.add(tabLayout.getTabAt(i)); if (i == 0) &#123; tabListView.get(i).setIcon(R.mipmap.selected_icon); &#125; else &#123; tabListView.get(i).setIcon(R.mipmap.ic_launcher); &#125; tabListView.get(i).setText(\"PAGE\" + i); &#125;&#125; 设置监听 123456789101112131415161718192021222324/** * Setting Tab Click Listener */private void initEvents() &#123; tabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; // Called when the tab was selected tabListView.get(tab.getPosition()).setIcon(R.mipmap.selected_icon); viewPager.setCurrentItem(tab.getPosition()); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; // Called when a tab from selected switch to unselected tabListView.get(tab.getPosition()).setIcon(R.mipmap.ic_launcher); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; // Called when a tab selected more than twice consecutively &#125; &#125;);&#125; 不足 利用控件已有的性质，基本的Tab切换已经实现。但是没有自己手动实现滑动等控件的效果。实现方式有很多种，以后来补充。 Tips: 作为一个Android小白，自然有很多不知道不理解的地方。如果文中有错或者有哪些值得改进的地方，欢迎大家提意见，我很开心能和大家一起交流学习，共同进步。 多谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"复现ANR","date":"2017-04-07T02:00:00.000Z","path":"2017/04/07/RecurrentANR/","text":"GitHub 任务描述写出不少于3种常见ANR错误的Android代码 主线程复现ANR BroadcastReceiver复现ANR Service复现ANR 1.什么是ANR? ANR(Application Not Responding),应用程序无响应. 参考ANR完全解析 2.ANR的三种类型 KeyDispatchTimeout(5 seconds) 主要类型按键或触摸事件在特定时间内无响应 BroadcastTimeout(10 seconds) BroadcastReceiver在特定时间内无法处理完成 ServiceTimeout(20 seconds) 小概率类型 Service在特定的时间内无法处理完成 3.复现ANRI 主线程复现ANR 代码 1234567891011121314/** * Recurrent ANR in main Thread */private void mainThreadANR() &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"MainThreadANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(20 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(\"MainThreadANR\", \"mainThreadANR() Done\");&#125; 结果 II BroadcastReceiver复现ANR 代码 1234567891011121314public class BroadcastANR extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"BroadcastANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(80 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; III Service复现ANR 代码 1234567891011121314151617181920public class ServiceANR extends Service &#123; @Override public void onCreate() &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"ServiceANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(60 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 4.避免ANR要想避免ANR，首先要分析为什么会发生ANR，主要是在一些不能耗时操作的函数中处理代码的时间过长，所以把耗时长的程序写入其他子进程中就可以避免。ANR机制以及问题分析写的很详细。 首先我们看看Log 12345678MainThreadANR: I/MainThreadANR: myLooper=Looper (main, tid 1) &#123;13467e36&#125;; mainLooper=Looper (main, tid 1) &#123;13467e36&#125;BroadcastANR:I/BroadcastANR: myLooper=Looper (main, tid 1) &#123;33c6137&#125;; mainLooper=Looper (main, tid 1) &#123;33c6137&#125;ServiceANR:I/ServiceANR: myLooper=Looper (main, tid 1) &#123;303e756a&#125;; mainLooper=Looper (main, tid 1) &#123;303e756a&#125; 前面的三个ANR都有一个特点，那就是当前的线程都是主线程，细心点会发现其实还有一句丢帧Log打印 1Skipped 1204 frames! The application may be doing too much work on its main thread. 我实现下通过在主线程中创建一个新线程的方法来避免ANR 代码 1234567891011121314151617181920/** * Deal ANR in main Thread */private void mainThreadNotANR() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"MainThreadNotANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(20 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(\"MainThreadNotANR\", \"Thread Run() Done\"); &#125; &#125;).start(); Log.i(\"MainThreadNotANR\", \"mainThreadNotANR() Done\");&#125; 下面我们来对比下和主线程中直接处理的Log有什么不同 12345678910111213141516MainThreadNotANR:点击按钮MainThreadNotANRI/MainThreadNotANR: mainThreadNotANR() DoneI/MainThreadNotANR: myLooper=null; mainLooper=Looper (main, tid 1) &#123;303e756a&#125;I/MainThreadNotANR: ThreadRun() DoneW/art: Suspending all threads took: 6.032msMainThreadANR:点击按钮MainThreadANRI/MainThreadANR: myLooper=Looper (main, tid 1) &#123;303e756a&#125;; mainLooper=Looper (main, tid 1) &#123;303e756a&#125;I/MainThreadANR: mainThreadANR() Done再多次点击按钮MainThreadANRI/Choreographer: Skipped 1200 frames! The application may be doing too much work on its main thread.I/MainThreadANR: myLooper=Looper (main, tid 1) &#123;303e756a&#125;; mainLooper=Looper (main, tid 1) &#123;303e756a&#125;I/art: Thread[5,tid=2037,WaitingInMainSignalCatcherLoop,Thread*=0xef70d400,peer=0x12c00080,&quot;Signal Catcher&quot;]: reacting to signal 3I/art: Wrote stack traces to &apos;/data/anr/traces.txt&apos; 从Log中可以看出MainThreadNotANR中先打印mainThreadNotANR() Done后打印ThreadRun() Done说明代码没在MainThreadNotANR这个线程中运行，从myLooper=null; mainLooper=Looper (main, tid 1) {303e756a}可以验证我们的猜想。而MainThreadANR中就很明显，各种丢帧奔溃。不过I/art: Wrote stack traces to ‘/data/anr/traces.txt’告诉我们可以在/data/anr/traces.txt中追踪奔溃的缘由1234567891011121314151617181920212223242526traces.txtDALVIK THREADS (18):&quot;main&quot; prio=5 tid=1 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x73581970 self=0xf4306800 | sysTid=2030 nice=0 cgrp=apps sched=0/0 handle=0xf7761160 | state=S schedstat=( 545706267 72336573 314 ) utm=30 stm=23 core=3 HZ=100 | stack=0xff7c7000-0xff7c9000 stackSize=8MB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x2ce90c0d&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x2ce90c0d&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at org.fitzeng.recurrentanr.MainActivity.mainThreadANR(MainActivity.java:47) at org.fitzeng.recurrentanr.MainActivity.onClick(MainActivity.java:81) at android.view.View.performClick(View.java:4756) at android.view.View$PerformClick.run(View.java:19749) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:135) at android.app.ActivityThread.main(ActivityThread.java:5221) at java.lang.reflect.Method.invoke!(Native method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:899) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:694) 这是定位ANR的有效手段。 Tips: 作为一个Android小白，自然有很多不知道不理解的地方。如果文中有错或者有哪些值得改进的地方，欢迎大家提意见，我很开心能和大家一起交流学习，共同进步。 多谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]}]