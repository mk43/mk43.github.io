[{"title":"NumPy 官方快速入门教程(译)","date":"2018-02-04T03:27:00.000Z","path":"2018/02/04/NumPyOfficialQuickstartTutorial/","text":"写在前面：本来是学习下 \\( NumPy \\)，看到官网的入门教程想跟着实验一下，怕不常用，而我这人健忘，所以记录下来。索性就照着翻译一下，同样可以提升自己的阅读和写作能力，需要的可以存一下。当然，本人水平有限，有错误的地方欢迎大家指正。这里是基于 \\( NumPy\\ v1.13.dev0\\ Manual \\) 翻译的。截止时间\\( 2018/02/04 \\) 快速入门教程1 准备工作在你浏览这个指导之前，你应该懂一点 \\( Python \\) 。如果你想回顾一下可以看Python tutorial。如果你想把教程的代码跑起来，必须安装一些软件，请参考http://scipy.org/install.html 2 基础知识\\( NumPy \\) 的主要操作对象是同类型的多维数组。它是一个由正整数元组索引，元素类型相同的表（通常元素是数字）。在 \\( NumPy \\) 维度被称为 axes, axes 的数量称为 rank。 例如，在 \\( 3D \\) 空间的一个点 \\( [1, 2, 1] \\) 是一个 rank = 1 的数组，因为它只有一个 axes。这个 axes 的长度是 \\( 3 \\)。在下面这个例子中，数组 rank = 2 （它是 \\( 2 \\)维的）。第一维（axes）长度是 \\( 2 \\)，第二位长度是 \\( 3 \\) 12[[ 1., 0., 0. ], [ 0., 1., 2. ]] \\( NumPy \\) 的数组类是 ndarray。也可以叫做 array。说到这里，numpy.array 和标准 ( Python \\) 库中的 array.array 是不一样的，它只能处理一维的数组和提供更少的功能。ndarray 对象的一些重要属性如下： ndarray.ndim 数组的 axes （维数）数值大小。在 \\( Python \\) 中维数的大小可以参考 rank ndarray.shape 数组的维数，这是由每个维度的大小组成的一个元组。对于一个 \\( n \\) 行 \\( m \\) 列的矩阵。shape 是 (n, m)。由 shape 元组的长度得出 rank 或者维数 ndim。 ndarray.size 数组元素的个数总和，这等于 shape 元组数字的乘积。 ndarray.dtype 在数组中描述元素类型的一个对象。它是一种可以用标准的 \\( Python \\) 类型创建和指定的类型。另外，\\( NumPy \\)也提供了它自己的类型：numpy.int32，numpy.int16，numpy.float64…… ndarray.itemsize 数组中每个元素所占字节数。例如，一个 float64 的 itemsize 是 \\( 8 ( = 64/8bit) \\)，complex32 的 itemsize 是 \\( 4 ( = 32/8bit) \\)。它和 ndarray.dtype.itemsize 是相等的。 ndarray.data 数组实际元素的缓存区。通常来说，我们不需要使用这个属性，因为我们会使用索引的方式访问数据。 2.1 例子1234567891011121314151617181920212223&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(15).reshape(3, 5)&gt;&gt;&gt; aarray([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]])&gt;&gt;&gt; a.shape(3, 5)&gt;&gt;&gt; a.ndim2&gt;&gt;&gt; a.dtype.name&apos;int64&apos;&gt;&gt;&gt; a.itemsize8&gt;&gt;&gt; a.size15&gt;&gt;&gt; type(a)&lt;type &apos;numpy.ndarray&apos;&gt;&gt;&gt;&gt; b = np.array([6, 7, 8])&gt;&gt;&gt; barray([6, 7, 8])&gt;&gt;&gt; type(b)&lt;type &apos;numpy.ndarray&apos;&gt; 2.2 创建数组这里有几种方法创建数组。 例如，你可以使用 array 函数从一个常规的 \\( Python \\) 列表或元组创建一个数组。创建的数组类型是从原始序列中的元素推断出来的。 123456789&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([2,3,4])&gt;&gt;&gt; aarray([2, 3, 4])&gt;&gt;&gt; a.dtypedtype(&apos;int64&apos;)&gt;&gt;&gt; b = np.array([1.2, 3.5, 5.1])&gt;&gt;&gt; b.dtypedtype(&apos;float64&apos;) 一个常见错误是在调用 array 函数时，传递的参数是多个数值而不是一个单独的数字列表。 12&gt;&gt;&gt; a = np.array(1,2,3,4) # WRONG&gt;&gt;&gt; a = np.array([1,2,3,4]) # RIGHT array 将序列转化成高维数组 1234&gt;&gt;&gt; b = np.array([(1.5,2,3), (4,5,6)])&gt;&gt;&gt; barray([[ 1.5, 2. , 3. ], [ 4. , 5. , 6. ]]) 数组的类型也能够在创建时具体指定： 1234&gt;&gt;&gt; c = np.array( [ [1,2], [3,4] ], dtype=complex )&gt;&gt;&gt; carray([[ 1.+0.j, 2.+0.j], [ 3.+0.j, 4.+0.j]]) 通常，我们都是知道数组的大小而不知道其中的原始数据。因此 \\( NumPy \\) 提供了几个用占位符的函数去创建数组。这样可以最小化增加数组的成本，增加数组是一项很耗费资源的操作。 zeros 函数创建一个全是 \\( 0 \\) 的数组，ones 函数创建全是 \\( 1 \\) 的数组，empty 创建一个随机的数组。默认创建数组的类型是 float64。 1234567891011121314&gt;&gt;&gt; np.zeros( (3,4) )array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]])&gt;&gt;&gt; np.ones( (2,3,4), dtype=np.int16 ) # dtype can also be specifiedarray([[[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]], [[ 1, 1, 1, 1], [ 1, 1, 1, 1], [ 1, 1, 1, 1]]], dtype=int16)&gt;&gt;&gt; np.empty( (2,3) ) # uninitialized, output may varyarray([[ 3.73603959e-262, 6.02658058e-154, 6.55490914e-260], [ 5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) 为了创建数字序列，\\( NumPy \\) 提供了一个和 range 相似的函数，可以返回一个数组而不是列表。 1234&gt;&gt;&gt; np.arange( 10, 30, 5 )array([10, 15, 20, 25])&gt;&gt;&gt; np.arange( 0, 2, 0.3 ) # it accepts float argumentsarray([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) 当 arange 的参数是浮点型的，由于有限的浮点精度，通常不太可能去预测获得元素的数量。出于这个原因，通常选择更好的函数 linspace，他接收我们想要的元素数量而不是步长作为参数。 12345&gt;&gt;&gt; from numpy import pi&gt;&gt;&gt; np.linspace( 0, 2, 9 ) # 9 numbers from 0 to 2array([ 0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ])&gt;&gt;&gt; x = np.linspace( 0, 2*pi, 100 ) # useful to evaluate function at lots of points&gt;&gt;&gt; f = np.sin(x) 参考array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, numpy.random.rand, numpy.random.randn, fromfunction, fromfile 2.3 打印数组当你打印数组时，\\( NumPy \\) 显示出来和嵌套的列表相似，但是具有以下布局： 最后一个 axis 从左到右打印， 第二到最后一个从上到下打印， 剩余的也是从上到下打印，每一片通过一个空行隔开。 12345678910111213141516171819&gt;&gt;&gt; a = np.arange(6) # 1d array&gt;&gt;&gt; print(a)[0 1 2 3 4 5]&gt;&gt;&gt;&gt;&gt;&gt; b = np.arange(12).reshape(4,3) # 2d array&gt;&gt;&gt; print(b)[[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]]&gt;&gt;&gt;&gt;&gt;&gt; c = np.arange(24).reshape(2,3,4) # 3d array&gt;&gt;&gt; print(c)[[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] 参考下文来获取更多 reshape 的细节。 如果一个数组太大而不能被打印，那么 \\( NumPy \\) 会自动忽略中间的只打印角上的数据。 1234567891011&gt;&gt;&gt; print(np.arange(10000))[ 0 1 2 ..., 9997 9998 9999]&gt;&gt;&gt;&gt;&gt;&gt; print(np.arange(10000).reshape(100,100))[[ 0 1 2 ..., 97 98 99] [ 100 101 102 ..., 197 198 199] [ 200 201 202 ..., 297 298 299] ..., [9700 9701 9702 ..., 9797 9798 9799] [9800 9801 9802 ..., 9897 9898 9899] [9900 9901 9902 ..., 9997 9998 9999]] 为了取消这种行为，强制 \\( NumPy \\) 去打印整个数组，你可以通过 set_printoptions 改变打印选项。 1&gt;&gt;&gt; np.set_printoptions(threshold=&apos;nan&apos;) 2.4 基本操作在数组上的算数运算应用于每个元素。并创建一个用结果填充的新的数组。 12345678910111213&gt;&gt;&gt; a = np.array( [20,30,40,50] )&gt;&gt;&gt; b = np.arange( 4 )&gt;&gt;&gt; barray([0, 1, 2, 3])&gt;&gt;&gt; c = a-b&gt;&gt;&gt; carray([20, 29, 38, 47])&gt;&gt;&gt; b**2array([0, 1, 4, 9])&gt;&gt;&gt; 10*np.sin(a)array([ 9.12945251, -9.88031624, 7.4511316 , -2.62374854])&gt;&gt;&gt; a&lt;35array([ True, True, False, False], dtype=bool) 在 \\( NumPy \\) 数组的 * 操作不像其他的矩阵语言。矩阵乘法通过 dot 函数进行模拟。 12345678910111213&gt;&gt;&gt; A = np.array( [[1,1],... [0,1]] )&gt;&gt;&gt; B = np.array( [[2,0],... [3,4]] )&gt;&gt;&gt; A*B # elementwise productarray([[2, 0], [0, 4]])&gt;&gt;&gt; A.dot(B) # matrix productarray([[5, 4], [3, 4]])&gt;&gt;&gt; np.dot(A, B) # another matrix productarray([[5, 4], [3, 4]]) 想 += 和 *= 操作之类的，直接在原数组上做修改，不会创建新数组。 1234567891011121314&gt;&gt;&gt; a = np.ones((2,3), dtype=int)&gt;&gt;&gt; b = np.random.random((2,3))&gt;&gt;&gt; a *= 3&gt;&gt;&gt; aarray([[3, 3, 3], [3, 3, 3]])&gt;&gt;&gt; b += a&gt;&gt;&gt; barray([[ 3.417022 , 3.72032449, 3.00011437], [ 3.30233257, 3.14675589, 3.09233859]])&gt;&gt;&gt; a += b # b is not automatically converted to integer typeTraceback (most recent call last): ...TypeError: Cannot cast ufunc add output from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) with casting rule &apos;same_kind&apos; 在不同数组类型之间的操作，结果数组的类型趋于更普通或者更精确的一种（称为向上转型） 123456789101112131415&gt;&gt;&gt; a = np.ones(3, dtype=np.int32)&gt;&gt;&gt; b = np.linspace(0,pi,3)&gt;&gt;&gt; b.dtype.name&apos;float64&apos;&gt;&gt;&gt; c = a+b&gt;&gt;&gt; carray([ 1. , 2.57079633, 4.14159265])&gt;&gt;&gt; c.dtype.name&apos;float64&apos;&gt;&gt;&gt; d = np.exp(c*1j)&gt;&gt;&gt; darray([ 0.54030231+0.84147098j, -0.84147098+0.54030231j, -0.54030231-0.84147098j])&gt;&gt;&gt; d.dtype.name&apos;complex128&apos; 许多类似于求数组所有元素的和的一元操作都是作为 ndarray 类的方法实现的。 12345678910&gt;&gt;&gt; a = np.random.random((2,3))&gt;&gt;&gt; aarray([[ 0.18626021, 0.34556073, 0.39676747], [ 0.53881673, 0.41919451, 0.6852195 ]])&gt;&gt;&gt; a.sum()2.5718191614547998&gt;&gt;&gt; a.min()0.1862602113776709&gt;&gt;&gt; a.max()0.6852195003967595 默认情况下，尽管这些操作是应用于一个数字列表，可以无视它的形状。当时，通过指定 axis 参数可以将操作应用于数组的某一具体 axis 。 12345678910111213141516&gt;&gt;&gt; b = np.arange(12).reshape(3,4)&gt;&gt;&gt; barray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])&gt;&gt;&gt;&gt;&gt;&gt; b.sum(axis=0) # sum of each columnarray([12, 15, 18, 21])&gt;&gt;&gt;&gt;&gt;&gt; b.min(axis=1) # min of each rowarray([0, 4, 8])&gt;&gt;&gt;&gt;&gt;&gt; b.cumsum(axis=1) # cumulative sum along each rowarray([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38]]) 2.5 通用功能\\( NumPy \\) 提供了很多数学上的函数，例如 sin、cos、exp。这些被叫做 “universal functions” (ufunc)。在 \\( NumPy \\）中这些函数是操作数组数字，产生一个数组作为输出。 12345678910&gt;&gt;&gt; B = np.arange(3)&gt;&gt;&gt; Barray([0, 1, 2])&gt;&gt;&gt; np.exp(B)array([ 1. , 2.71828183, 7.3890561 ])&gt;&gt;&gt; np.sqrt(B)array([ 0. , 1. , 1.41421356])&gt;&gt;&gt; C = np.array([2., -1., 4.])&gt;&gt;&gt; np.add(B, C)array([ 2., 0., 6.]) 参考all, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, std, sum, trace, transpose, var, vdot, vectorize, where 2.6 索引，切片和迭代一维数组可以被索引，切片和迭代，就像列表和其他Python序列一样。 12345678910111213141516171819202122232425&gt;&gt;&gt; a = np.arange(10)**3&gt;&gt;&gt; aarray([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729])&gt;&gt;&gt; a[2]8&gt;&gt;&gt; a[2:5]array([ 8, 27, 64])&gt;&gt;&gt; a[:6:2] = -1000 # equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000&gt;&gt;&gt; aarray([-1000, 1, -1000, 27, -1000, 125, 216, 343, 512, 729])&gt;&gt;&gt; a[ : :-1] # reversed aarray([ 729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000])&gt;&gt;&gt; for i in a:... print(i**(1/3.))...nan1.0nan3.0nan5.06.07.08.09.0 多维数组对于每个 axis 都有一个索引，这些索引用逗号分隔。 12345678910111213141516171819&gt;&gt;&gt; def f(x,y):... return 10*x+y...&gt;&gt;&gt; b = np.fromfunction(f,(5,4),dtype=int)&gt;&gt;&gt; barray([[ 0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33], [40, 41, 42, 43]])&gt;&gt;&gt; b[2,3]23&gt;&gt;&gt; b[0:5, 1] # each row in the second column of barray([ 1, 11, 21, 31, 41])&gt;&gt;&gt; b[ : ,1] # equivalent to the previous examplearray([ 1, 11, 21, 31, 41])&gt;&gt;&gt; b[1:3, : ] # each column in the second and third row of barray([[10, 11, 12, 13], [20, 21, 22, 23]]) 当提供的索引少于 axis 的数量时，缺失的索引按完全切片考虑。 12&gt;&gt;&gt; b[-1] # the last row. Equivalent to b[-1,:]array([40, 41, 42, 43]) b[i] 这种表达中括号中的 i 后面可以跟很多用 : 表示其它 axis 的实例。\\( NumPy \\) 也允许使用三个点代替 b[i, ...] 这三个点(...)表示很多完整索引元组中的冒号。例如，x 的 rank = 5 有： x[1, 2, ...] = x[1, 2, :, :, :] x[..., 3] = x[:, :, :, :, 3] x[4, ..., 5, :] = x[4, :, :, 5, :] 123456789101112&gt;&gt;&gt; c = np.array( [[[ 0, 1, 2], # a 3D array (two stacked 2D arrays)... [ 10, 12, 13]],... [[100,101,102],... [110,112,113]]])&gt;&gt;&gt; c.shape(2, 2, 3)&gt;&gt;&gt; c[1,...] # same as c[1,:,:] or c[1]array([[100, 101, 102], [110, 112, 113]])&gt;&gt;&gt; c[...,2] # same as c[:,:,2]array([[ 2, 13], [102, 113]]) 迭代多维数组是对第一 axis 进行的。 12345678&gt;&gt;&gt; for row in b:... print(row)...[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43] 然而，如果你想模拟对数组中每一个元素的操作，你可以使用 flat 属性，它是一个 iterator，能够遍历数组中每一个元素。 1234567891011121314151617181920212223&gt;&gt;&gt; for element in b.flat:... print(element)...012310111213202122233031323340414243 参考Indexing, Indexing (reference), newaxis, ndenumerate, indices 3 操控形状3.1 改变数组的形状每一个数组的形状通过每一个 axis 中的元素数量。（其实就是每一个维度的元素多少确定） 1234567&gt;&gt;&gt; a = np.floor(10*np.random.random((3,4)))&gt;&gt;&gt; aarray([[ 2., 8., 0., 6.], [ 4., 5., 1., 1.], [ 8., 9., 3., 6.]])&gt;&gt;&gt; a.shape(3, 4) 数组的形状可以通过很多命令来改变，提到这里，接下来的三个例子放回一个被修改的数组，原数组不会改变。 123456789101112131415161718&gt;&gt;&gt; a.ravel() # returns the array, flattenedarray([ 2., 8., 0., 6., 4., 5., 1., 1., 8., 9., 3., 6.])&gt;&gt;&gt; a.reshape(6,2) # returns the array with a modified shapearray([[ 2., 8.], [ 0., 6.], [ 4., 5.], [ 1., 1.], [ 8., 9.], [ 3., 6.]])&gt;&gt;&gt; a.T # returns the array, transposedarray([[ 2., 4., 8.], [ 8., 5., 9.], [ 0., 1., 3.], [ 6., 1., 6.]])&gt;&gt;&gt; a.T.shape(4, 3)&gt;&gt;&gt; a.shape(3, 4) ravel() 函数中每个元素的位置通常是一种 “C-style” 的，也就是说，最右边的索引改变起来最快。所以元素 a[0, 0] 后面的元素是 a[0, 1]。如果这个数组被塑造成其它形状，这个数组也是作为 “C-style” 对待。\\( NumPy \\) 通常也是按照这个创建的数组，所以使用 ravel() 函数时不需要复制，但是如果这个数组是通过从另一个数组切片或者其它不同寻常的方式而来的话，它就需要进行复制了。函数 ravel() 和 reshape() 也可以通过可选参数被指定去用 FORTRAN-style 的数组，这这种风格中，最左的索引改变最快。 reshape 函数返回修改的形状，而 ndarray.resize 方法直接修改数组本身。 12345678&gt;&gt;&gt; aarray([[ 2., 8., 0., 6.], [ 4., 5., 1., 1.], [ 8., 9., 3., 6.]])&gt;&gt;&gt; a.resize((2,6))&gt;&gt;&gt; aarray([[ 2., 8., 0., 6., 4., 5.], [ 1., 1., 8., 9., 3., 6.]]) 如果一个维度给一个 \\( -1 \\) 作为参数，那么其他它维度将自动计算。 1234&gt;&gt;&gt; a.reshape(3,-1)array([[ 2., 8., 0., 6.], [ 4., 5., 1., 1.], [ 8., 9., 3., 6.]]) 参考ndarray.shape, reshape, resize, ravel 3.2 不同数组的组合数组可以通过不同的 axes 组合起来。 12345678910111213141516&gt;&gt;&gt; a = np.floor(10*np.random.random((2,2)))&gt;&gt;&gt; aarray([[ 8., 8.], [ 0., 0.]])&gt;&gt;&gt; b = np.floor(10*np.random.random((2,2)))&gt;&gt;&gt; barray([[ 1., 8.], [ 0., 4.]])&gt;&gt;&gt; np.vstack((a,b))array([[ 8., 8.], [ 0., 0.], [ 1., 8.], [ 0., 4.]])&gt;&gt;&gt; np.hstack((a,b))array([[ 8., 8., 1., 8.], [ 0., 0., 0., 4.]]) column_stack 函数可以将 \\( 1D \\) 数组作为 \\( 2D \\) 数组的列。当且仅当数组是 \\( 1D \\) 的时候它等于 vstack 1234567891011121314151617&gt;&gt;&gt; from numpy import newaxis&gt;&gt;&gt; np.column_stack((a,b)) # With 2D arraysarray([[ 8., 8., 1., 8.], [ 0., 0., 0., 4.]])&gt;&gt;&gt; a = np.array([4.,2.])&gt;&gt;&gt; b = np.array([2.,8.])&gt;&gt;&gt; a[:,newaxis] # This allows to have a 2D columns vectorarray([[ 4.], [ 2.]])&gt;&gt;&gt; np.column_stack((a[:,newaxis],b[:,newaxis]))array([[ 4., 2.], [ 2., 8.]])&gt;&gt;&gt; np.vstack((a[:,newaxis],b[:,newaxis])) # The behavior of vstack is differentarray([[ 4.], [ 2.], [ 2.], [ 8.]]) 对于超过两个维度的数组，hstack 会沿着第二个 axis 堆积，vstack 沿着第一个 axes 堆积，concatenate 允许一个可选参数选择哪一个 axis 发生连接操作。 提示在复杂情况下，r_ 和 c_ 对于通过沿一个 axis 堆积数字来创建数组很有用。它们允许使用范围表示符号（“:”） 12&gt;&gt;&gt; np.r_[1:4,0,4]array([1, 2, 3, 0, 4]) 当使用数组作为参数时，r_ 与 c_ 在默认行为是和 vstack 与 hstack 相似的，但是它们允许可选参数给出 axis 来连接。 参考hstack，vstack，column_stack，concatenate，c_，r_ 3.3 将数组分割成几个小数组使用 hsplit，你能沿着它的水平 axis 分割，可以通过指定数组形状来返回，也可以指定哪个列应该拆分： 1234567891011121314&gt;&gt;&gt; a = np.floor(10*np.random.random((2,12)))&gt;&gt;&gt; aarray([[ 9., 5., 6., 3., 6., 8., 0., 7., 9., 7., 2., 7.], [ 1., 4., 9., 2., 2., 1., 0., 6., 2., 2., 4., 0.]])&gt;&gt;&gt; np.hsplit(a,3) # Split a into 3[array([[ 9., 5., 6., 3.], [ 1., 4., 9., 2.]]), array([[ 6., 8., 0., 7.], [ 2., 1., 0., 6.]]), array([[ 9., 7., 2., 7.], [ 2., 2., 4., 0.]])]&gt;&gt;&gt; np.hsplit(a,(3,4)) # Split a after the third and the fourth column[array([[ 9., 5., 6.], [ 1., 4., 9.]]), array([[ 3.], [ 2.]]), array([[ 6., 8., 0., 7., 9., 7., 2., 7.], [ 2., 1., 0., 6., 2., 2., 4., 0.]])] vplit 沿着竖直的 axis 分割，array_split 允许通过指定哪个 axis 去分割。 4 拷贝和 Views在操作数组的时候，它们的数据有时候拷贝进一个新的数组，有时候又不是。这经常是初学者感到困惑。下面有三种情况： 4.1 不拷贝简单的赋值不会拷贝任何数组对象和它们的数据。 1234567&gt;&gt;&gt; a = np.arange(12)&gt;&gt;&gt; b = a # no new object is created&gt;&gt;&gt; b is a # a and b are two names for the same ndarray objectTrue&gt;&gt;&gt; b.shape = 3,4 # changes the shape of a&gt;&gt;&gt; a.shape(3, 4) \\( Python \\) 将可变对象作为引用传递，所以函数调用不会产生拷贝。 1234567&gt;&gt;&gt; def f(x):... print(id(x))...&gt;&gt;&gt; id(a) # id is a unique identifier of an object148293216&gt;&gt;&gt; f(a)148293216 4.2 View 或者浅拷贝不同的数组对象可以分享相同的数据。view 方法创建了一个相同数据的新数组对象。PS：这里 View（视图？） 不知道如何理解好，所以保留。 12345678910111213141516&gt;&gt;&gt; c = a.view()&gt;&gt;&gt; c is aFalse&gt;&gt;&gt; c.base is a # c is a view of the data owned by aTrue&gt;&gt;&gt; c.flags.owndataFalse&gt;&gt;&gt;&gt;&gt;&gt; c.shape = 2,6 # a&apos;s shape doesn&apos;t change&gt;&gt;&gt; a.shape(3, 4)&gt;&gt;&gt; c[0,4] = 1234 # a&apos;s data changes&gt;&gt;&gt; aarray([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]]) 切片数组返回一个 view： 123456&gt;&gt;&gt; s = a[ : , 1:3] # spaces added for clarity; could also be written &quot;s = a[:,1:3]&quot;&gt;&gt;&gt; s[:] = 10 # s[:] is a view of s. Note the difference between s=10 and s[:]=10&gt;&gt;&gt; aarray([[ 0, 10, 10, 3], [1234, 10, 10, 7], [ 8, 10, 10, 11]]) 4.3 深拷贝copy 方法完全拷贝数组。 12345678910&gt;&gt;&gt; d = a.copy() # a new array object with new data is created&gt;&gt;&gt; d is aFalse&gt;&gt;&gt; d.base is a # d doesn&apos;t share anything with aFalse&gt;&gt;&gt; d[0,0] = 9999&gt;&gt;&gt; aarray([[ 0, 10, 10, 3], [1234, 10, 10, 7], [ 8, 10, 10, 11]]) 4.4 函数和方法综述这里通过类别排序列举一些有用的 \\( NumPy \\) 函数和方法。拆看完整列表点击Routines 数组收集 arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r, zeros, zeros_like 转化 ndarray.astype, atleast_1d, atleast_2d, atleast_3d, mat 操作 array_split, column_stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, ndarray.item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack 疑问 all, any, nonzero, where 排序 argmax, argmin, argsort, max, min, ptp, searchsorted, sort 运算 choose, compress, cumprod, cumsum, inner, ndarray.fill, imag, prod, put, putmask, real, sum 基本统计 cov, mean, std, var 基本线性代数 cross, dot, outer, linalg.svd, vdot 5 Less Basic5.1 广播规则广播允许通用功能用一种有意义的方式去处理不完全相同的形状输入。第一条广播规则是如果所有输入的数组都没有相同的维度数字，那么将会重复地用 \\( 1 \\) 去加在较小的数组形状上直到所有的数组有相同的维度数字。第二条广播规则是确保沿着特定维度大小为 \\( 1 \\) 的数组就像沿着这个维度最大维数大小一样的，假设数组元素的值在广播数组的维度是相同的。应用广播规则后，所有数组大小不必须匹配。更多细节可以在Broadcasting。 Numpy中的广播(Broadcasting) 6 花式索引和索引技巧\\( NumPy \\) 提供了比 \\( Python \\) 序列更多的索引功能。除了我们之前看到的通过整数和切片索引之外，数组可以通过整数数组和布尔数组索引。 6.1 用索引数组索引123456789&gt;&gt;&gt; a = np.arange(12)**2 # the first 12 square numbers&gt;&gt;&gt; i = np.array( [ 1,1,3,8,5 ] ) # an array of indices&gt;&gt;&gt; a[i] # the elements of a at the positions iarray([ 1, 1, 9, 64, 25])&gt;&gt;&gt;&gt;&gt;&gt; j = np.array( [ [ 3, 4], [ 9, 7 ] ] ) # a bidimensional array of indices&gt;&gt;&gt; a[j] # the same shape as jarray([[ 9, 16], [81, 49]]) 当数组 a 是多维的，单个数组指向数组 a 的第一维。以下示例通过使用调色板将标签图像转换为彩色图像来显示此行为。 12345678910111213141516&gt;&gt;&gt; palette = np.array( [ [0,0,0], # black... [255,0,0], # red... [0,255,0], # green... [0,0,255], # blue... [255,255,255] ] ) # white&gt;&gt;&gt; image = np.array( [ [ 0, 1, 2, 0 ], # each value corresponds to a color in the palette... [ 0, 3, 4, 0 ] ] )&gt;&gt;&gt; palette[image] # the (2,4,3) color imagearray([[[ 0, 0, 0], [255, 0, 0], [ 0, 255, 0], [ 0, 0, 0]], [[ 0, 0, 0], [ 0, 0, 255], [255, 255, 255], [ 0, 0, 0]]]) 我们可以给超过一维的索引。数组每个维度的索引形状必须一样。 12345678910111213141516171819202122232425&gt;&gt;&gt; a = np.arange(12).reshape(3,4)&gt;&gt;&gt; aarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])&gt;&gt;&gt; i = np.array( [ [0,1], # indices for the first dim of a... [1,2] ] )&gt;&gt;&gt; j = np.array( [ [2,1], # indices for the second dim... [3,3] ] )&gt;&gt;&gt;&gt;&gt;&gt; a[i,j] # i and j must have equal shapearray([[ 2, 5], [ 7, 11]])&gt;&gt;&gt;&gt;&gt;&gt; a[i,2]array([[ 2, 6], [ 6, 10]])&gt;&gt;&gt;&gt;&gt;&gt; a[:,j] # i.e., a[ : , j]array([[[ 2, 1], [ 3, 3]], [[ 6, 5], [ 7, 7]], [[10, 9], [11, 11]]]) 当然，我们可以把 i, j 放进一个序列然后对这个列表进行索引。 1234&gt;&gt;&gt; l = [i,j]&gt;&gt;&gt; a[l] # equivalent to a[i,j]array([[ 2, 5], [ 7, 11]]) 然而，我们可以直接把 i，j 放进数组中，因为这个数组将会被解释成 a 第一维的索引。 123456789&gt;&gt;&gt; s = np.array( [i,j] )&gt;&gt;&gt; a[s] # not what we wantTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?IndexError: index (3) out of range (0&lt;=index&lt;=2) in dimension 0&gt;&gt;&gt;&gt;&gt;&gt; a[tuple(s)] # same as a[i,j]array([[ 2, 5], [ 7, 11]]) 另一个常用数组索引是查询时间相关系列的最大值。 1234567891011121314151617181920212223242526&gt;&gt;&gt; time = np.linspace(20, 145, 5) # time scale&gt;&gt;&gt; data = np.sin(np.arange(20)).reshape(5,4) # 4 time-dependent series&gt;&gt;&gt; timearray([ 20. , 51.25, 82.5 , 113.75, 145. ])&gt;&gt;&gt; dataarray([[ 0. , 0.84147098, 0.90929743, 0.14112001], [-0.7568025 , -0.95892427, -0.2794155 , 0.6569866 ], [ 0.98935825, 0.41211849, -0.54402111, -0.99999021], [-0.53657292, 0.42016704, 0.99060736, 0.65028784], [-0.28790332, -0.96139749, -0.75098725, 0.14987721]])&gt;&gt;&gt;&gt;&gt;&gt; ind = data.argmax(axis=0) # index of the maxima for each series&gt;&gt;&gt; indarray([2, 0, 3, 1])&gt;&gt;&gt;&gt;&gt;&gt; time_max = time[ ind] # times corresponding to the maxima&gt;&gt;&gt;&gt;&gt;&gt; data_max = data[ind, xrange(data.shape[1])] # =&gt; data[ind[0],0], data[ind[1],1]...&gt;&gt;&gt;&gt;&gt;&gt; time_maxarray([ 82.5 , 20. , 113.75, 51.25])&gt;&gt;&gt; data_maxarray([ 0.98935825, 0.84147098, 0.99060736, 0.6569866 ])&gt;&gt;&gt;&gt;&gt;&gt; np.all(data_max == data.max(axis=0))True 你也可以使用数组索引对数组进行赋值： 123456&gt;&gt;&gt; a = np.arange(5)&gt;&gt;&gt; aarray([0, 1, 2, 3, 4])&gt;&gt;&gt; a[[1,3,4]] = 0&gt;&gt;&gt; aarray([0, 0, 2, 0, 0]) 然而，当你的列表索引包含重复，这个赋值会发生几次，保留最后一个数值。 1234&gt;&gt;&gt; a = np.arange(5)&gt;&gt;&gt; a[[0,0,2]]=[1,2,3]&gt;&gt;&gt; aarray([2, 1, 3, 3, 4]) 这足够合理，但是如果你想使用 \\( Python \\) 的 += 结构时要小心，它可能不像你期待的一样： 1234&gt;&gt;&gt; a = np.arange(5)&gt;&gt;&gt; a[[0,0,2]]+=1&gt;&gt;&gt; aarray([1, 1, 3, 3, 4]) 即使 \\( 0 \\) 在列表中出现了两次，这第 \\( 0 \\) 个元素也只增加一次。这是因为 \\( Python \\) 把 “a+=1” 等价于 “a=a+1”。 6.2 用布尔数组索引当我们用整数数组去索引数组时，我们提供了索引列表去挑选。用布尔索引的方法是不用的；我们明确的在数组中选择哪个我们想要哪个我们不想要。最自然能想到的方法是用和原数组一样形状的布尔数组进行布尔索引。 12345678&gt;&gt;&gt; a = np.arange(12).reshape(3,4)&gt;&gt;&gt; b = a &gt; 4&gt;&gt;&gt; b # b is a boolean with a&apos;s shapearray([[False, False, False, False], [False, True, True, True], [ True, True, True, True]], dtype=bool)&gt;&gt;&gt; a[b] # 1d array with the selected elementsarray([ 5, 6, 7, 8, 9, 10, 11]) 这个属性在复制时非常有用。 12345&gt;&gt;&gt; a[b] = 0 # All elements of &apos;a&apos; higher than 4 become 0&gt;&gt;&gt; aarray([[0, 1, 2, 3], [4, 0, 0, 0], [0, 0, 0, 0]]) 你可以看接下来的例子去了解如何使用布尔索引去生成 Mandelbrot set 图像。 12345678910111213141516171819&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import matplotlib.pyplot as plt&gt;&gt;&gt; def mandelbrot( h,w, maxit=20 ):... &quot;&quot;&quot;Returns an image of the Mandelbrot fractal of size (h,w).&quot;&quot;&quot;... y,x = np.ogrid[ -1.4:1.4:h*1j, -2:0.8:w*1j ]... c = x+y*1j... z = c... divtime = maxit + np.zeros(z.shape, dtype=int)...... for i in range(maxit):... z = z**2 + c... diverge = z*np.conj(z) &gt; 2**2 # who is diverging... div_now = diverge &amp; (divtime==maxit) # who is diverging now... divtime[div_now] = i # note when... z[diverge] = 2 # avoid diverging too much...... return divtime&gt;&gt;&gt; plt.imshow(mandelbrot(400,400))&gt;&gt;&gt; plt.show() 123456789101112131415161718import numpy as npimport matplotlib.pyplot as pltdef mandelbrot(h, w, maxit=20): y, x = np.ogrid[-1.4:1.4:h * 1j, -2:0.8:w * 1j] c = x + y * 1j z = c divtime = maxit + np.zeros(z.shape, dtype=int) for i in range(maxit): z = z ** 2 + c diverge = z * np.conj(z) &gt; 2 ** 2 # who is diverging div_now = diverge &amp; (divtime == maxit) # who is diverging now divtime[div_now] = i # note when z[diverge] = 2 # avoid diverging too much return divtimeplt.imshow(mandelbrot(400, 400))plt.show() 第二种用布尔索引方法更像是整数索引，对于每个数组的维度，我们给一个 \\( 1D \\) 的布尔数组去选择我们想要的切片。 12345678910111213141516171819&gt;&gt;&gt; a = np.arange(12).reshape(3,4)&gt;&gt;&gt; b1 = np.array([False,True,True]) # first dim selection&gt;&gt;&gt; b2 = np.array([True,False,True,False]) # second dim selection&gt;&gt;&gt;&gt;&gt;&gt; a[b1,:] # selecting rowsarray([[ 4, 5, 6, 7], [ 8, 9, 10, 11]])&gt;&gt;&gt;&gt;&gt;&gt; a[b1] # same thingarray([[ 4, 5, 6, 7], [ 8, 9, 10, 11]])&gt;&gt;&gt;&gt;&gt;&gt; a[:,b2] # selecting columnsarray([[ 0, 2], [ 4, 6], [ 8, 10]])&gt;&gt;&gt;&gt;&gt;&gt; a[b1,b2] # a weird thing to doarray([ 4, 10]) 请注意，\\( 1D \\) 布尔数组的长度必须与你要切片的维度（或axis）的长度一致。在之前的例子中，b1 是一个长度为 \\( 3 \\)（a 的行数） 的 1-rank 数组，b2 （长度为 \\( 4 \\)）是一个适合去索引 a 的第二 rank (列)。 6.3 ix_() 函数ix_ 可以组合不同向量去获得对于每一个 n-uplet 的结果。例如，如果你想从每个 \\( a, b, c \\) 向量中取得三元组去计算所有的 \\( a+b*c \\) ： 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; a = np.array([2,3,4,5])&gt;&gt;&gt; b = np.array([8,5,4])&gt;&gt;&gt; c = np.array([5,4,6,8,3])&gt;&gt;&gt; ax,bx,cx = np.ix_(a,b,c)&gt;&gt;&gt; axarray([[[2]], [[3]], [[4]], [[5]]])&gt;&gt;&gt; bxarray([[[8], [5], [4]]])&gt;&gt;&gt; cxarray([[[5, 4, 6, 8, 3]]])&gt;&gt;&gt; ax.shape, bx.shape, cx.shape((4, 1, 1), (1, 3, 1), (1, 1, 5))&gt;&gt;&gt; result = ax+bx*cx&gt;&gt;&gt; resultarray([[[42, 34, 50, 66, 26], [27, 22, 32, 42, 17], [22, 18, 26, 34, 14]], [[43, 35, 51, 67, 27], [28, 23, 33, 43, 18], [23, 19, 27, 35, 15]], [[44, 36, 52, 68, 28], [29, 24, 34, 44, 19], [24, 20, 28, 36, 16]], [[45, 37, 53, 69, 29], [30, 25, 35, 45, 20], [25, 21, 29, 37, 17]]])&gt;&gt;&gt; result[3,2,4]17&gt;&gt;&gt; a[3]+b[2]*c[4]17 你也可以按以下方式实现： 123456&gt;&gt;&gt; def ufunc_reduce(ufct, *vectors):... vs = np.ix_(*vectors)... r = ufct.identity... for v in vs:... r = ufct(r,v)... return r 然后这样使用： 12345678910111213&gt;&gt;&gt; ufunc_reduce(np.add,a,b,c)array([[[15, 14, 16, 18, 13], [12, 11, 13, 15, 10], [11, 10, 12, 14, 9]], [[16, 15, 17, 19, 14], [13, 12, 14, 16, 11], [12, 11, 13, 15, 10]], [[17, 16, 18, 20, 15], [14, 13, 15, 17, 12], [13, 12, 14, 16, 11]], [[18, 17, 19, 21, 16], [15, 14, 16, 18, 13], [14, 13, 15, 17, 12]]]) 这个版本的比通常的 ufunc.reduce 好在它使用了Broadcasting Rules 规则去避免创建一个大小是输出乘以矢量数量数组。 6.4 使用字符串索引参考Structured arrays 7 线性代数工作进行中，基本的线性代数包含在其中。 7.1 简单的数组操作看\\( NumPy \\) 文件夹下的 \\( linalg.py \\) 文件了解更多。 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1.0, 2.0], [3.0, 4.0]])&gt;&gt;&gt; print(a)[[ 1. 2.] [ 3. 4.]]&gt;&gt;&gt; a.transpose()array([[ 1., 3.], [ 2., 4.]])&gt;&gt;&gt; np.linalg.inv(a)array([[-2. , 1. ], [ 1.5, -0.5]])&gt;&gt;&gt; u = np.eye(2) # unit 2x2 matrix; &quot;eye&quot; represents &quot;I&quot;&gt;&gt;&gt; uarray([[ 1., 0.], [ 0., 1.]])&gt;&gt;&gt; j = np.array([[0.0, -1.0], [1.0, 0.0]])&gt;&gt;&gt; np.dot (j, j) # matrix productarray([[-1., 0.], [ 0., -1.]])&gt;&gt;&gt; np.trace(u) # trace2.0&gt;&gt;&gt; y = np.array([[5.], [7.]])&gt;&gt;&gt; np.linalg.solve(a, y)array([[-3.], [ 4.]])&gt;&gt;&gt; np.linalg.eig(j)(array([ 0.+1.j, 0.-1.j]), array([[ 0.70710678+0.j , 0.70710678-0.j ], [ 0.00000000-0.70710678j, 0.00000000+0.70710678j]])) 1234567Parameters: square matrixReturns The eigenvalues, each repeated according to its multiplicity. The normalized (unit &quot;length&quot;) eigenvectors, such that the column ``v[:,i]`` is the eigenvector corresponding to the eigenvalue ``w[i]`` . 8 技巧和提示这里我们给出一些有用的小技巧。 8.1 “自动塑形”为了改变数组的维度，你可以省略一个可以自动被推算出来的大小的参数。 123456789101112131415&gt;&gt;&gt; a = np.arange(30)&gt;&gt;&gt; a.shape = 2,-1,3 # -1 means &quot;whatever is needed&quot;&gt;&gt;&gt; a.shape(2, 5, 3)&gt;&gt;&gt; aarray([[[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11], [12, 13, 14]], [[15, 16, 17], [18, 19, 20], [21, 22, 23], [24, 25, 26], [27, 28, 29]]]) 8.2 矢量叠加我们怎么从一个相同大小的行向量构造出一个 \\( 2D \\) 数组？在 \\( MATLAB \\)中是相当简单的：如果 x 和 y 是两个相同长度的向量，你只需要把 m=[x;y]。在 \\( NumPy \\) 中，通过函数 column_stack，dstack，hstack 和 vstack 实现，这取决于所要叠加的维度。例如： 12345x = np.arange(0,10,2) # x=([0,2,4,6,8])y = np.arange(5) # y=([0,1,2,3,4])m = np.vstack([x,y]) # m=([[0,2,4,6,8], # [0,1,2,3,4]])xy = np.hstack([x,y]) # xy =([0,2,4,6,8,0,1,2,3,4]) 在超过两个维度时这些函数背后的逻辑是奇怪的。 参考NumPy for Matlab users 8.3 柱状图\\( NumPy \\) 的 histogram 函数应用于数组，返回一对矢量：数组的柱状图和 bins 矢量。当心：matplotlib 也有一个函数去构建柱状图（叫做 hist，同样在 \\( Matlab \\) 中），这个和 \\( NumPy \\) 还是不一样的。主要的区别是 pylab.hist 自动绘制柱状图而 matplotlib 只是生成数据。 12345678&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import matplotlib.pyplot as plt&gt;&gt;&gt; # Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2&gt;&gt;&gt; mu, sigma = 2, 0.5&gt;&gt;&gt; v = np.random.normal(mu,sigma,10000)&gt;&gt;&gt; # Plot a normalized histogram with 50 bins&gt;&gt;&gt; plt.hist(v, bins=50, normed=1) # matplotlib version (plot)&gt;&gt;&gt; plt.show() 123456789import numpy as npimport matplotlib.pyplot as plt# Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2mu, sigma = 2, 0.5v = np.random.normal(mu, sigma, 10000)# Plot a normalized histogram with 50 binsplt.hist(v, bins=50, normed=1) # matplotlib version (plot)plt.show() 1234&gt;&gt;&gt; # Compute the histogram with numpy and then plot it&gt;&gt;&gt; (n, bins) = np.histogram(v, bins=50, normed=True) # NumPy version (no plot)&gt;&gt;&gt; plt.plot(.5*(bins[1:]+bins[:-1]), n)&gt;&gt;&gt; plt.show() 12345678910import numpy as npimport matplotlib.pyplot as plt# Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2mu, sigma = 2, 0.5v = np.random.normal(mu, sigma, 10000)# Compute the histogram with numpy and then plot it(n, bins) = np.histogram(v, bins=50, normed=True) # NumPy version (no plot)plt.plot(.5 * (bins[1:] + bins[:-1]), n)plt.show() 9 更多阅读 The Python tutorial NumPy Reference SciPy Tutorial SciPy Lecture Notes A matlab, R, IDL, NumPy/SciPy dictionary","tags":[{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://fitzeng.org/tags/MachineLearning/"},{"name":"Python","slug":"Python","permalink":"http://fitzeng.org/tags/Python/"},{"name":"NumPy","slug":"NumPy","permalink":"http://fitzeng.org/tags/NumPy/"}]},{"title":"从 TensorFlow 入门机器学习","date":"2018-02-03T03:27:00.000Z","path":"2018/02/03/TensorFlowIntroduction/","text":"写在前面：紧跟时代步伐，开始学习机器学习，抱着争取在毕业之前多看看各个方向是什么样子的心态，发现这是一个很有潜力也很有趣的领域（keng）。// 然后就开始补数学了…… 0 TensorFlow 介绍刚刚入门的小白，理解不深，直接看官方的介绍吧 GitHub Description: Computation using data flow graphs for scalable machine learning 官网: \\( TensorFlow^{^{TM}} \\)是一个使用数据流图进行数值计算的开源软件库。图中的节点代表数学运算， 而图中的边则代表在这些节点之间传递的多维数组（张量）。 0.1 什么是 TensorFlow ?\\( Tensor \\) 是张量的意思，\\( Flow \\) 是流的意思。所以可以直接看做利用张量组成的数据流图进行计算的一个开源库。 0.2 TensorFlow 可以做什么 ?目前主要是用于机器学习，这样说有点不亲民，笔者理解是可以将数据转化为向量描述并且构建相应的计算流图都是可以使用的。举个例子吧，虽然不知道恰不恰当。比如我们在计算 \\( (1 + 2)*3-4 \\) 时，可以构建一个二叉树 这棵二叉树的中序遍历就是上面的表达式，也就是说这个表达式可以转化成一个形如二叉树的图，而 \\( TensorFlow \\) 正好可以计算这个图。下面给出代码，看不懂没关系，只要理解代码流程是对图(二叉树)的计算就可以了，下一章会介绍如何使用\\( TensorFlow \\)。 1234567891011# coding: utf-8import tensorflow as tfa, b, c, d = tf.constant(1), tf.constant(2), tf.constant(3),tf.constant(4)add = tf.add(a,b)mul = tf.multiply(add, c)sub = tf.subtract(mul, d)with tf.Session() as sess: print(sess.run(sub))# output: # 5 0.3 TensorFlow 安装这里就不做详细介绍了，相信点开这篇文章的你应该有了运行环境。如果没有这里推荐两个网站英文:官网 和 中文:**学院翻译然后介绍一下我的环境：\\( Anaconda + PyCharm \\) 注意 \\( PyCharm:\\ Project\\ Interpreter \\) 设置为 \\( Conda\\ Environment \\) 才能跑 \\( TensorFlow \\)。如果不会可以多看看网上的教程，能对虚拟环境加深了解。 1 初识 TensorFlow好了，有前面的介绍，你应该有能够使用 \\( TensorFlow \\) 的环境了，下面开始介绍如何编码。 1.1 基础语法 其实说语法是不准确的，语法就是 \\( Python \\) 的语法(这里使用 Python)，主要是介绍调用这个计算库来实现这个特殊的计算。同样摆上官网教程 1.1.1 计算单元介绍可以看到在计算图中，有两个主要的内容是点(叶子和非叶子节点)和线。我的理解是点代表数据，线代表操作。不知道对不对，不过下面就按照这样思路介绍了。下面开始介绍有哪些常用的“点”： 常量 1c = tf.constant(2) 变量 1v = tf.Variable(2) 占位符 1p = tf.placeholder(tf.float32) 以上代码都是以最小能用原则传的参，感兴趣的可以去看看源码，这里主要是往 \\( Python \\) 语法上拉，先使用起来再以后自己深究为什么要设计成这样的数据结构对计算图是必须的。 接下来就是有哪些“线”： 四则运算 1234add = tf.add(a, b)sub = tf.subtract(a, b)mul = tf.multiply(a, b)div = tf.divide(a, b) 其他的就不再介绍了，详情可看 \\( XXX\\ ops.py \\) 的源码。比如以上的操作定义在 \\( math\\ ops.py \\)。 1.1.2 计算流程介绍知道了常见数据和计算方法下面介绍计算流程： 1234567891011121314# coding: utf-8import tensorflow as tf# Step1: 创建数据a, b, c, d = tf.constant(1), tf.constant(2), tf.constant(3),tf.constant(4)# Step2: 构造计算图add = tf.add(a,b)mul = tf.multiply(add, c)sub = tf.subtract(mul, d)# Step3: 进行计算with tf.Session() as sess: print(sess.run(sub)) 上面这个例子是一个标准的常量计算过程，你可以试着 print(a, add) 看看你创建的是个什么东西，你会发现他是一个 \\( Tensor \\) 而且里面的值是 \\( 0 \\)。可以猜测，这里只打印不计算，看 \\( Tensor \\) 源码： 12345678910# ops.pydef __repr__(self): return \"&lt;tf.Tensor '%s' shape=%s dtype=%s&gt;\" % (self.name, self.get_shape(),self._dtype.name)@propertydef name(self): \"\"\"The string name of this tensor.\"\"\" if not self._op.name: raise ValueError(\"Operation was not named: %s\" % self._op) return \"%s:%d\" % (self._op.name, self._value_index) 学会了计算常量，变量是不是也一样？如果你试过就知道是不一样的，变量需要初始化操作。 1234v = tf.Variable(2)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print(v, sess.run(v)) 到这里可能会疑问，那变量和常量有什么区别？从字面意思可以知道变量应该是可变的，方便我们在计算过程中随时调整参数，下面通过一段代码介绍如何使用。 123456789101112131415161718192021222324v = tf.Variable(2)# 将 v 的值自乘 2update = tf.assign(v, tf.multiply(v, tf.constant(2)))with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for _ in range(4): print(\"-----------------------\") print \"Before : \", sess.run(v) sess.run(update) print \"After : \", sess.run(v)# output:# -----------------------# Before : 2# After : 4# -----------------------# Before : 4# After : 8# -----------------------# Before : 8# After : 16# -----------------------# Before : 16# After : 32 但是如果我们不想每次都设置-更新-计算-更新-计算……而是直接把数据写入计算，那占位符就起作用了。同样举个小例子。 1234567891011121314151617c = tf.constant(2)# 注意类型一致，这里是 tf.int32p = tf.placeholder(tf.int32)mul = tf.multiply(c, p)with tf.Session() as sess: # tmp = 2 相当于上一个例子变量的初始值是 2 tmp = 2; for _ in range(4): # 直接填充 feed_dict tmp = sess.run(mul, feed_dict=&#123;p:tmp&#125;) print tmp# output:# 4# 8# 16# 32 下面总结下计算过程： 创建数据：可以创建常量、变量和占位符。 构建图：通过前面的数据构建一张图。 初始化：把变量初始化。 计算：必须通过开启一个 Session 来计算图 1.2 可视化\\( TensorFlow \\)提供了一个可视化工具——\\( TensorBoard \\)，下面开始介绍如何使用。 这里对上面二叉树的例子进行可视化处理。 1234567891011# coding: utf-8import tensorflow as tfa, b, c, d = tf.constant(1), tf.constant(2), tf.constant(3),tf.constant(4)add = tf.add(a,b)mul = tf.multiply(add, c)sub = tf.subtract(mul, d)with tf.Session() as sess: writer = tf.summary.FileWriter('./graphs', sess.graph) print(sess.run(sub))writer.close() 然后使用命令行到存储 graphs 的文件夹下执行 tensorboard --logdir=&quot;./graphs&quot; 命令，然后按照提示在浏览器中打开 http://localhost:6006 如果成功显示 \\( TensorBoard \\) 界面就说明成功了。 2 利用 TensorFlow 进行机器学习这里也算是机器学习的入门介绍吧。直接介绍机器学习相关知识可能不太现实，而且笔者也是在学习阶段，所以举一些小例子来体会机器学习的过程吧。 2.1 线性回归这里我们使用最熟悉的线性回归来体会一下机器学习的过程： 2.1.1 准备数据这里很简单，就是模拟一个线性回归，所以我们直接自己拟定一些数据好预测结果和自己设想的是否一致。 12train_X = numpy.asarray([1.1, 1.8, 3.2, 4.7, 5.9, 6.7])train_Y = numpy.asarray([1.2, 2.1, 3.1, 4.6, 5.5, 6.9]) 2.1.2 构建模型我们采用占位符的形式进行计算，在运算时直接导入数据便可。这里因为我们采用线性回归，所以目标函数是形如 \\( Y = XW + b \\) 的形式的一次函数。也就是说，我们通过给出的点去拟合一条比较符合这些点分布的直线。 123456789X = tf.placeholder(tf.float32)Y = tf.placeholder(tf.float32)W = tf.Variable(-1., name=\"weight\")b = tf.Variable(-1., name=\"bias\")# linear model # activation = X*W + bactivation = tf.add(tf.multiply(X, W), b) 2.1.3 参数评估我们采用每个点给出的纵坐标和线性模型算出的纵坐标的差\\( (activation - Y) \\)的平方和\\( (tf.reduce\\_ sum(tf.pow(activation - Y, 2))) \\)作为损失函数，在训练中采用梯度下降算法尽量使和最小，学利率选择 \\( 0.01 \\)。其中的数学原理这里就不介绍了，以后会写关于机器学习算法的相关文章。一般选取损失函数和通过某些最优化手段更新权重是这里的一大难点，如果要知道原理，需要学习大量数学基础知识（概率论，线性代数，微积分……）。 1234learning_rate = 0.01cost = tf.reduce_sum(tf.pow(activation - Y, 2))optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost) 2.1.4 训练数据这里就是取数据，喂给图中的输入节点，然后模型会自己进行优化，可以将数据多次迭代使得拟合函数能够更好的适应这些数据点。 1234567891011121314151617181920212223242526training_epochs = 2000display_step = 100with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for epoch in range(training_epochs): for (x, y) in zip(train_X, train_Y): sess.run(optimizer, feed_dict=&#123;X: x, Y: y&#125;) if epoch % display_step == 0: print(\"Epoch:\", '%04d' % (epoch + 1), \"cost=\", \"&#123;:.9f&#125;\".format(sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;)), \"W=\", sess.run(W), \"b=\", sess.run(b)) print(\"Optimization Finished!\") print(\"cost=\", sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;), \"W=\", sess.run(W), \"b=\", sess.run(b))``` #### 2.1.5 可视化可以直接绘制二维图形看结果。不熟悉的可以参考[Matplotlib 教程](https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/)```python writer = tf.summary.FileWriter('./graphs', sess.graph) plt.scatter(train_X, train_Y, color='red', label='Original data') plt.plot(train_X, sess.run(W) * train_X + sess.run(b), color='blue', label='Fitted line') plt.show()writer.close() 二维图：数据流图： 2.1.6 小结其实整个过程如果不深究其中的原理，还是很好理解的，无非就是提供数据-选取拟合函数-构建图-选取损失函数-最优化-训练数据（更新权重）-得出结论。这个过程符合我们对线性回归这个问题解决的基本思路的预期。当然，笔者认为这只是开始，要想深入，学习必要的数学知识是机器学习的必经之路。 这里可以参考TensorFlow 入门整体代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# coding: utf-8from __future__ import print_functionimport tensorflow as tfimport numpyimport matplotlib.pyplot as plttrain_X = numpy.asarray([1.1, 1.8, 3.2, 4.7, 5.9, 6.7])train_Y = numpy.asarray([1.2, 2.1, 3.1, 4.6, 5.5, 6.9])X = tf.placeholder(tf.float32)Y = tf.placeholder(tf.float32)W = tf.Variable(-1., name=\"weight\")b = tf.Variable(-1., name=\"bias\")activation = tf.add(tf.multiply(X, W), b)learning_rate = 0.01cost = tf.reduce_sum(tf.pow(activation - Y, 2))optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)training_epochs = 2000display_step = 100with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for epoch in range(training_epochs): for (x, y) in zip(train_X, train_Y): sess.run(optimizer, feed_dict=&#123;X: x, Y: y&#125;) if epoch % display_step == 0: print(\"Epoch:\", '%04d' % (epoch + 1), \"cost=\", \"&#123;:.9f&#125;\".format(sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;)), \"W=\", sess.run(W), \"b=\", sess.run(b)) print(\"Optimization Finished!\") print(\"cost=\", sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;), \"W=\", sess.run(W), \"b=\", sess.run(b)) writer = tf.summary.FileWriter('./graphs', sess.graph) plt.scatter(train_X, train_Y, color='red', label='Original data') plt.plot(train_X, sess.run(W) * train_X + sess.run(b), color='blue', label='Fitted line') plt.show()writer.close()# output:# Epoch: 0001 cost= 0.785177052 W= 1.07263 b= -0.448403# Epoch: 0101 cost= 0.440001398 W= 1.02555 b= -0.0137608# Epoch: 0201 cost= 0.437495589 W= 1.02078 b= 0.0176154# Epoch: 0301 cost= 0.437433660 W= 1.02043 b= 0.0199056# Epoch: 0401 cost= 0.437430561 W= 1.02041 b= 0.0200727# Epoch: 0501 cost= 0.437429130 W= 1.0204 b= 0.0200851# Epoch: 0601 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 0701 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 0801 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 0901 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1001 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1101 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1201 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1301 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1401 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1501 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1601 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1701 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1801 cost= 0.437429696 W= 1.0204 b= 0.0200854# Epoch: 1901 cost= 0.437429696 W= 1.0204 b= 0.0200854# Optimization Finished!# cost= 0.43743 W= 1.0204 b= 0.0200854# 可以看到迭代次数到 500 次左右数据就稳定了。 3 总结其实这只是一个开始，还有好多好多东西要去学习。越来越觉得基础的重要性，不仅仅是计算机基础，数学基础也是同等重要，特别是未来的物联网趋势，可能编码这种专业越来越淡化，只是作为某些专业人员的一种工具/技能使用。马上面临毕业，只能自己慢慢啃这些东西了…… 4 参考资料 0. 官网 1. 中文:**学院翻译 2. Matplotlib 教程 3. TensorFlow 入门","tags":[{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://fitzeng.org/tags/MachineLearning/"},{"name":"Python","slug":"Python","permalink":"http://fitzeng.org/tags/Python/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://fitzeng.org/tags/TensorFlow/"}]},{"title":"机器学习之重拾概率论","date":"2018-01-26T03:27:00.000Z","path":"2018/01/26/reProbabilityTheory/","text":"0. 前言 这里主要是围绕浙大的《概率论与数理统计》第四版的内容进行总结, 其中截取了一些图片作为内容有助于对公式的理解。笔者把这篇文章作为自己的读书笔记, 为以后系统回顾概率论提供便捷。同时会继续更新, 保证自己读懂之后再来书写。 1. 基本概念1.1 事件关系 包含事件 \\( A \\subset B \\) : 事件 \\( B \\) 包含事件 \\( A \\)，事件 \\( A \\) 发生必然导致事件 \\( B \\) 的发生。 和事件 \\( A \\cup B = \\{ x|x \\in A\\ or\\ x \\in B \\} \\) : \\( A \\) \\( B \\) 中至少有一个事件发生。 \\( \\bigcup\\limits_{k=1}\\limits^{n} A_k \\) : \\( n \\) 个事件 \\( A_1, A_2, \\ldots , A_n \\) 的和事件。 \\( \\bigcup\\limits_{k=1}\\limits^{\\infty} A_k \\) : 可列个事件 \\( A_1, A_2, \\ldots \\) 的和事件。 积事件 \\( A \\cap B = \\{ x|x \\in A\\ and\\ x \\in B \\} \\) : \\( A \\) \\( B \\) 事件同时发生。 \\( \\bigcap\\limits_{k=1}\\limits^{n} A_k \\) : \\( n \\) 个事件 \\( A_1, A_2, \\ldots , A_n \\) 的积事件。 \\( \\bigcap\\limits_{k=1}\\limits^{\\infty} A_k \\) : 可列个事件 \\( A_1, A_2, \\ldots \\) 的积事件。 差事件 \\( A - B = \\{x|x=\\in A\\ and\\ \\notin B \\} \\) : 当且仅当 \\( A \\) 发生， \\( B \\) 不发生。 互斥事件 \\( A \\cap B = \\emptyset \\) : \\( A \\) 与 \\( B \\) 事件不相容，不能同时发生。 对立事件 \\( A \\cup B = S\\ and\\ A \\cap B = \\emptyset \\) : \\( A \\) \\( B \\)事件互逆，每次实验 \\( A, B \\) 必有一个发生且只有一个发生。\\( A \\) 的对立事件记为 \\( \\overline{A}.\\ \\overline{A} = S - A \\)。 1.2 基本运算 交换律 $$ A \\cup B = B \\cup A;\\ A \\cap B = B \\cap A $$ 结合律 $$ A \\cup (B \\cup C) = (A \\cup B) \\cup C \\\\ A \\cap (B \\cap C) = (A \\cap B) \\cap C $$ 分配率 $$ A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C) \\\\ A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C) $$ 德摩根率 $$ \\overline{A \\cap B} = \\overline{A} \\cap \\overline{B};\\ \\overline{A \\cap B} = \\overline{A} \\cup \\overline{B} $$ 1.3 概率 非负性 : 对于每一个事件 \\( A \\), 有 \\( P(A) \\geq 0 \\); 规范性 : 对于必然事件 \\( S \\), 有 \\( P(S) = 1 \\); 可列可加性 : 设 \\( A_1, A_2, \\ldots \\) 是两两不相容的事件，即对于 \\( A_iA_j = \\emptyset,\\ i \\neq j, i, j = 1, 2, \\ldots \\), 有 \\( P(A_1 \\cup A_2 \\cup \\ldots) = P(A_1) + P(A_2) + \\ldots \\)。 Tips : \\( n \\to \\infty \\Longrightarrow f_n(A) = P(A) \\) 1.3.1 基本性质 \\( P(\\emptyset) = 0\\ and\\ P(A) \\leq 1 \\) 有限可加性 : \\( A_1, A_2, \\ldots, A_n \\) 为互斥事件, 则 $$ P(A_1 \\cup A_2 \\cup \\ldots \\cup A_n) = P(A_1) + P(A_2) + \\ldots + P(A_n) $$ 若 \\( A \\in B \\), 则 $$ P(B - A) = P(B) - P(A) \\\\ P(B) \\geq P(A) $$ 证明提示 : \\( B = A \\cup (B - A)\\ and\\ A(B - A) = \\emptyset \\) \\( P(\\overline{A}) = 1 - P(A) \\) 加法公式 : 任意 \\( A, B \\) 事件, 有 $$ P(A \\cup B) = P(A) + P(B) - P(AB) $$ 证明提示 : \\( A \\cup B = A \\cup (B - AB) \\) 加法公式推广$$ P(A_1 \\cup A_2 \\cup A_3) = P(A_1) + P(A_2) + P(A_3) - P(A_1A_2) - P(A_1A_3) - P(A_2A_3) + P(A_1A_2A_3) $$ 一般的有$$\\begin{aligned} P(A_1 \\cup A_2 \\cup \\ldots \\cup A_n) = {}&amp; \\sum_{i = 1}^{n}P(A_i) - \\sum_{1 \\leq i &lt; j \\leq n}P(A_iA_j) {} \\\\&amp; + \\sum_{1 \\leq i &lt; j &lt; k \\leq n}P(A_iA_jA_k) + \\ldots + (-1)^{n-1}P(A_1A_2 \\ldots A_n) \\end{aligned}$$ 1.4 古典概型 也称等可能事件, 样本空间包含有限个元素, 每个基本事件发生的可能性相同。 1.4.1 基本性质 等可能性 : 在样本空间 \\( S = \\{ e_1, e_2, \\ldots, e_n \\} \\) 则 $$ P(\\{e_1\\}) = P(\\{e_2\\}) = \\ldots = P(\\{e_n\\}) $$ 两两不相容 : 有$$\\begin{aligned}1 {}&amp; = P(S) = P(\\{e_1\\} \\cup \\{e_2\\} \\cup \\ldots \\cup \\{e_n\\}) {} \\\\&amp; = P(\\{e_1\\}) + P(\\{e_2\\}) + \\ldots + P(\\{e_n\\}) {} \\\\&amp; = nP(\\{e_i\\}) \\\\&amp; P(\\{e_i\\}) = \\frac{1}{n}, i = 1, 2, \\ldots, n.\\end{aligned}$$ 若事件 \\( A \\) 包含 \\( k \\) 个基本事件, 即 \\( A = \\{e_{i_1}\\} \\cup \\{e_{i_2}\\} \\cup \\dots \\cup \\{e_{i_k}\\} \\) 这里 \\( i_1, i_2, \\ldots, i_k \\) 是 \\( 1, 2, \\ldots, n \\) 中某 \\( k \\)个不同的数。则有 $$ P(A) = \\sum{j = 1}^{k} P(\\{ e\\{i_j} \\}) = \\frac{k}{n} = \\frac{the\\ number\\ of\\ event\\ A}{the\\ number\\ of\\ event\\ S} $$ 1.5 条件概率 主要理解就是在事件 \\( A \\) 发生了的情况下, 事件 \\( B \\) 发生的概率 \\( P(B|A) \\)。可理解样本空间为事件 \\( A \\) 发生之后的。 1.5.1 定义事件 \\( A \\) 发生的条件下发生事件 \\( B \\) 的条件概率 : $$ P(B|A) = \\frac{P(AB)}{P(A)} $$ 如果不太好理解可以换成 \\( P(AB) = P(A)P(B|A) \\), 事件 \\( AB \\) 发生的过程是事件 \\( A \\) 发生后, 再发生事件 \\( B \\), 这样就可以得出事件 \\( AB \\) 的概率 \\( P(AB) \\) 与 事件 \\( A \\) 发生的概率 \\( P(A) \\) 以及事件 \\( A \\) 后发生的事件 \\( B \\) 的概率 \\( P(B|A) \\) 的乘积相等。 同理, 概率的非负性、规范性、可列可加性条件概率同样具备, 下面解释第三条。 可列可加性 : 设 \\( B_1, B_2, \\ldots \\) 是两两不相容的事件, 则 $$ P(\\bigcup\\limits_{i=1}\\limits^{\\infty} B_i | A) = \\sum\\limits_{i = 1}\\limits^{\\infty} P(B_i | A) $$ 理解 : 体会基于事件 \\( A \\) 后发生的事件 \\( B_i \\) 的样本空间是事件 \\( A \\) 发生后的样本空间, 典型例子是在一个黑盒中不放回的取球, 求多次取出某种组合球的概率。 乘法定理 : 设 \\( P(A) &gt; 0 \\) 则$$ P(AB) = P(B|A)P(A) $$ 乘法定理推广 : 设 \\( P(AB) &gt; 0 \\) 则$$ P(ABC) = P(C|AB)P(B|A)P(A) $$ Tips : \\( P(A) \\geq P(AB) &gt; 0 \\) 是隐藏条件。一般化, 设 \\( A_1, A_2, \\ldots, A_n \\ and\\ n \\geq 2 \\ and \\ P(A_1A_2\\ldots A_{n-1}) &gt; 0\\), 则有 $$ P(A_1A_2\\ldots A_{n}) = P(A_n|A_1A_2\\ldots A_{n-1})P(A_{n-1}A_1A_2\\ldots A_{n-2}) \\ldots P(A_2|A_1)P(A_1)$$ 很好理解, 从后到前, 一个一个事件发生去思考。 1.5.2 重要公式 全概率公式 : 设实验 \\( E \\) 的样本空间为 \\( S \\), \\( A \\) 为 \\( E \\) 的事件, \\( B_1, B_2, \\ldots, B_n \\) 为 \\( S \\) 的一个划分, 且 \\( P(B_i) &gt; 0 (i = 0, 1, \\dots, n) \\), 则 $$ P(A) = P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + \\ldots + P(A|B_n)P(B_n) $$ 照前面样本空间来理解就好了, \\( P(A|B_i) \\) 代表 \\( A \\) 事件在 \\( B_i \\) 样本空间的概率, 乘以 \\( P(B_i) \\) 代表在样本空间 \\( S \\) 中, \\( B_i \\) 中的样本触发事件 \\( A \\) 的概率。当所有划分样本的概率加起来时, 就是事件 \\( A \\) 在 \\( S \\) 中发生的概率了。证明：假设 \\( P(B_i) &gt; 0 \\ (i = 1, 2, \\ldots, n) \\ and \\ (AB_i)(AB_j) = \\emptyset, i \\neq j, i, j = 1, 2, \\ldots, n \\)$$A = AS = A(B_1 \\cup B_2 \\cup \\ldots \\cup B_n) = AB_1 \\cup AB_2 \\cup \\ldots \\cup AB_n, \\\\\\begin{aligned}P(A) {} &amp; = P(AB_1) + P(AB_2) + \\ldots + P(AB_n) {} \\\\&amp; = P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + \\ldots + P(A|B_n)P(B_n)\\end{aligned}$$ 贝叶斯公式 : 设实验 \\( E \\) 的样本空间为 \\( S \\), \\( A \\) 为 \\( E \\) 的事件, \\( B_1, B_2, \\ldots, B_n \\) 为 \\( S \\) 的一个划分, 且 \\( P(A) &gt; 0,P(B_i) &gt; 0 (i = 0, 1, \\dots, n) \\), 则 $$ P(B_i|A) = \\frac{P(A|B_i)P(B_i)}{\\sum\\limits_{j = 1}\\limits^{n}P(A|B_j)P(B_j)}, i= 1,2, \\ldots, n.$$ 当 \\( n = 2 \\) 时, 这两个公式分别为 : $$ P(A) = P(A|B)P(B) + P(A|\\overline{B})P(\\overline{B}) = P(AB) + P(A\\overline{B}) \\\\ P(B|A) = \\frac{P(AB)}{P(A)} = \\frac{P(A|B)P(B)}{P(A|B)P(B) + P(A|\\overline{B})P(\\overline{B})} = \\frac{P(A|B)P(B)}{P(AB) + P(A\\overline{B})} $$ 这两个公式比较重要, 这里截取一个例子供加深理解: 1.6 独立性 理解事件 \\( A, B \\) 有 \\( P(A|B) = P(A) \\) 条件成立时, \\( A, B \\) 相互独立。 1.6.1 定义设事件 \\( A, B \\) 满足 $$ P(AB) = P(A)P(B) $$ 则称事件 \\( A, B \\) 互相独立。 1.6.2 性质若 \\( A, B \\) 互相独立, 则 \\( (A,\\overline{B})\\ (\\overline{A}, B)\\ (\\overline{A}, \\overline{B}) \\) 也相互独立。 多事件独立 : \\( A, B, C \\) 独立条件 $$ \\begin{aligned} &amp; P(AB) = P(A)P(B) \\\\ &amp; P(AC) = P(A)P(C) \\\\ &amp; P(BC) = P(B)P(C) \\\\ &amp; P(ABC) = P(A)P(B)P(C) \\end{aligned}$$ 一般, 设事件 \\( A_1, A_2, \\ldots, A_n \\) 是 \\( n \\ (n \\geq 2) \\) 个事件, 如果对于其中任意 \\( 2, 3, \\ldots, n \\)个事件的积事件的概率都等于各事件概率之积, 则称事件 \\( A_1, A_2, \\ldots, A_n \\) 相互独立。 Tips : 通过关键词自己一一回顾这一章的内容吧。随机试验, 样本空间, 随机事件, 基本事件, 频率, 概率, 古典概型, \\( A \\) 的对立事件 \\( \\overline{A} \\) 及其概率, 两互不相容事件的和事件的概率, 概率的加法定理, 条件概率, 概率的乘法公式, 全概率公式, 贝叶斯公式, 事件的独立性, 实际推断原理 2. 随机变量及其分布2.1 随机变量 在前面随机试验中, 结果可以用数来表示, 但是有些描述起来不方便, 为了处理方便, 将 \\( S \\) 中的每一个元素 \\( e \\) 与实数 \\( x \\) 对应起来, 随机变量就这样引入了。 2.2 离散型随机变量及其分布 随机变量 \\( X \\) 的取值是离散的, 如 \\( 0, 1, 2, 3 \\) 2.2.1 定义设离散型随机变量 \\( X \\) 所有可能的取值为 \\( x_k(k = 1, 2, \\ldots) , X \\) 取各个可能值的概率, 及时间 \\( \\{ X = x_k\\} \\) 的概率为 : $$ P\\{X = x_k\\} = p_k, k = 1, 2, \\ldots . $$ 同理, 概率的非负性、规范性、可列可加性离散型随机变量概率同样具备。用表格表示 \\( X \\) 的分布律:$$\\begin{array}{c|ccccc}X &amp; x_1 &amp; x_2 &amp; \\ldots &amp; x_n &amp; \\ldots \\\\\\hlinep_k &amp; p_1 &amp; p_2 &amp; \\ldots &amp; p_n &amp; \\dots\\end{array}$$ 2.2.2 几种典型的离散分布 0-1 分布 : 随机变量 \\( X \\) 只能取值 \\( 0, 1 \\) 分布律是 $$ P\\{X = k\\} = p^k(1 - p)^{1 - k}, k = 0, 1 \\ (0 &lt; p &lt; 1) $$对于随机试验 \\( S = \\{ e_1, e_2 \\}\\), 我们总能在 \\( S \\) 上定义一个服从 （0 — 1）分布的随机变量 \\( X \\) : $$ X = X(e) = \\begin{cases} 0,\\ when\\ e = e_1 \\\\ 1,\\ when\\ e = e_2 \\end{cases} $$ 来描述。 伯努利试验、二项分布 : 试验 \\( E \\) 只有两个可能的结果 \\( \\{ A, \\overline{A} \\} \\), 则称 \\( E \\) 为伯努利试验。将 \\( E \\) 重复地进行 \\( n \\) 次, 称这一串重复的独立实试验为重复伯努利试验。设 \\( P(A) = p \\) 则在 \\( n \\) 次试验中 \\( A \\) 发生 \\( k \\) 次的概率为 : $$ P\\{X = k\\} = \\left( \\begin{array}{c} n \\\\ k \\end{array} \\right) p^k{(1 - p)}^{n - k}, k = 0, 1, 2, \\ldots, n.$$ 显然 $$ \\sum\\limits_{k = 0}\\limits^{n}P\\{X = k\\} = \\sum\\limits_{k = 0}\\limits^{n} \\left( \\begin{array}{c} n \\\\ k \\end{array} \\right) p^k{(1 - p)}^{n - k} = {(p + (1 - p))}^n = 1 $$ 二项式 \\( {(p + (1 - p))}^n \\) 的第 \\( k \\) 项展开 \\( \\left( \\begin{array}{c} n \\\\ k \\end{array} \\right) p^k{(1 - p)}^{n - k} \\)。 所以, 我们称 \\( X \\) 服从参数为 \\( n, p \\) 的二项分布, 记作 : $$ X \\sim b(n, p) $$ 特别的, 当 \\( n = 1 \\)时为二项分布 : $$ P\\{X = k\\} = p^k{(1 - p)}^{1 - k}, k = 0, 1.$$ 泊松分布 : 随机变量 \\( X = \\{0, 1, 2, \\ldots \\} \\), 而各个概率的取值为 $$ P\\{X = k\\} = \\frac{\\lambda^k e^{-\\lambda}}{k!}, k = 0, 1, 2, \\ldots, \\lambda &gt; 0 $$ 则称 \\( X \\)服从参数为 \\( \\lambda \\) 的泊松分布, 记作 : $$ X \\sim \\pi(\\lambda) $$ 显然 $$ \\sum\\limits_{k = 0}^{\\infty}P\\{X = k\\} = \\sum\\limits_{k = 0}^{\\infty} \\frac{\\lambda^k e^{-\\lambda}}{k!} = e^{-\\lambda} \\sum\\limits_{k = 0}^{\\infty}\\frac{\\lambda^k}{k!} = e^{-\\lambda}e^\\lambda = 1 $$ 具体使用后面会慢慢介绍。 泊松定理 : 设 \\( \\lambda &gt; 0, np_n = \\lambda \\ n \\)为任意正整数, 则对于任意一个固定的非负整数 \\( k \\), 有 $$ \\lim_{n \\rightarrow \\infty} \\left( \\begin{array}{c} n \\\\ k \\end{array} \\right) p_n^k{(1 - p_n)}^{n - k} = \\frac{\\lambda^k e^{-\\lambda}}{k!} $$ 这就是用泊松分布逼近二项分布的泊松定理。证明截图如下 :上面的证明说明了, 当 \\( n \\rightarrow \\infty\\) 时, 以 \\( n, p \\) 为参数的二项分布概率值可以由参数为 \\( \\lambda = np \\) 的泊松分布的概率值近似。举个栗子 2.3 随机变量的分布函数 对于非离散的随机变量 \\( X \\) 指定某一实数值得概率都为 \\( 0 \\)。所以这里就改为研究随机变量所落区间的概率 : $$ P\\{x_1 &lt; X \\leq x_2\\} = P(X \\leq x_2) - P(X \\leq x_1) $$ 画个数轴就很好理解了。 2.3.1 定义设 \\( X \\) 是一个随机变量, \\( x \\) 是任意实数, 函数 : $$ F(x) = P\\{ X \\leq x\\}, -\\infty &lt; x &lt; \\infty $$ 称为 \\( X \\) 的分布函数。对任意实数 \\( x_1, x_2 (x_1 &lt; x_2) \\), 有 $$ P\\{x_1 &lt; X \\leq x_2\\} = P(X \\leq x_2) - P(X \\leq x_1) = F(x_2) - F(x_1) $$ 2.3.2 基本性质 \\( F(x) \\) 是一个不减函数。 \\( 0 \\leq F(x) \\leq 1 \\ and\\ F(-\\infty) = \\lim\\limits_{x\\rightarrow-\\infty}F(x) = 0 \\ F(\\infty) = \\lim\\limits_{x\\rightarrow\\infty}F(x) = 1 \\) 2.4 连续型随机变量及其概率密度 如上一节分析, 随机变量 \\( X \\) 的分布函数 \\( F(x) \\)存在非负函数 \\( f(x) \\), 使得任意实数 \\( x \\)有 $$ F(x) = \\int_{-\\infty}^{x}f(x)dt $$ 则称 \\( X \\)为连续型随机变量, 其中函数 \\( f(x) \\) 称为 \\( X \\) 的概率密度函数, 简称概率密度。 \\( f(x) \\geq 0 \\) \\( \\int_{-\\infty}^{\\infty} f(x)dx = 1 \\) 对于任意实数 \\( x_1, x_2 (x_1 \\leq x_2) \\) $$ P(x_1 &lt; X \\leq x_2) = F(x_2) - F(x_1) = \\int_{x_1}^{x_2}f(x)dx $$ 若 \\( f(x) \\) 在 \\( x \\)出连续, 则 \\( F^{‘}(x) = f(x) \\) 2.4.1 几种典型的连续型随机变量 均匀分布 : 若连续型随机变量 \\( X \\) 的概率密度为 $$ f(x) = \\begin{cases} \\frac{1}{b - a},\\ a &lt; x &lt; b \\\\ 0,\\ others \\end{cases} $$ 则称 \\( X \\) 在区间 \\( (a, b) \\) 上服从均匀分布。记为 \\( X \\sim U(a, b) \\)。分布函数为 $$ F(x) = \\begin{cases} 0,\\ x &lt; a \\\\ \\frac{x - a}{b - a},\\ a \\leq x &lt; b \\\\ 1,\\ x \\geq b \\end{cases} $$ 指数分布 : 若连续型随机变量 \\( X \\) 的概率密度为 $$ f(x) = \\begin{cases} \\frac{1}{\\theta}e^{-x/\\theta},\\ x &gt; 0 \\\\ 0,\\ others \\end{cases} $$ 其中 \\( \\theta &gt; 0 \\) 为常数, 则称 \\( X \\) 服从参数为 \\( \\theta \\) 的指数分布。分布函数为 $$ f(x) = \\begin{cases} 1 - e^{-x/\\theta},\\ x &gt; 0 \\\\ 0,\\ others \\end{cases} $$指数分布的无记忆性 : 对于任意 \\( s, t &gt; 0 \\), 有 $$ P\\{ X &gt; s + t | X &gt; s\\} = P\\{ X &gt; t \\} $$ 证明 : 正态分布 : 若连续型随机变量 \\( X \\) 的概率密度为 $$ f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e ^{- \\frac{(x - \\mu)^2}{2\\sigma^2}}, \\ -\\infty &lt; x &lt; \\infty $$ 其中 \\( \\mu, \\sigma (\\sigma &gt; 0) \\) 为常数, 则称 \\( X \\) 服从参数为 \\( \\mu, \\sigma \\) 的正态分布或高斯分布, 记为 \\( X \\sim N(\\mu, \\sigma^2) \\)。证明 : 曲线关于 \\( x = \\mu \\) 对称, 这表明对于任意 \\( h &gt; 0 \\) 有 $$ P\\{ \\mu - h &lt; X \\leq \\mu \\} = P\\{ \\mu &lt; X \\leq \\mu + h \\} $$ 当 \\( x = \\mu \\) 时取最大值 $$ f(\\mu) = \\frac{1}{\\sqrt{2\\pi}\\sigma} $$ 在 \\( x = \\mu \\pm \\sigma \\) 处曲线有拐点。特别, 当 \\( \\mu = 0, \\sigma = 1 \\) 时, 称随机变量 \\( X \\) 服从标准正态分布。其概率密度和分布函数分别用 \\( \\varphi (x), \\Phi (x) \\) 表示, 即有 $$ \\varphi (x) = \\frac{1}{\\sqrt{2\\pi}}e^{-t^2/2} \\\\ \\Phi (x) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x}e^{-t^2/2}dt \\\\ \\Phi (-x) = 1 - \\Phi (x) $$ 2.5 随机变量的函数的分布 这里主要介绍在已知随机变量 \\( X \\) 的概率求 \\( Y = g(X) \\ g(\\cdot) \\) 是已知连续函数。 举个栗子 设随机变量 \\( X \\) 具有概率密度 \\( f_X(x), \\ -\\infty &lt; x &lt; \\infty \\), 又设函数 \\( g(x) \\) 处处可导, 恒有 \\( g(x)^{‘} &gt; 0 \\ or \\ g(x)^{‘} &lt; 0 \\), 则 \\( Y = g(X) \\) 是连续型随机变量, 其概率密度为 $$ f_Y(y) = \\begin{cases} f_X[h(y)]|h^{‘}(y)|, \\ \\alpha &lt; y &lt; \\beta \\\\ 0, \\ others \\end{cases} $$ 其中 \\( \\alpha = min\\{ g(-\\infty), g(\\infty) \\} \\ \\beta = max\\{ g(-\\infty), g(\\infty) \\} \\ h(x) \\) 是 \\( g(x) \\) 的反函数。证明提示 : 见上一个🌰 小结 : 3. TODO未完待续…","tags":[{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://fitzeng.org/tags/MachineLearning/"},{"name":"ProbabilityTheory","slug":"ProbabilityTheory","permalink":"http://fitzeng.org/tags/ProbabilityTheory/"}]},{"title":"MarkDown 插入数学公式实验大集合","date":"2018-01-23T03:27:00.000Z","path":"2018/01/23/LaTexFormula/","text":"0. 前言 最近在学习一些机器学习相关的知识，想把自己学习的东西通过 MD 的形式在线记录下来，但是之前一直没有开始行动，因为里面的公式什么的感觉实在是麻烦。于是今天打算花点时间了解一下如何在 markdown 中插入数学公式，发现其实很简单，大概花一个小时左右就能知道如何编写了。 1. 基础认识 笔者认为所谓插入数学公式其实就是引入一种规则，然后通过模板？渲染成公式，不知道这个理解对不对，不对望指正。其实你以前可能就看到过有的博客本该出现公式的时候不显示，点击后会链接到一个 new tab 然后显示一张公式的图片，有时却出现一大堆的代码。这里就是通过这段代码解析成公式然后显示的。 这里我们选取 MathJax 引擎。引入脚本，把下面代码插入 MD 文件里面，如果你怕这份在线文件源别人访问不到的话，可以把这个下下来自己做一个源，这样比较稳定缺点是要自己手动更新源。 1&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; 好了到这里就可以插入公式了，如果你懂 LaTeX 的话那看一两个例子就知道了，不懂也没关系，自己写一写代码就知道了，可以找一个可以预览 MD 的工具一直尝试。 1.1 插入方式 这里分两种，一种是行间插入，另一种是另取一行 1.1.1 行间插入1\\\\(a + b\\\\) 这里是行间插入公式 a + b : \\(a + b\\)，特点就是通过( 和 ) 包含公式，然后为了模板引擎能够区分该 ( 不是普通文本的 ( 而是公式的 (，通过 \\\\ 转义一下。这样应该就很好理解这个语法构成了。注意这里方式不唯一，这是笔者喜欢的方式，其他的使用方式自行搜索。下面的介绍同样是这样。 1.1.2 另取一行1$$a + b$$ 这里是另取一行$$a + b$$ 特点就是通过$$包含公式。 笔者认为第二种方式更好，以下没看 JS 源码纯属猜测：行间的需要考虑到当前行的行高并对公式进行处理，而另取一行就更简单一些，可能解析起来更快。最最最最最最主要是看起来漂亮 ^_^ 不太要考虑空间不够换行。 1.2 基本类型的插入 这里对 @houkai ：LATEX数学公式基本语法 的思路稍加修改，然后进行介绍。 1.2.1 上、下标先看结果再总结语法吧。 1234567891011$$x_1$$$$x_1^2$$$$x^2_1$$$$x_&#123;22&#125;^&#123;(n)&#125;$$$$&#123;&#125;^*x^*$$$$x_&#123;balabala&#125;^&#123;bala&#125;&amp;&amp; $$x_1$$ $$x_1^2$$ $$x^2_1$$ $$x_{22}^{(n)}$$ $${}^*x^*$$ $$x_{balabala}^{bala}$$ 可以看到 x 元素的上标通过 ^ 符号后接的内容体现，下表通过 _ 符号后接的内容体现，多于一位是要加 {} 包裹的。笔者习惯先下标后上标的写法，和我的书写习惯一致：x_{balabala}^{bala}，不管你使用哪一种风格，最好自己注意统一，不要混用。 1.2.2 分式123$$\\frac&#123;x+y&#125;&#123;2&#125;$$$$\\frac&#123;1&#125;&#123;1+\\frac&#123;1&#125;&#123;2&#125;&#125;$$ $$\\frac{x+y}{2}$$ $$\\frac{1}{1+\\frac{1}{2}}$$ 这里就出现了一个 frac{}{} 函数的东西，同样，为了区分这是函数不是几个字母，通过 \\frac 转义，于是 frac 被解析成函数，然后第一个 {} 里面的被解析成分子，第二个 {} 被解析成分母。这里可以试试分数的行间解析\\(\\frac{1}{1+\\frac{1}{2}}\\)。我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果。 1.2.3 根式12345$$\\sqrt&#123;2&#125;&lt;\\sqrt[3]&#123;3&#125;$$$$\\sqrt&#123;1+\\sqrt[p]&#123;1+a^2&#125;&#125;$$$$\\sqrt&#123;1+\\sqrt[^p\\!]&#123;1+a^2&#125;&#125;$$ $$\\sqrt{2}&lt;\\sqrt[3]{3}$$ $$\\sqrt{1+\\sqrt[p]{1+a^2}}$$ $$\\sqrt{1+\\sqrt[^p]{1+a^2}}$$ 读到这里你已经了解了函数的概念，那么这历久很简单了，语法就是 sqrt[]{} 。[] 中代表是几次根式，{} 代表根号下的表达式。第二和第三个的区别在于为了美观微调位置 ^_^。 1.2.4 求和、积分1234567$$\\sum_&#123;k=1&#125;^&#123;n&#125;\\frac&#123;1&#125;&#123;k&#125;$$\\\\(\\sum_&#123;k=1&#125;^n\\frac&#123;1&#125;&#123;k&#125;\\\\)$$\\int_a^b f(x)dx$$\\\\(\\int_a^b f(x)dx\\\\) $$\\sum_{k=1}^{n}\\frac{1}{k}$$ \\(\\sum_{k=1}^n\\frac{1}{k}\\) $$\\int_{a}^b f(x)dx$$ \\(\\int_a^b f(x)dx\\) 这里很容易看出求和函数表达式 sum_{起点}^{终点}表达式，积分函数表达式 int_下限^上限 被积函数d被积量。还有一个有趣的是行间的公式都被压缩了。 1.2.5 空格1234567紧贴 $a\\\\!b$没有空格 $ab$小空格 a\\,b中等空格 a\\;b大空格 a\\ bquad空格 $a\\quad b$两个quad空格 $a\\qquad b$ $$a\\!b$$$$ab$$$$a\\,b$$$$a\\;b$$$$a\\ b$$$$a\\quad b$$$$a\\qquad b$$ 这个直接看上面的文字，介绍很清楚，主要指微调距离，使得公式更加漂亮。请比较下面的积分公式： 123$$\\int_a^b f(x)\\mathrm&#123;d&#125;x$$$$\\int_a^b f(x)\\,\\mathrm&#123;d&#125;x$$ $$\\int_a^b f(x)\\mathrm{d}x$$ $$\\int_a^b f(x)\\,\\mathrm{d}x$$ 1.2.6 公式界定符12345678\\\\( ( \\\\)\\\\( ) \\\\)\\\\( [ \\\\)\\\\( ] \\\\)\\\\( \\\\&#123; \\\\)\\\\( \\\\&#125; \\\\)\\\\( | \\\\)\\\\( \\\\| \\\\) 主要符号有\\( ( \\)\\( ) \\)\\( [ \\)\\( ] \\)\\( \\{ \\)\\( \\} \\)\\( | \\)\\( \\| \\)那么如何使用呢？通过 \\left 和 \\right 后面跟界定符来对同时进行界定。 1$$\\left(\\sum_&#123;k=\\frac&#123;1&#125;&#123;2&#125;&#125;^&#123;N^2&#125;\\frac&#123;1&#125;&#123;k&#125;\\right)$$ $$\\left(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k}\\right)$$ 1.2.7 矩阵12345678910111213$$\\begin&#123;matrix&#125;1 &amp; 2\\\\\\\\3 &amp;4\\end&#123;matrix&#125;$$$$\\begin&#123;pmatrix&#125;1 &amp; 2\\\\\\\\3 &amp;4\\end&#123;pmatrix&#125;$$$$\\begin&#123;bmatrix&#125;1 &amp; 2\\\\\\\\3 &amp;4\\end&#123;bmatrix&#125;$$$$\\begin&#123;Bmatrix&#125;1 &amp; 2\\\\\\\\3 &amp;4\\end&#123;Bmatrix&#125;$$$$\\begin&#123;vmatrix&#125;1 &amp; 2\\\\\\\\3 &amp;4\\end&#123;vmatrix&#125;$$$$\\left|\\begin&#123;matrix&#125;1 &amp; 2\\\\\\\\3 &amp;4\\end&#123;matrix&#125;\\right|$$$$\\begin&#123;Vmatrix&#125;1 &amp; 2\\\\\\\\3 &amp;4\\end&#123;Vmatrix&#125;$$ $$\\begin{matrix}1 &amp; 2\\\\3 &amp;4\\end{matrix}$$ $$\\begin{pmatrix}1 &amp; 2\\\\3 &amp;4\\end{pmatrix}$$ $$\\begin{bmatrix}1 &amp; 2\\\\3 &amp;4\\end{bmatrix}$$ $$\\begin{Bmatrix}1 &amp; 2\\\\3 &amp;4\\end{Bmatrix}$$ $$\\begin{vmatrix}1 &amp; 2\\\\3 &amp;4\\end{vmatrix}$$ $$\\left|\\begin{matrix}1 &amp; 2\\\\3 &amp;4\\end{matrix}\\right|$$ $$\\begin{Vmatrix}1 &amp; 2\\\\3 &amp;4\\end{Vmatrix}$$ 类似于 left right，这里是 begin 和 end。而且里面有具体的矩阵语法，&amp; 区分行间元素，\\\\\\\\ 代表换行。可以理解为 HTML 的标签之类的。 1.2.8 排版数组123456\\mathbf&#123;X&#125; =\\left( \\begin&#123;array&#125;&#123;ccc&#125;x\\_&#123;11&#125; &amp; x\\_&#123;12&#125; &amp; \\ldots \\\\\\\\x\\_&#123;21&#125; &amp; x\\_&#123;22&#125; &amp; \\ldots \\\\\\\\\\vdots &amp; \\vdots &amp; \\ddots\\end&#123;array&#125; \\right) $$\\mathbf{X} =\\left( \\begin{array}{ccc}x_{11} &amp; x_{12} &amp; \\ldots \\\\x_{21} &amp; x_{22} &amp; \\ldots \\\\\\vdots &amp; \\vdots &amp; \\ddots\\end{array} \\right)$$ 2. 常用公式举例 持续更新…… 2.1 多行公式 主要是各种方程的表达 2.1.1 长公式12345678910111213$$\\begin&#123;multline&#125;x = a+b+c+&#123;&#125; \\\\\\\\d+e+f+g\\end&#123;multline&#125;$$$$\\begin&#123;aligned&#125;x =&#123;&#125;&amp; a+b+c+&#123;&#125; \\\\\\\\&amp;d+e+f+g\\end&#123;aligned&#125;$$ 不对齐 $$\\left| \\begin{multline}x = a+b+c+{} \\\\d+e+f+g\\end{multline} \\right|$$ 对齐 $$\\left| \\begin{aligned}x ={}&amp; a+b+c+{} \\\\&amp;d+e+f+g\\end{aligned} \\right|$$ 2.1.2 公式组12345678910111213$$\\begin&#123;gather&#125;a = b+c+d \\\\\\\\x = y+z\\end&#123;gather&#125;$$$$\\begin&#123;align&#125;a &amp;= b+c+d \\\\\\\\x &amp;= y+z\\end&#123;align&#125;$$ $$\\begin{gather}a = b+c+d \\\\x = y+z\\end{gather}$$ $$\\begin{align}a &amp;= b+c+d \\\\x &amp;= y+z\\end{align}$$ 2.1.3 分段函数123456$$y=\\begin&#123;cases&#125;-x,\\quad x\\leq 0 \\\\\\\\x,\\quad x&gt;0\\end&#123;cases&#125;$$ $$y=\\begin{cases}-x,\\quad x\\leq 0 \\\\x,\\quad x&gt;0\\end{cases}$$ 里面用到了 \\(\\leq\\) 符号，下一章会介绍常用数学符号。 2.2 数组的其他使用2.2.1 划线1234567$$\\left(\\begin&#123;array&#125;&#123;|c|c|&#125;1 &amp; 2 \\\\\\\\\\\\hline3 &amp; 4\\end&#123;array&#125;\\right)$$ $$\\left( \\begin{array}{|c|c|}1 &amp; \\ldots \\\\\\hline\\vdots &amp; \\ddots\\end{array} \\right)$$ 2.2.2 制表123456789$$\\begin&#123;array&#125;&#123;|c|c|&#125;\\hline&#123;1111111111&#125; &amp; 2 \\\\\\\\\\hline3 &amp; 4 \\\\\\\\\\hline\\end&#123;array&#125;$$ $$\\begin{array}{|c|c|}\\hline{1111111111} &amp; 2 \\\\\\hline{balabala} &amp; 你好啊 {}^\\land\\_{}^\\land \\\\\\hline\\end{array}$$ 可以看到，其实其他很多东西都可以很灵活的表达出来。碰到其他有趣的我会继续写出来的。 3. 常用数学符号 这里提供一个文档下载，如果上面的链接失效，也可以到我的 GitHub 下载 pdf 版。下面举几个例子。 3.1 希腊字母123456789101112131415161718192021222324252627$$\\begin&#123;array&#125;&#123;|c|c|c|c|c|c|c|c|&#125;\\hline&#123;\\alpha&#125; &amp; &#123;\\backslash alpha&#125; &amp; &#123;\\theta&#125; &amp; &#123;\\backslash theta&#125; &amp; &#123;o&#125; &amp; &#123;o&#125; &amp; &#123;\\upsilon&#125; &amp; &#123;\\backslash upsilon&#125; \\\\\\\\\\hline&#123;\\beta&#125; &amp; &#123;\\backslash beta&#125; &amp; &#123;\\vartheta&#125; &amp; &#123;\\backslash vartheta&#125; &amp; &#123;\\pi&#125; &amp; &#123;\\backslash pi&#125; &amp; &#123;\\phi&#125; &amp; &#123;\\backslash phi&#125; \\\\\\\\\\hline&#123;\\gamma&#125; &amp; &#123;\\backslash gamma&#125; &amp; &#123;\\iota&#125; &amp; &#123;\\backslash iota&#125; &amp; &#123;\\varpi&#125; &amp; &#123;\\backslash varpi&#125; &amp; &#123;\\varphi&#125; &amp; &#123;\\backslash varphi&#125; \\\\\\\\\\hline&#123;\\delta&#125; &amp; &#123;\\backslash delta&#125; &amp; &#123;\\kappa&#125; &amp; &#123;\\backslash kappa&#125; &amp; &#123;\\rho&#125; &amp; &#123;\\backslash rho&#125; &amp; &#123;\\chi&#125; &amp; &#123;\\backslash chi&#125; \\\\\\\\\\hline&#123;\\epsilon&#125; &amp; &#123;\\backslash epsilon&#125; &amp; &#123;\\lambda&#125; &amp; &#123;\\backslash lambda&#125; &amp; &#123;\\varrho&#125; &amp; &#123;\\backslash varrho&#125; &amp; &#123;\\psi&#125; &amp; &#123;\\backslash psi&#125; \\\\\\\\\\hline&#123;\\varepsilon&#125; &amp; &#123;\\backslash varepsilon&#125; &amp; &#123;\\mu&#125; &amp; &#123;\\backslash mu&#125; &amp; &#123;\\sigma&#125; &amp; &#123;\\backslash sigma&#125; &amp; &#123;\\omega&#125; &amp; &#123;\\backslash omega&#125; \\\\\\\\\\hline&#123;\\zeta&#125; &amp; &#123;\\backslash zeta&#125; &amp; &#123;\\nu&#125; &amp; &#123;\\backslash nu&#125; &amp; &#123;\\varsigma&#125; &amp; &#123;\\backslash varsigma&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\\\\\\\hline&#123;\\eta&#125; &amp; &#123;\\backslash eta&#125; &amp; &#123;\\xi&#125; &amp; &#123;\\backslash xi&#125; &amp; &#123;\\tau&#125; &amp; &#123;\\backslash tau&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\\\\\\\hline&#123;\\Gamma&#125; &amp; &#123;\\backslash Gamma&#125; &amp; &#123;\\Lambda&#125; &amp; &#123;\\backslash Lambda&#125; &amp; &#123;\\Sigma&#125; &amp; &#123;\\backslash Sigma&#125; &amp; &#123;\\Psi&#125; &amp; &#123;\\backslash Psi&#125; \\\\\\\\\\hline&#123;\\Delta&#125; &amp; &#123;\\backslash Delta&#125; &amp; &#123;\\Xi&#125; &amp; &#123;\\backslash Xi&#125; &amp; &#123;\\Upsilon&#125; &amp; &#123;\\backslash Upsilon&#125; &amp; &#123;\\Omega&#125; &amp; &#123;\\backslash Omega&#125; \\\\\\\\\\hline&#123;\\Omega&#125; &amp; &#123;\\backslash Omega&#125; &amp; &#123;\\Pi&#125; &amp; &#123;\\backslash Pi&#125; &amp; &#123;\\Phi&#125; &amp; &#123;\\backslash Phi&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\\\\\\\hline\\end&#123;array&#125;$$ $$\\begin{array}{|c|c|c|c|c|c|c|c|}\\hline{\\alpha} &amp; {\\backslash alpha} &amp; {\\theta} &amp; {\\backslash theta} &amp; {o} &amp; {o} &amp; {\\upsilon} &amp; {\\backslash upsilon} \\\\\\hline{\\beta} &amp; {\\backslash beta} &amp; {\\vartheta} &amp; {\\backslash vartheta} &amp; {\\pi} &amp; {\\backslash pi} &amp; {\\phi} &amp; {\\backslash phi} \\\\\\hline{\\gamma} &amp; {\\backslash gamma} &amp; {\\iota} &amp; {\\backslash iota} &amp; {\\varpi} &amp; {\\backslash varpi} &amp; {\\varphi} &amp; {\\backslash varphi} \\\\\\hline{\\delta} &amp; {\\backslash delta} &amp; {\\kappa} &amp; {\\backslash kappa} &amp; {\\rho} &amp; {\\backslash rho} &amp; {\\chi} &amp; {\\backslash chi} \\\\\\hline{\\epsilon} &amp; {\\backslash epsilon} &amp; {\\lambda} &amp; {\\backslash lambda} &amp; {\\varrho} &amp; {\\backslash varrho} &amp; {\\psi} &amp; {\\backslash psi} \\\\\\hline{\\varepsilon} &amp; {\\backslash varepsilon} &amp; {\\mu} &amp; {\\backslash mu} &amp; {\\sigma} &amp; {\\backslash sigma} &amp; {\\omega} &amp; {\\backslash omega} \\\\\\hline{\\zeta} &amp; {\\backslash zeta} &amp; {\\nu} &amp; {\\backslash nu} &amp; {\\varsigma} &amp; {\\backslash varsigma} &amp; {} &amp; {} \\\\\\hline{\\eta} &amp; {\\backslash eta} &amp; {\\xi} &amp; {\\backslash xi} &amp; {\\tau} &amp; {\\backslash tau} &amp; {} &amp; {} \\\\\\hline{\\Gamma} &amp; {\\backslash Gamma} &amp; {\\Lambda} &amp; {\\backslash Lambda} &amp; {\\Sigma} &amp; {\\backslash Sigma} &amp; {\\Psi} &amp; {\\backslash Psi} \\\\\\hline{\\Delta} &amp; {\\backslash Delta} &amp; {\\Xi} &amp; {\\backslash Xi} &amp; {\\Upsilon} &amp; {\\backslash Upsilon} &amp; {\\Omega} &amp; {\\backslash Omega} \\\\\\hline{\\Omega} &amp; {\\backslash Omega} &amp; {\\Pi} &amp; {\\backslash Pi} &amp; {\\Phi} &amp; {\\backslash Phi} &amp; {} &amp; {} \\\\\\hline\\end{array}$$ 写太累了😂😂😂。。。其他的详见 PDF。 4. 总结 通过这样梳理一下基本的公式都能插入了，而且也会如何查资料。对于自己日后学习 LaTeX 写论文有很大帮助。以下建议带有很强的主观性，仅供参考。 公式一律使用另取一行，并且上下都空一行 一个公式一个语句，不要写在一个 $$***$$ 里，保证独立性，一个公式错误不影响另一个公式。 风格统一，不要混用。比如上下标的写法：x_{balabala}^{bala} 行间字母可以使用 \\\\(a\\\\) 代替 a ，养成自己的写作风格。 最后：我的 Blog 和 GitHub，感谢阅读。 5. 参考资料 十分感谢以下作者的无私分享。 Markdown中插入数学公式的方法 LATEX数学公式基本语法 一份其实很短的 LaTeX 入门文档","tags":[{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://fitzeng.org/tags/MarkDown/"},{"name":"Formula","slug":"Formula","permalink":"http://fitzeng.org/tags/Formula/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://fitzeng.org/tags/LaTeX/"}]},{"title":"GitNote","date":"2017-12-16T03:27:00.000Z","path":"2017/12/16/GitNote/","text":"0. 前言 在使用 Git 时有一种感觉就是只会 add | commit | push 三个命令。因为这三个命令似乎足以把代码提交到 GitHub 上，即使是碰到某个问题，也可以直接 Google。但是对于其中的逻辑和版本管理的精髓没有体会到，而只是作为一个在线代码仓库在使用，这样做也没有什么不可以，但是如果能系统的了解为什么要有版本管理工具，以及版本管理工具能够给我们提供怎么样的管理服务，对于使用工具的我们来说有很大帮助。不用记住命令，只是以后遇到问题时知道这个工具有实现的方式就足够了。 现在我系统的看了一下官方的 Git 入门教程 Git 官方教程（中字） 里面通过描述对命令的使用情景进而选择命令进行操作的方式，使得命令很容易理解也容易加深记忆。比起单一的命令用文字解释这种方式，对于不熟悉 Git 的人来说是十分友好的。但是，看完容易忘，所以写了这篇整理笔记用作辅助查询。 1. 基本命令1.1 了解帮助命令 git help : 查看命令 git help add : 查看 git add 命令的具体解释 1.2 仓库初始化 git init : 创建 .git, 适合在已存在项目追加版本控制 git init projectname : 创建 projectname/.git, 适合项目开始时加入版本控制 1.3 文件基本操作 git add filename/* : 添加文件[产生暂存文件] git commmit -m &quot;message&quot; : 将添加的文件提交到本地仓库[产生提交文件] git rm filename : 移除文件，使用 rm filename 的有暂存 git add -u . : 如果之前使用非 git 命令删除文件，可以使用这个命令把当前目录的文件重新遍历清除 git rm --cache filename : 暂存但是不参与跟踪 git mv filepath newfilepath : 移动文件 git rm filepath &amp;&amp; git add newfilepath : 移动文件，之前使用非 git 命令移动文件 git add -A . : 如果之前使用非 git 命令移动文件，可以使用这个命令把当前目录的文件重新遍历移动，和 rm 命令类似 git reset etc... : 历史提交管理(回退，合并…)，checkout 更关注文件 1.4 查看文件修改 git status : 查看文件信息 git diff : 查看修改[工作树和暂存文件] git diff --staged : 查看修改[暂存文件和最近提交文件] git diff HEAD : 查看修改[工作树和最近提交文件] git diff --word-diff : 查看修改的单词用颜色标出 git diff --stat : 查看修改的文件名 参考资料 0. Git 学习（三）本地仓库操作——git add &amp; commit 了解 git 版本库实现 1.5 查看提交 Log git log : 显示提交信息 git log --oneline : 显示提交 Message git log --stat : 显示提交文件名级详细修改信息 git log --patch : 显示提交文件内容级详细修改信息 git log --graph : 用图显示提交记录 git log --graph --all --decorate --oneline : 去除冗余信息，更加直观显示每条分支每次提交 git log --stat -- filename : 文件提交记录（不记录路径移动） git log --stat -M --follow -- filename : 看到完整的文件操作过程 1.6 忽略文件 touch .gitignore : 创建文件(次级目录也可以创建) vim .gitignore : 编辑文件添加 ignore 文件。*.log | tmp/ | .sass-cache etc... git ls-files --others --ignored --exclude-standard : 查看被 ignore 的文件 git reflog : 详细修改日志 1.7 分支操作 git branch branchname : 创建分支 git branch : 显示分支 git branch -d branchname : 删除分支 git branch -D branchname : 删除未合并分支 git checkout branchname : 切换分支 git checkout commitID : 工作树切换到 commitID 时 git checkout -- filename : 清理掉最后一次提交内容 git checkout -b branchname : 创建新分支并且进入该分支 git merge branchname : 和并 branchname 分支到目前所在分支(合并时文件冲突要手动解决) git merge --abort : 清除工作目录和暂存区 git merge squash branchname : 将合并的分支改变变成一个 commit git rebase branchname : 将当前分支历史提交合并到 branchname 分支 参考资料 2. 代码合并：Merge、Rebase 的选择 1.8 远程操作 git remote add origin https://github.com/accountname/projectname git remote set-url origin newUrl : 改变 URL git remote rm origin : 删除 git remote -v : 查看 URL git fetch origin : 抓取远程分支，本地会有一个 remotehostname/branchname 的分支，一般用于查看伙伴代码 git pull origin : 和 fetch 类似，但是是取回远程更新和本地合并。相当于先 fetch 再 merge。 git push origin : push 到远程仓库 参考资料 1. Git远程操作详解 2. 总结 其实在开始把 Git 整个命令流程学习下来之前，对 Git 理解十分浅显，使用命令也是抱着试试看的心态，错了搜索解决方法重试，对了就不追究原因了。这种方式感觉更加浪费时间，而且很可能多次遇到重复问题。觉得以后学习某个东西还是得大概了解整个系统才好，想快速入门未尝不可，但是闲下来的时候要去多问问为什么，这样有了宏观的概念，出了问题说不定能自己摸索着解决。还有一点，实践确实是比单一的阅读或看视频更加记忆深刻，对命令的理解也是同理，所以最好都敲一遍。 GitHub Blog 掘金 多谢阅读 ^_^ 3. 参考资料 -1. GitHub&amp;Git入门基础 0. Git 学习（三）本地仓库操作——git add &amp; commit 1. Git远程操作详解 2. 代码合并：Merge、Rebase 的选择 3. GitHub 高质量的Git中文教程","tags":[{"name":"Git","slug":"Git","permalink":"http://fitzeng.org/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://fitzeng.org/tags/GitHub/"},{"name":"Tool","slug":"Tool","permalink":"http://fitzeng.org/tags/Tool/"}]},{"title":"完美解决 Linux 的【dpkg： warning： files list file for package 'XXXXXXX' missing, assuming package has no files currently installed】Bug","date":"2017-11-04T03:27:00.000Z","path":"2017/11/04/linuxDpkgBug/","text":"0.前言 估计是之前动了或者损坏了 /var/lib/dpkg/info 里面的文件，每次执行 apt 类的命令总是输出一大段东西，在网上找了很多资料，有解决方案，但是不全。。。很多都是失败的。最后我发现 reinstall 可以解决，所以打算写个脚本执行文件。 1.解决方法1.1 创建一下三个文件 fixit.py fix.sh txt 1.2 填写内容先来最简单的 fix.sh，不用填写内容，是空文件。 接着就写 txt，直接把错误日志复制进去，如： 1234567891011dpkg: warning: files list file for package &apos;libodbc1:amd64&apos; missing; assuming package has no files currently installeddpkg: warning: files list file for package &apos;dh-autoreconf&apos; missing; assuming package has no files currently installeddpkg: warning: files list file for package &apos;erlang-webtool&apos; missing; assuming package has no files currently installeddpkg: warning: files list file for package &apos;libhtml-template-perl&apos; missing; assuming package has no files currently installed.......dpkg: warning: files list file for package &apos;libvirt-dev:amd64&apos; missing; assuming package has no files currently installeddpkg: warning: files list file for package &apos;autopoint&apos; missing; assuming package has no files currently installeddpkg: warning: files list file for package &apos;libconfig-general-perl&apos; missing; assuming package has no files currently installeddpkg: warning: files list file for package &apos;ubuntu-cloud-keyring&apos; missing; assuming package has no files currently installeddpkg: warning: files list file for package &apos;tgt&apos; missing; assuming package has no files currently installeddpkg: warning: files list file for package &apos;libfdt1:amd64&apos; missing; assuming package has no files currently installed 下面写 fixit.py 1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = &apos;Fitzeng&apos;import redef main(): fix = open(&apos;fix.sh&apos;, &apos;w+&apos;) for line in open(&quot;txt&quot;): pkg = re.match(re.compile(&apos;&apos;&apos;dpkg: warning: files list file for package &apos;(.+)&apos; &apos;&apos;&apos;), line) if pkg: cmd = &quot;sudo apt-get install --reinstall &quot; + pkg.group(1) fix.write(cmd + &apos;\\n&apos;)if __name__ == &quot;__main__&quot;: main() 1.3 执行命令如果权限不够可以直接先 chmod 777 *，然后执行 python fixit.py，这时 fix.sh 就变成下面的样子了。 123456789101112131415sudo apt-get install --reinstall libodbc1:amd64sudo apt-get install --reinstall dh-autoreconfsudo apt-get install --reinstall erlang-webtoolsudo apt-get install --reinstall libhtml-template-perlsudo apt-get install --reinstall erlang-base.......sudo apt-get install --reinstall qemu-system-miscsudo apt-get install --reinstall libvirt-dev:amd64sudo apt-get install --reinstall autopointsudo apt-get install --reinstall libconfig-general-perlsudo apt-get install --reinstall ubuntu-cloud-keyringsudo apt-get install --reinstall tgtsudo apt-get install --reinstall libfdt1:amd64 最后执行 ./fix.sh。 然后就是等待执行结束了。 效果如下，一行一行 dpkg: warning: 在减少。","tags":[{"name":"linux","slug":"linux","permalink":"http://fitzeng.org/tags/linux/"},{"name":"dpkg","slug":"dpkg","permalink":"http://fitzeng.org/tags/dpkg/"}]},{"title":"一个小白使用 devstack 部署 openstack 的心路历程","date":"2017-11-04T03:27:00.000Z","path":"2017/11/04/deployOpenstackByDevstack/","text":"0.前言 作为一个想要入门云计算的人来说，大多数人的第一步就是学习 openstack，而学习 openstack 的人面临的第一步就是第一个‘难题’，使用自动化部署工具 devstack 部署 openstack 环境。第一次接触这个东西，花了两天多时间在 Ubuntu Server 和 Ubuntu Desktop 的 16.04 版本上成功部署。有很多人说 Desktop 版有很多坑，亲测问题确实比 Server 版多，但都是可解决的。其中最对初学者不友好的就是网络问题，下面会介绍为什么。所以如果你自己买了国外的 VPS 那就好办了，因为有个骚操作要用到，如果你网速好可能你遇不到这些问题就可以忽略。 下面会分两个部分介绍，都会将 Server 和 Desktop 上的部署过程描述一遍。教程推荐 官方的 Doc和避坑指南教程这个东西对于初学者不宜太多，容易乱，只要有一个正确的执行框架就好。碰到其他 bug 直接 Google 就好。 然后介绍下我的环境吧 Mac 10.12.6 VirtualBox 5.1.28 Ubuntu Server 16.04 4G+20G (临时测试 devstack，听说坑少) Ubuntu Desktop 16.04 4G+80G (平时使用) VPS(最好有) (由于是乞丐版，不适合直接部署和平时学习) 1.Ubuntu Server 版安装 Ubuntu Server首先肯定是要在 Virtual Box 安装 Ubuntu Server 了，这一步略过。相信你已经是接触过一段时间虚拟机的人了，但是一点注意，竟可能分多一点内存和硬盘。由于我不打算日后再这 Server 版使用，所以我的配置是 4G + 20G SSH 登录虚拟机当你创建完成之后面临的一个问题就是那个界面太丑了。。。所以如果可以在宿主机上操作就好了，SSH 正好满足你。至于 SSH 不通使用不了的自己查查资料吧，这里我主要介绍网卡配置，我使用了两个网卡：第一个：做端口映射，将主机的 2222 映射到虚拟机的 22，这条是为了以后使用 SSH。第二个：配完之后再在全局配置中设置你所选中的网卡启用 DHCP。对于网卡各种连接模式不熟的可以查查资料了解一下。 然后连接就是直接在主机下使用 1ssh -p 2222 fitzeng@127.0.0.1 fitzeng 改成你的用户名。如果你出现各种问题连不上可以注意一下两点：1.防火墙2.把 ~/.ssh 文件夹下的 known_hosts 文件删了再重连 开始部署 这里的主教程以官方提供的为准，并且那些注意点我会更新。 部署的脚本要求是拥有 root 权限的非 root 用户。 12345678sudo useradd -s /bin/bash -d /opt/stack -m stackecho &quot;stack ALL=(ALL) NOPASSWD: ALL&quot; | sudo tee /etc/sudoers.d/stacksudo su - stackcd /opt/stackgit clone https://git.openstack.org/openstack-dev/devstackcd devstack 如果上面 clone 太慢或者 clone 不下来的话可以试试 github 的源。 1git clone https://github.com/openstack-dev/devstack.git 然后就是添加配置了，如果不懂推荐直接使用官方页面介绍的。或者使用以下命令 12cp samples/local.conf ./vim local.conf 如果你幸运，讲道理最后执行 ./stack.sh 直接一路到底。。。但是还有很多坑正在等待着我们。但但是有一个很好的是他的 Log 和报错十分清新，很快可以定位问题所在，有时候直接搜 Log 都会出现解决方法。如果脚本直接退出提示没有 HOST_IP。那么直接在 local.conf 后面添加 12HOST_IP=x.x.x.xGIT_BASE=https://github.com HOST_IP具体是什么在你的虚拟机上 ifconfig 查看。然后推荐把 git 源换成 github 的。这里你可以检测一下你的源有没有问题 apt-get update 有的话直接把有问题的源在 /etc/apt/sources.list.d/ 目录下移除，移除前建议备份一下。然后推荐 apt-get upgrade 一下，Python 版本保持默认的 2.7.X 就好，如果出现什么和 Python 3.4 不匹配的 Log 直接忽略。如果你换成 3.4 很多库会出问题。如果你是 Python 3.X，可以把 /user/bin/ 下的 Python2.X 链接到该目录下的 Python 文件。这时执行 python -V 就能看到结果了。 但但但是，上面只是解决了有形的 Bug，还有就是无形的 Bug，你将面临网络问题，如果你想顺畅点可以直接更换源。修改 pip 源 1234567mkdir ~/.pipvim ~/.pip/pip.conf填入：[global]trusted-host=mirrors.aliyun.comindex-url=http://mirrors.aliyun.com/pypi/simple 修改 sources.list： 12345678910111213141516171819202122sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo vim /etc/apt/sources.list填入：# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 都改成 aliyun 的。到这时候如果你的网络没什么问题，可能会出点环境小问题，dkpg 和各种包等之类的问题，一搜网上基本都有解决方案。 但但但是，如果你的网速下载某些包不超 10Kb/s 那就要用骚操作了。。。因为会一直卡着，网一断又得重新开始，先 unstack，clean 再 stack，十分不友好。出现问题大多是在下载某个 git 仓库和某些包的时候。尤其是 nova horizon 之类的，大小到了 300+M。 这里介绍一个方法：思路是先 SSH 上你的国外 VPS，下载你的 git 仓库或其他文件。然后再 SCP 到你的虚拟机上。主要是这样不会中断，而且无形中就可以是多线程操作，开几个终端 SCP 好几个文件。看看速度对比效果吧，虚拟机上下载：VPS 上下载：之后自己 SCP 就好了 1sudo scp -P 10800 -r root@xx.xx.xx.xx:/fitzeng/horizon /etc/stack/ -r 是 cp 文件夹，然后端口，IP 填你自己的后面跟目录。这里可能也有点慢，但是比之前的好而且稳定。 这一切操作都源于友好的 log 机制，看上面的图片我们可以知道下载地址和存放目录，所以，知道这些手段就多了起来。网速够快也可以直接在本地 clone。 有了这些操作基本就意味着你解决了网络问题，借助 google 基本可以解决其他库和环境的问题。成功图上传一波： 2.Ubuntu Desktop 版基本步骤是和前面一致的，出的问题可能就是你之前在 Ubuntu 上装过各种软件(我装的 Sogou 输入法，里面的 fcitx 源影响了速度，甚至有时候直接卡这不动)，更改了软件源或者做过其它的工具更改，按照前面的配置亲测可行。如果你之前在 Ubuntu Server 版上装过，直接把文件 SCP 过来，如果虚拟机之间不能通讯，可以先 SCP 到宿主机，再从宿主机通过文件共享的方式共享到 Ubuntu Desktop。然后运行就可以了，有了前面的基础就很简单了。 那就看直接看结果吧： 3.后记说实话，这不太算技术文章，纯属个人记录。本来不太想写，但是感觉国内环境对开发者有点不友好，如果这篇文章能对初学者有部分帮助我就满意了，能够使初学者继续学习下去。然后这是部署完之后写的，部署的过程远不如写的这么轻松，但是我现在有信心去解决部署过程中碰到的问题，这才是重点。希望你也是。每个人的环境都不一样，出现的问题也不可能一样，所以如果你照上面做了还没有解决可以留言大家一起讨论。 最后：多谢阅读祝大家一遍过 ^_^","tags":[{"name":"devstack","slug":"devstack","permalink":"http://fitzeng.org/tags/devstack/"},{"name":"openstack","slug":"openstack","permalink":"http://fitzeng.org/tags/openstack/"}]},{"title":"Restart","date":"2017-09-22T03:27:00.000Z","path":"2017/09/22/restart/","text":"0. 前言 我的求职生活是从今年的 04-16 找实习开始到 09-22 拿到优招(秋招) Offer结束，中间共经历过了三家公司面试，面试经验不足，而且最近的面试已距现在两个多月了，细节记不清了，所以这不太算是面经，只是我个人对我自己找工作这小半年的总结以及我对找工作这件事的认识。首先说明我不是大神，只能从平静叙述整个找工作的过程，希望你能从中体会到一点什么就很满意了，在此先祝大家找工作顺利！ 1. 面试过程 自己要介绍自己在三家公司的面试过程，不涉及面试题目什么的，纯属叙述整个心理过程。不过后面我会补充一些资料和我参考的一些其他面试者的面经。 下面我根据邮件理一下时间线： 第一家公司（腾讯）实习-跪一面：04-16大概记忆就是啥都问，读过我以前文章的都知道，我以前是写 Android 的，但是他问了 Linux，C/C++，操作系统，JVM，设计模式，算法，Andriod，还有一些小智力测试题。目前我只能记清这些知识点，这个过程是一开始问了十多分钟项目，再问问 Android 基础(答得很烂)，再问 JVM(也很烂😭)，接着就给我一张纸上面两道题手写代码，面试官就喝水去了，然后我没意识到有两面题，只做了第一面的两道告诉面试官我做好了，他过来了，我跟他讲解代码（因为字迹实在难看清😂），在他的引导下慢慢把第二题进行优化。接着就是问问计算机基础的一些知识。面了有将近一个小时，这是我第一次面试，流了一身的汗。我对面试结果是很不乐观的，因为我是在 04-1X 才知道这是已经接近实习招聘尾声。基本上大多数公司的内推什么的都弄完了，而我也是后知后觉，04-14 晚上做简历，因为听说腾讯 04-15 截止投递实习简历，到 04-15 早上，我做完简历就投了。可能是里面有一些学长学姐吧，当天下午就收到内推通知并告知完善简历，接着晚上就收到通知明天去面试。整个感觉很惊喜，但是其实后来跪了之后想想其实是自己没有做好准备，根本不知道准备实习人家从三月份就开始找了，所以有信息来源很重要。本来以为一面要挂的结果第二天晚上就通知过了并且过一天第二面。 二面：04-18这一面很崩，后来才知道可能是压力面。说实话，第一面能过之后我已经放松了很多。二面内容和 Android 一毛钱关系都没有。同样一开始聊聊项目，然后桌子上有一堆大概十厘米厚的 A4 纸，拿一张，口述一道题然后写代码，这里提醒下大家如果遇到这种情况，最好在动笔前问清楚问题条件，比如我一动笔写了一点然后问他字符串是以什么形式存储的，然后他回答了 char *，接着给我感觉有点不太舒服，气氛很严肃，但是我又问了一个问题：是写伪代码还是？结果崩了，他立马说，都这时候了还写什么伪代码！好，我默默的划掉，又写了一段代码，由于混在一起，我就把代码又抄了一遍，但是有些语句一开始抄漏所以出现了两句代码在一行的情况。。。他看了边叹气边说：“这些的什么，乱七八糟的，缩进XXXXXXXXX”，然后我弱弱地说要不我再抄一遍把格式调调？结果他说还调什么调，浪费我时间！😂😂😂😂😂😂把我吓坏了，然后弱弱的给他讲解了代码，由于代码写的还不错，这里他没揪我的小辫子。然后他又说给你来一道博弈题？？？我黑人问号，我面的是 Android 吗？口述完题目后，他看到了我有点高兴，问我是不是看过类似的题目？我诚实的回答是。结果他说给你出道简单一点的题？？？？？念完题目之后我一脸懵逼，结果最后我对题目的看法和面试官不符，然后挂了。总结就是：抱歉，我不会演戏。。。当时想如果我稍微冷静一点，把博弈题拿下应该这面能过吧，但是没有如果。。。 第二家公司（华为）1. 实习-跪技术面：05-13由于面试官不是做 Android，给我感觉连 Java 相关都不是，所以全程在聊天，什么你家在哪里？为什么不读研？你能接受加班吗？之类的。。。。大概二十多分钟，结束得很轻松。 综合面：05-13由于技术面没问技术，所以这面大概就是和前面问的问题差多，时间也是差不多，感觉很水。。。 补充：前面都是同一天面完，感觉很诡异，不太像面试。。。回到学校后，过几天面试状态就是录用排序中。算是面试过了，然后一两周过后有同班的同学收到实习 offer，而我没消息。直到听说实习 offer 都发完了我才知道我挂了。所以说华为的面试通过和 offer 还有一段资源池的距离。后来一个学长 hr 来到学校找同学谈话，这时我被告知技术面给了个 B+。。。这个对我后面影响挺大的，然后综合面是 OK 的。所以面试时算过，本来也可以给 offer 但是没有岗位，只招一个 Android 实习的 🙂。但是这时候我还可以用这个安慰自己，不是你差，是市场需求，这是没办法的事。后续的是就是学长跟我谈了谈人生规划啊，然后推荐我参加优招。后面就是优招的故事了； 第三家公司（阿里）实习-跪一面：05-20阿里是在线面试，给我的感觉是面过最难的，问得我无从回答，因为我基本没有项目经验，什么说说你在开发中碰到印象最深刻的问题是什么？遇到网上怎么也查不到答案的问题怎么办？还有你对 RN（当时只知道有个 RN 开发，并不清楚是什么） 开发怎么看？反正我答不上来，所以直接毙了。后面他问我有什么问题问他，我问他他对我面试感觉怎么样？他说我基础不行，然后我又问了要怎么学习？他说 Java 要学好，反射注解什么的。总之就是基础要扎实。。。 第二家公司（华为）2. 优招-过补技术面：07-14由于前面的实习面试给了个 B+，所以这次要补一个技术面。面试官也不是做 Android 的，不过是和 Java 相关的，所以基本就是问我 Java 了。也是开始聊聊项目和生活，然后问问 Java 内存泄漏，GC，接着考考算法，一道迷宫的题目，说下用深度优先和广度优先遍历的实现思想，进而问如果要找出一条最少步骤的路走出迷宫怎么办？基本都答上来了，最后他说我问你一个 Java 问题，我以为会很难。结果他说被 final 关键字修饰的类会怎么样？我迟疑了一下，说了答案。。。然后面试就结束了。给我的感觉应该是能过的。 BOSS 面：07-14等了好久，最后排队排不上上午的了，然后发了餐券去吃了个饭回来面试。面试过程和实习面试时差不多，但是那个面试官的级别感觉挺高的，白头发特别多，估计 50+ 吧，最后加了个群，面试结束了。感觉没什么感觉，当时面试的研究生特别多，所以我感觉可能要 GG。 等了两个多月后，等到 09-21 发来的签约短信，09-22 以白菜价签了三方。是自己满意的城市加上整个暑假都在学校，09 月份投了十多家公司和做了 7-8份笔试题，心太累实在是不想等了。。。签的过程中有个更改城市的小插曲，hr 很好，忙到晚上 7 点多才结束，在这表示感谢。还有一个小插曲是当天有一个腾讯的面试，这是我的收到的第一个秋招面试，由于签了华为的三方，所以也没有去面了，准确说，其实我没有秋招，除了投了十几分简历和做了几次笔试。 2. 面试准备 这里主要叙述我的暑假和九月上旬这个面试准备过程和自己对面是准备的看法。 说实话，没有实习 offer 对我算是有点打击的。所以我就打算暑假不回家好好复习基础知识，我觉得对于一个本科生来说，基础扎实才是你的优势，对于这里可能每个人看法不一，对于每个方向可能有差距吧，这里我只是平静地表达我的观点。 所以我基本放下 Android 了，只是挑热点面试问题过过。说下我做过的努力： 1.重拾数据结构2.重拾操作系统3.重读 JVM4.Android Blog Collection5.Handler 机制再了解 以上是以 Blog 形式进行了总结的，还有部分书籍没有总结的。 里面的看了有 30% 吧，都是采取不重要的粗读重要的精读模式。电子版下载 链接 : http://pan.baidu.com/s/1o7LcZCe 密码 : 0p0c 。希望大家有条件去支持纸质书吧，我对知识创造者还是很尊重的，因为自己发现写 Blog 每个礼拜一篇都写不来，但是对于部分学习计算机的人来说，书确实有点多，也要花很多钱，所以取舍之下就是有条件的现在支持原作者，没条件的以后有条件了再支持。好像偏题了。。。 期间看过 Android 开发艺术探索，Android 群英传，Android 进阶之光。之前还看过 编程之美，编程珠玑，编程之法，都没有自己敲代码实现，所以处于有思路但不能写代码实现的状态。然后就是一些专业课课本了。对于读书这件事我觉得没有必要为一个知识点死磕，我一般就是往后翻，基本两天跳着‘看’完一本书。时间固定的情况下宁愿跳着多看几遍，也不追求一遍仔细看完。因为你面临的结果就是记不住，没有重点的重复刺激下知识网络建立不起来。往往阅读到后面，前面的疑问就会迎刃而解。 然后说说岗位吧，以后我可能就不会再写和 Android 相关的文章了，签的工作是云计算所以打算学学 Python 和 OpenStack 之类的，从新开始接触一个新的领域。所以如果你不是对一个岗位持有非做不可的态度，其实我觉得那就不要太在意那些花哨的东西，注重基础的积累。比如之前面试有问我学过什么框架吗？我说没学过，然后这个话题就跳过了。当然学过加分，没学过我觉得不减分吧，毕竟应届生。但是一个 Java 基础的语言特性答不上来那就有点说不过去了。而且框架的精髓在读源码之后转化为自己的理解从而应用在自己代码中，而不是会使用框架，这种价值不大。如果你是大神，基础扎实，那这些就是你的进阶，你的加分项，本质不一样。就像试卷的必答题答完了肯定是去答选做题，但是有些人连必答题都没做完就跟着别人翻卷子是不是有点。。。总之就是注重语言本身，而不是语言衍生品。 接着说说面经，这是很好的东西，但是也是很不好的东西，看你的认知。有人对面经的态度是题库，觉得看完记着我面试就能过了，同一个问题，不同的人说相同的答案面试官也能知道哪个厉害哪个水。大家可以试试对一个自己不理解的技术问题尝试解释会怎样？你一迟疑，面试官就会反问你，最后只有一个字崩！而且那些面经提供的答案往往是符合作者的思考思路，不一定对你适用。所以我对面经的态度是类似于考纲，至于考纲和题库的区别留给读者思考吧。 然后我面试准备过程中参考的好的‘考纲’ [干货，阅后进BAT不是梦] 面试心得与总结—BAT、网易、蘑菇街 自己动手丰衣足食，前面一篇是我认为的好面经，可以作为查找参考。 3. 最后如果你觉得对你有帮助就点下赞吧，让更多的人看到，希望能帮到更多的人。这是我第一篇求赞的文章，因为确实想和大家分享我的想法。谢谢。 再如果你有相同或者不同的意见，欢迎评论区留言大家互相讨论呀~ 然后国际惯例：GitHub &amp;&amp; Blog 欢迎来观光 ^_^ 多谢阅读！","tags":[{"name":"Life","slug":"Life","permalink":"http://fitzeng.org/tags/Life/"},{"name":"Job","slug":"Job","permalink":"http://fitzeng.org/tags/Job/"}]},{"title":"重识 Android","date":"2017-09-19T03:27:00.000Z","path":"2017/09/19/reAndroid/","text":"Android 基础知识整理。 1. Activity1.1 Activity 生命周期状态：running paused stopped killed 启动：onCreate() -&gt; onStart() -&gt; onResume() 点击 Home ：-&gt; onPause() -&gt; onStop() 重现：-&gt; onRestart() -&gt; onStart() -&gt; onResume() 退出：-&gt; onPause() -&gt; onStop() -&gt; onDestory() 进程优先级：前台(可交互) 可见(失去焦点) 服务 后台(不可见) 空(缓存用) 1.2 Activity 任务栈standard：标准模式(每次都创建) singleTop：栈顶复用模式(栈顶检测) singleTask：栈内复用模式(栈内检测) singleInstance：单实例模式(独立的任务栈) 1.3 Activity 启动模式1.4 Scheme 跳转协议1.5 参考2. Fragment2.1 生命周期Create: 准备视图 onAttach: Fragment 与 Activity 关联 onCreate: 创建 Fragment 对象 onCreateView: 创建视图 onActivityCreated: Activity 对象创建完成 Start: 加载视图 onStart: Fragment 可见 Resume: 获取焦点 onResume: Fragment 可交互 Pause 失去焦点 onPause: Fragment 失去焦点 Stop 视图不可见 onStop: Fragment 不可见 Destory 销毁对象 onDestoryView: Fragment 视图销毁 onDestory: 对象销毁 onDetach: 解绑 Fragment 并销毁对象 以上为个人理解，不是完整的视图加载过程，只是属于一个理解分析的过程。 2.2 Fragment 添加到 Activity 中静态加载：XML 动态加载： FragmentManager FragmentPagerAdapter(detach) 适用于页面较少的情况，不销毁 Fragment 只与 Activity 脱离。 FragmentStatePagerAdapter(remove) 适用于页面较多的情况，直接移除 Fragment。 2.3 Fragment 通信 Fragment 中调用 Activity : 调用 getActivity() Activity 中调用 Fragment : Fragment 回调函数 Fragment 中调用 Fragment : findFragmentById() 2.4 典型方法replace: 替换 Fragment 实例 add: 添加 Fragment 实例 remove: 移除 Fragment 实例 2.5参考 Android_Tutor : 两分钟彻底让你明白Android Activity生命周期(图文)! 3. Service3.1 Service 和 ThreadService: 依托于所在的线程并且在后台运行，不可做耗时操作，否则会 ANR。Thread: 主要是出处理耗时操作。 4. BroadCast Receiver","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"Handler 机制再了解","date":"2017-09-11T03:27:00.000Z","path":"2017/09/11/handler/","text":"这里主要是先了解整个消息传递的过程，知道这样做的好处和必要性。而不是直接介绍里面的几个关键类，然后介绍这个机制，这样容易头晕。而且网络上已经有很多这样的文章了，那些作者所站的高度对于我这种初学者来说有点高，我理解起来是比较稀里糊涂的，所以这里从一个问题出发，一步一步跟踪代码，这里只是搞清楚 handler 是怎么跨线程收发消息的，具体实现细节还是参考网上的那些大神的 Blog 比较权威。PS. 本来是想分章节书写，谁知道这一套军体拳打下来收不住了，所以下面基本是以一种很流畅的过程解释而不是很跳跃，细心看应该会对理解 Handler 机制有所收获。 Q1: 假如有一个耗时的数据处理，而且数据处理的结果是对 UI 更新影响的，而 Android 中 UI 更新不是线程安全的，所以规定只能在主线程中更新。 下面我们有两种选择： 12345678910111213141516171819202122232425262728293031323334353637主线程版本：public class MainActivity extends AppCompatActivity &#123; private static final String TAG = \"MainActivity\"; private Button btnTest; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_test); init(); &#125; private void init() &#123; btnTest = (Button) findViewById(R.id.btn_test); btnTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 假装数据处理 int i = 0; for (i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 假装更新 UI Log.d(TAG, \"Handle it！\" + i); &#125; &#125;); &#125;&#125; 直接在主线程中处理数据，接着直接根据处理结果更新 UI。我想弊端大家都看到了，小则 UI 卡顿，大则造成 ANR。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748子线程版本：public class MainActivity extends AppCompatActivity &#123; private static final String TAG = \"MainActivity\"; private Button btnTest; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_test); init(); &#125; private void init() &#123; btnTest = (Button) findViewById(R.id.btn_test); btnTest.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 假装数据处理 int i; for (i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 返回处理结果 handler.sendEmptyMessage(i); &#125; &#125;).start(); &#125; &#125;); &#125; Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // 假装更新 UI Log.d(TAG, \"Handle MSG = \" + msg.what); &#125; &#125;;&#125; 这是一种典型的处理方式，开一个子线程处理数据，通过 Android 中提供的 Handler 机制进行跨线程通讯，把处理结果返回给主线程，进而更新 UI。这里我们就是探讨 Handler 是如何把数据发送过去的。 到这里，我们了解到的就是一个 Handler 的黑盒机制，子线程发送，主线程接收。接下来，我们不介绍什么 ThreadLocal、Looper 和 MessageQueue。而是直接从上面的代码引出它们的存在，从原理了解它们存在的必要性，然后在谈它们内部存在的细节。 一切罪恶源于 handler.sendEmptyMessage();，最终找到以下函数 sendMessageAtTime(Message msg, long uptimeMillis)： 123456789101112131415161718192021222324252627282930Handler.class/** * Enqueue a message into the message queue after all pending messages * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;. * &lt;b&gt;The time-base is &#123;@link android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt; * Time spent in deep sleep will add an additional delay to execution. * You will receive it in &#123;@link #handleMessage&#125;, in the thread attached * to this handler. * * @param uptimeMillis The absolute time at which the message should be * delivered, using the * &#123;@link android.os.SystemClock#uptimeMillis&#125; time-base. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. Note that a * result of true does not mean the message will be processed -- if * the looper is quit before the delivery time of the message * occurs then the message will be dropped. */public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; MessageQueue 出来了，我们避免不了了。里面主要是 Message next() 和 enqueueMessage(Message msg, long when) 方法值得研究，但是现在还不是时候。 从 MessageQueue queue = mQueue; 中可以看出我们的 handler 对象里面包含一个 mQueue 对象。至于里面存的什么怎么初始化的现在也不用太关心。大概有个概念就是这是个消息队列，存的是消息就行，具体实现细节后面会慢慢水落石出。后面的代码就是说如果 queue 为空则打印 log 返回 false；否则执行 enqueueMessage(queue, msg, uptimeMillis); 入队。那就好理解了，handler 发送信息其实是直接把信息封装进一个消息队列。 12345678Handler.classprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 这里涉及 Message，先说下这个类的三个成员变量： 12345/*package*/ Handler target; /*package*/ Runnable callback; /*package*/ Message next; 所以 msg.target = this; 把当前 handler 传给了 msg。 中间的 if 代码先忽略，先走主线：执行了 MessageQueue 的 enqueueMessage(msg, uptimeMillis);方法。接着看源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354MessageQueue.classboolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 代码有点长，不影响主线的小细节就不介绍了，那些也很容易看懂的，但是原理还是值得分析。if (mQuitting)...，直接看看源码初始化赋值的函数是在 void quit(boolean safe) 函数里面，这里猜测可能是退出消息轮训，消息轮训的退出方式也是值得深究，不过这里不影响主线就不看了。 msg.markInUse(); msg.when = when; 标记消息在用而且继续填充 msg，下面就是看注释了。我们前面介绍的 Message 成员变量 next 就起作用了，把 msg 链在一起了。所以这里的核心就是把 msg 以一种链表形式插进去。似乎这一波分析结束了，在这里划张图总结下：推荐自己根据所观察到的变量赋值进行绘制图画，这样印象更加深刻。 OK，消息是存进去了，而且也是在 handler 所在的线程中。那么到底怎么取出信息呢？也就是前面小例子 1234567Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // 假装更新 UI Log.d(TAG, \"Handle MSG = \" + msg.what); &#125;&#125;; handleMessage() 什么时候调用？这里基本断了线索。但是如果你之前哪怕看过类似的一篇文章应该都知道其实在 Android 启动时 main 函数就做了一些操作。这些操作是必要的，这也就是为什么我们不能直接在子线程中 new Handler();。 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); // -------1 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); // -------2 &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); // -------3 throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 可以看出这里在获取 sMainThreadHandler 之前进行了 Looper.prepareMainLooper(); 操作，之后进行了 Looper.loop(); 操作。 下面开始分析： 1234567891011121314151617181920212223242526272829303132333435363738394041Loopr.class /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;/** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125;/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 前两个方法是在自己创建 Looper 的时候用，第三个是主线程自己用的。由于这里消息传递以主线程为线索。prepare(false);说明了这是主线程，在 sThreadLocal.set(new Looper(quitAllowed)); 中的 quitAllowed 为 false 则说明主线程的 MessageQueue 轮训不能 quit。这句代码里还有 ThreadLocal 的 set() 方法。先不深究实现，容易晕，这里需要知道的就是把一个 Looper 对象“放进”了 ThreadLocal，换句话说，通过 ThreadLocal 可以获取不同的 Looper。最后的 sThreadLocal.get(); 展示了 get 方法。说明到这时 Looper 已经存在啦。现在看看 Looper 类的成员变量吧！ 123456Looper.classstatic final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.classfinal MessageQueue mQueue;final Thread mThread; 在这里先介绍一下 ThreadLocal 的上帝视角吧。直接源码，可以猜测这是通过一个 ThreadLocalMap 的内部类对线程进行一种 map。传进来的泛型 T 正是我们的 looper。所以 ThreadLocal 可以根据当前线程查找该线程的 Looper，具体怎么查找推荐看源码，这里就不介绍了。1234567891011121314151617181920212223242526272829303132333435/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 分析到这里，handler 和 looper 都有了，但是消息还是没有取出来？这是看第三句 Looper.loop();。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Looper.class/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 一开始也是获取 Looper，但是那么多 Looper 怎么知道这是哪个 Looper 呢？这先放着待会马上解释。把 loop() 函数主要功能搞懂再说。接下来就是获取 Looper 中的 MessageQueue了，等等，这里提出一个疑问，前面说了 Handler 中也存在 MessageQueue，那这之间存在什么关系吗？（最后你会发现其实是同一个）先往下看，一个死循环，也就是轮训消息喽，中间有一句 msg.target.dispatchMessage(msg); 而前面介绍 msg.target 是 handler 型参数。所以和 handler 联系上了。 12345678910111213141516Handler.class/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 逻辑很简单，总之就是调动了我们重写的 handleMessage() 方法。 Step 1：Looper.prepare(); 在 Looper 中有一个静态变量 sThreadLocal，把创建的 looper “存在” 里面，创建 looper 的同时创建 MessageQueue，并且和当前线程挂钩。 Step 2：new Handler(); 通过上帝 ThreadLocal，并根据当前线程，可获取 looper，进而获取 MessageQueue，Callback之类的。12345678910111213141516171819202122232425262728293031323334353637Handler.class/** * Use the &#123;@link Looper&#125; for the current thread with the specified callback interface * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; // 前面的两个 MessageQueue 联系起来了，疑问已解答。 mCallback = callback; mAsynchronous = async;&#125; 这个函数可以说明在 new Handler() 之前该线程必需有 looper，所以要在这之前调用 Looper.prepare();。 Step 3：Looper.loop(); 进行消息循环。 基本到这里整个过程应该是清楚了，这里我画下我的理解。 那么我们现在来看一下 handler 是怎么准确发送信息和处理信息的。注意在 handler 发送信息之前，1、2、3 步已经完成。所以该获取的线程已经获取，直接往该线程所在的 MessageQueue 里面塞信息就行了，反正该信息会在该 handler 所在线程的 looper 中循环，最终会通过消息的 target 参数调用 dispatchMessage()，而在 dispatchMessage() 中会调用我们重写的 handleMessage() 函数。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"一个程序员使用 PPT 的小技巧","date":"2017-09-06T03:27:00.000Z","path":"2017/09/06/pptAndDev/","text":"前言前段时间，我写了一篇《重读 JVM》，在文章下有人评论里面的图是怎么做的，下面是我给的回复：然后想到自己在阅读其他大神些的 Blog 时，下面也有一批人在问作图工具什么的。然后我就想把自己的小技巧分享出来，如有雷同，纯属巧合。 WHY IS PPT作为一个有点轻微洁癖的程序员，装的软件相同功能的基本不会超过两个。所以不想为写 Blog 画图而再装一个软件，再说并不是每篇 Blog 都要画图，但是要画图的 Blog 一画就是十几张，整理起来很不方便。所以我想到了 PPT，分页存储。其实在这之前我用 PPT 的很大一原因是写简历，之前简历是用 Word 做的，苦不堪言，而且版本保存很恶心。。。文件乱的很，所以想到用 PPT，没想到特别好用。下面开始介绍一下我的实操。 实操简历篇 第一步：创建 A4 大小的幻灯片 第二步：设计简历 这里就是利用插入形状自己设计了，基本够日常使用，我也不是什么 PPT 高手，如果你会使用动画那效果估计更加惊人。 第三步：版本控制 利用注释！ 第四步：导出 PDF 直接另存为PDF 就可以了，很简单就不截图了。 管理图片篇基本有了绘制简历的基础，那么这个不在话下，剩下的就是自己的绘制水平高低了。 解释一下如何导出图片：直接 全选 -&gt; 右键 -&gt; 另存为图片… 注意这里的 PNG 如果没有背景图示透明的，所以绘制图片前可以自己加一层背景画布。 最后这篇文章有点水，不过如果对大家能有帮助就知足了。 如果你看到这 &amp;&amp; 如果你是一个程序员，那么按照国际惯例，推荐一下自己的 GitHub &amp;&amp; Blog 里面还是有一些干货值得大家发现的。 多谢阅读 ^_^","tags":[{"name":"Tips","slug":"Tips","permalink":"http://fitzeng.org/tags/Tips/"},{"name":"ppt","slug":"ppt","permalink":"http://fitzeng.org/tags/ppt/"}]},{"title":"重读 JVM","date":"2017-09-01T16:00:00.000Z","path":"2017/09/02/reJVM/","text":"秋招开始了，前面由于做别的事耽误了半个月，以前学的东西不用就很容易忘记。所以，这次重新阅读《深入理解 JVM 虚拟机》时，想做一个记录。将碎片的知识整合，方便自己以后阅读，同时也和大家一起分享。内容中会添加我自己的理解，其中如果有错误，欢迎大家指正。 相关阅读:1. 重拾数据结构2. 重拾操作系统3. 重拾计算机网络(未完成)）注意：以上内容会持续更新，欢迎大家关注 GitHub &amp;&amp; Blog 1. Java 内存区域与内存溢出异常1.1 运行时数据区域 根据《Java 虚拟机规范(Java SE 7 版)》规定，Java 虚拟机所管理的内存如下图所示。 1.1.1 程序计数器 内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成 如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。 1.1.2 Java 虚拟机栈 线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址) StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。 1.1.3 本地方法栈 区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。 1.1.4 Java 堆 对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。 OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。 1.1.5 方法区 属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 现在用一张图来介绍每个区域存储的内容。 1.1.6 运行时常量池 属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。 1.1.7 直接内存 非虚拟机运行时数据区的部分 在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。 1.2 HotSpot 虚拟机对象探秘 主要介绍数据是如何创建、如何布局以及如何访问的。 1.2.1 对象的创建 创建过程比较复杂，建议看书了解，这里提供个人的总结。 遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。 1.2.2 对象的内存布局 在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding) 对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。实例数据(Instance Data)：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。 1.2.3 对象的访问定位 使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。 通过句柄访问 Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。 使用直接指针访问 reference 中直接存储对象地址 比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。 1.3 实战 // 待填 2. 垃圾回收器与内存分配策略2.1 概述 程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。 2.2 对象已死吗？ 在进行内存回收之前要做的事情就是判断那些对象是‘死’的，哪些是‘活’的。 2.2.1 引用计数法 给对象添加一个引用计数器。但是难以解决循环引用问题。 从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。 2.2.2 可达性分析法 通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。 可作为 GC Roots 的对象： 虚拟机栈(栈帧中的本地变量表)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象 2.2.3 再谈引用 前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充，下面具体介绍。 下面四种引用强度一次逐渐减弱 强引用 类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。 软引用 SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。 弱引用 WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。 虚引用 PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 2.2.4 生存还是死亡 即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。finalize() 方法只会被系统自动调用一次。 2.2.5 回收方法区 在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。永久代垃圾回收主要两部分内容：废弃的常量和无用的类。 判断废弃常量：一般是判断没有该常量的引用。判断无用的类：要以下三个条件都满足 该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例 加载该类的 ClassLoader 已经被回收 该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法 2.3 垃圾回收算法 仅提供思路 2.3.1 标记 —— 清除算法 直接标记清除就可。 两个不足： 效率不高 空间会产生大量碎片 2.3.2 复制算法 把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。 解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。 2.3.3 标记-整理算法 不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。 2.3.4 分代回收 根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。 新生代 每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。 老年代 老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 标记 —— 清除 或者 标记 —— 整理 算法回收。 2.4 HotSpot 的算法实现 // 待填 2.5 垃圾回收器 收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。 说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。 2.5.1 Serial 收集器 这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。 2.5.2 ParNew 收集器 可以认为是 Serial 收集器的多线程版本。 并行：Parallel 指多条垃圾收集线程并行工作，此时用户线程处于等待状态 并发：Concurrent 指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。 2.5.3 Parallel Scavenge 收集器 这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。 CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。 2.5.4 Serial Old 收集器 收集器的老年代版本，单线程，使用 标记 —— 整理。 2.5.5 Parallel Old 收集器 Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 标记 —— 整理 2.5.6 CMS 收集器 CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。 运作步骤: 初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象 并发标记(CMS concurrent mark)：进行 GC Roots Tracing 重新标记(CMS remark)：修正并发标记期间的变动部分 并发清除(CMS concurrent sweep) 缺点：对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片 2.5.7 G1 收集器 面向服务端的垃圾回收器。 优点：并行与并发、分代收集、空间整合、可预测停顿。 运作步骤: 初始标记(Initial Marking) 并发标记(Concurrent Marking) 最终标记(Final Marking) 筛选回收(Live Data Counting and Evacuation) 2.6 内存分配与回收策略2.6.1 对象优先在 Eden 分配 对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。 一般来说 Java 堆的内存模型如下图所示： 新生代 GC (Minor GC) 发生在新生代的垃圾回收动作，频繁，速度快。 老年代 GC (Major GC / Full GC) 发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。 2.6.2 大对象直接进入老年代2.6.3 长期存活的对象将进入老年代2.6.4 动态对象年龄判定2.6.5 空间分配担保3. Java 内存模型与线程 3.1 Java 内存模型 屏蔽掉各种硬件和操作系统的内存访问差异。 3.1.1 主内存和工作内存之间的交互 操作 作用对象 解释 lock 主内存 把一个变量标识为一条线程独占的状态 unlock 主内存 把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定 read 主内存 把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用 load 工作内存 把 read 操作从主内存中得到的变量值放入工作内存中 use 工作内存 把工作内存中一个变量的值传递给执行引擎， 每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作 assign 工作内存 把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 store 工作内存 把工作内存中的一个变量的值传送到主内存中，以便 write 操作 write 工作内存 把 store 操作从工作内存中得到的变量的值放入主内存的变量中 3.1.2 对于 volatile 型变量的特殊规则 关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。 一个变量被定义为 volatile 的特性： 保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。 如果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。 禁止指令重排序优化。 通过插入内存屏障保证一致性。 3.1.3 对于 long 和 double 型变量的特殊规则 Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。 3.1.4 原子性、可见性与有序性 回顾下并发下应该注意操作的那些特性是什么，同时加深理解。 原子性(Atomicity) 由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。 可见性(Visibility) 是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。 有序性(Ordering) 如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。 3.1.5 先行发生原则 也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。 天然的先行发生关系 规则 解释 程序次序规则 在一个线程内，代码按照书写的控制流顺序执行 管程锁定规则 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作 volatile 变量规则 volatile 变量的写操作先行发生于后面对这个变量的读操作 线程启动规则 Thread 对象的 start() 方法先行发生于此线程的每一个动作 线程终止规则 线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测) 线程中断规则 对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生 (通过 Thread.interrupted() 方法检测) 对象终结规则 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始 传递性 如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C 3.2 Java 与线程3.2.1 线程的实现使用内核线程实现 直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。 使用用户线程实现 广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。 使用用户线程夹加轻量级进程混合实现 直接看图 Java 线程实现 平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。 3.2.2 Java 线程调度协同式线程调度 线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。 抢占式线程调度 每个线程由系统来分配执行时间。 3.2.3 状态转换五种状态： 新建(new) 创建后尚未启动的线程。 运行(Runable) Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。 无限期等待(Waiting) 出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。 以下方法会然线程进入无限期等待状态：1.没有设置 Timeout 参数的 Object.wait() 方法。2.没有设置 Timeout 参数的 Thread.join() 方法。3.LookSupport.park() 方法。 限期等待(Timed Waiting) 处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。 以下方法会让线程进入限期等待状态：1.Thread.sleep() 方法。2.设置了 Timeout 参数的 Object.wait() 方法。3.设置了 Timeout 参数的 Thread.join() 方法。4.LockSupport.parkNanos() 方法。5.LockSupport.parkUntil() 方法。 阻塞(Blocked) 线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 结束(Terminated) 已终止线程的线程状态。 4. 线程安全与锁优化 // 待填 5. 类文件结构 // 待填 有点懒了。。。先贴几个网址吧。 1. Official：The class File Format2.亦山: 《Java虚拟机原理图解》 1.1、class文件基本组织结构 6. 虚拟机类加载机制 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。 在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。 6.1 类加载时机类的生命周期( 7 个阶段) 其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。 以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)： 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。 使用 java.lang.reflect 包的方法对类进行反射调用的时候。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。 当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。 前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化，佳作被动引用。举几个例子~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class SuperClass &#123; static &#123; System.out.println(\"SuperClass init!\"); &#125; public static int value = 1127;&#125;public class SubClass extends SuperClass &#123; static &#123; System.out.println(\"SubClass init!\"); &#125;&#125;public class ConstClass &#123; static &#123; System.out.println(\"ConstClass init!\"); &#125; public static final String HELLOWORLD = \"hello world!\"&#125;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); /** * output : SuperClass init! * * 通过子类引用父类的静态对象不会导致子类的初始化 * 只有直接定义这个字段的类才会被初始化 */ SuperClass[] sca = new SuperClass[10]; /** * output : * * 通过数组定义来引用类不会触发此类的初始化 * 虚拟机在运行时动态创建了一个数组类 */ System.out.println(ConstClass.HELLOWORLD); /** * output : * * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类， * 因此不会触发定义常量的类的初始化。 * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。 */ &#125;&#125; 6.2 类的加载过程6.2.1 加载 通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。 数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下： 如果数组的组件类型是引用类型，那就递归采用类加载加载。 如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。 数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。 内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。 6.2.2 验证 是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。 文件格式验证 是否以魔数 0xCAFEBABE 开头 主、次版本号是否在当前虚拟机处理范围之内 常量池的常量是否有不被支持常量的类型（检查常量 tag 标志） 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量 CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据 Class 文件中各个部分集文件本身是否有被删除的附加的其他信息 …… 只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。 元数据验证 这个类是否有父类（除 java.lang.Object 之外） 这个类的父类是否继承了不允许被继承的类（final 修饰的类） 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法 类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载） 这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。 字节码验证 保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据） 保证跳转指令不会跳转到方法体以外的字节码指令上 保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的） …… 这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号引用验证 符号引用中通过字符创描述的全限定名是否能找到对应的类 在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问 …… 最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。 6.2.3 准备 这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。 public static int value = 1127;这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。 基本数据类型的零值 数据类型 零值 数据类型 零值 int 0 boolean false long 0L float 0.0f short (short) 0 double 0.0d char ‘\\u0000’ reference null byte (byte) 0 特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。 6.2.4 解析 这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。 直接引用直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 中常量类型。 6.2.5 初始化 前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。 6.3 类加载器 通过一个类的全限定名来获取描述此类的二进制字节流。 6.3.1 双亲委派模型 从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader） 启动类加载器加载 lib 下或被 -Xbootclasspath 路径下的类 扩展类加载器加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类 引用程序类加载器ClassLoader负责，加载用户路径上所指定的类库。 除顶层启动类加载器之外，其他都有自己的父类加载器。工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。 6.3.2 破坏双亲委派模型 keyword：线程上下文加载器(Thread Context ClassLoader) 最后 前面两次粗略的阅读，能理解内容，但是很难记住细节。每每碰到不会的知识点就上网查，所以知识点太碎片脑子里没有体系不仅更不容易记住，而且更加容易混乱。但是通过这种方式记录发现自己清晰了很多，就算以后忘记，知识再次捡起的成本也低了很多。 这次还有一些章节虽然阅读了，但是还未完成记录。等自己理解深刻有空闲了就再次记录下来，这里的内容均出自周志明老师的《深入理解 Java 虚拟机》，有兴趣的可以入手纸质版。 多谢阅读","tags":[{"name":"Java","slug":"Java","permalink":"http://fitzeng.org/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://fitzeng.org/tags/JVM/"}]},{"title":"重拾计算机网络","date":"2017-08-30T16:00:00.000Z","path":"2017/08/31/reCN/","text":"主要是把在重读 《计算机网络》 和 《数据通讯与网络》中觉得有价值的东西记录下来。 1. 计算机网络基础概念 一些互相连接的、自治的计算机的集合。 1.1 网络分类不同作用范围的网络 广域网 WAN (Wide Area Network) 城域网 MAN (Metropolitan Area Network) 局域网 LAN (Local Area Network) 个人区域网 PAN (Personal Area Network) 不同使用者的网络 公用网 (public network) 专用网 (private network) 用来把用户接入到因特网的网络 接入网 AN (Access Network) 1.2 计算机网络的性能指标速率 (bit/s)带宽 信号具有的频带宽度 (xxxHZ) 在计算机网络中，从来表示通讯线路所能传送数据的能力。因此网络中的带宽表示在单位时间内ongoing 网络中的某一点到另一点所能通过的最高数据率。单位是比特每秒(b/s) 吞吐量 单位时间通过某个网络(或信道、接口)的数据量 时延 数据从网络的一端发送到另一端所需的时间 总延时 = 发送时延 + 传播时延 + 处理时延 + 排队时延 发送时延(传输时延) 发送数据帧的时间 发送时延 = 数据帧长度(b) / 信道带宽(b/s) 传播时延 电磁波在信道中传播一定距离花费的时间 传播时延 = 信道长度(m) / 电磁波在信道上的传播速率(m/s) 处理时延 主机或路由器在收到分组时要花费一定时间处理。 排队时延 在路由器中输入队列中排队等待的时间 时延带宽积 以比特为单位的链路长度(可以理解为 体积 = 截面 * 长度) 时延带宽积 = 传播时延 * 带宽 往返时间 RTT (Round-Trip Time) 从发送方发送数据开始到发送方接收到来自接收方的确认总共经历的时间。 利用率信道利用率 某信道有百分之几的时间是被利用的 网络利用率 D0 : 网络空闲时的时延 D : 当前网络的时延 U : 利用率 D = D0 / (1 - U) 1.3 计算机网络的体系结构 每层的具体介绍后面章节给出 2. 物理层","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fitzeng.org/tags/计算机网络/"}]},{"title":"重拾操作系统","date":"2017-08-06T16:00:00.000Z","path":"2017/08/07/reOS/","text":"主要是把在重读 《现代操作系统》 中觉得有价值的东西，以 Tips 的形式记录下来。不可能面面俱到，但是如果有一定的基础应该是会回想起很多知识的。具体解释将会以链接形式补充。 1. 进程与线程1.1 进程 主要是为了支持伪并发能力 运行态 : 实际占用 CPU 资源 就绪态 : 可运行，但是由于没有时间片而被暂停等待 CPU 重新调度 阻塞态 : 外部某种事件导致（资源不足）不可运行 CPU 利用率 = 1 - p ^ n p : IO 等待时间比 n : 进程数 1.2 线程 每一个进程有一个地址空间和一个控制线程，主要是使某个进程内的任务之间不被相互阻塞，实现一种进程内并行操作的假象。创建销毁更加轻量级。 共享一组资源，协同完成任务。每个线程有自己的堆栈区（因为要区分同一进程内的线程，CPU 调度要进行状态的保存） 线程模型用户空间中实现线程内核中实现线程混合实现1.3 进程间通信（IPC）1.竞争条件 两个或者多个进程读写某些共享数据 2.临界区 将共享内存的访问代码称为临界区，确保在每个时刻两个进程不可能同时处于临界区中，这样可以避免竞争条件。核心思想为互斥。 并发程序准确高效要满足一下四个条件 任何两个进程不能同时处于其临界区 不应对 CPU 的速度和数量做任何假设 临界区外运行的程序不得阻塞其他进程 不得使进程无限期等待进入临界区 3.忙等待的互斥 互斥实现方案 屏蔽中断 每个进程进入临界区后立即屏蔽所有中断，这样 CPU 无法进行进程切换，就要离开临界区是打开中断。 锁变量 设置一个共享锁变量，初始值为 0。当一个进程想要进入临界区，必须检测锁的值是否为 0，是则置 1 进入临界区。不是则等待其他进程退出临界区时释放锁直到自己能获取到锁开始进入临界区。 锁变量还是会产生竞争条件 严格轮换法 一直循环等待直到出现允许该进程进入临界区的条件才开始运行，十分消耗 CPU 资源。 避免了竞争条件，但是临界区外运行的程序会发生阻塞 用于忙等待的锁称为自旋锁。 123456789101112131415A:while (TRUE) &#123; while (turn != 0); critical_region(); turn = 1; noncritical_region();&#125;B:while (TRUE) &#123; while (turn != 1); critical_region(); turn = 0; noncritical_region();&#125; Peterson 解法 一种互斥算法 12345678910111213141516171819#define FALSE 0#define TRUE 1#define N 2int turn;int interested[N];void enter_region(int process) &#123; int other; other = 1 - process; interested[process] = TRUE; turn = process; // 如果有另一个程序进入临界区的话则一直空循环 while (turn == process &amp;&amp; interested[other] == TRUE);&#125;void leave_region(int process) &#123; interested[process] = FALSE;&#125; 4.睡眠与唤醒 前面的弊端是忙等待会消耗 CPU 资源。如果在等待进入临界区时可以挂起，等到某个信号到达再唤醒就可以避免这种情况了。 生产者-消费者问题 利用资源缓冲区实现进程间的协调 1234567891011121314151617181920212223242526272829303132#define N 100 int count = 0;void producer(void) &#123; int item; while (TURE) &#123; item = produce_item(); if (count == N) &#123; sleep(); &#125; insert_item(item); count = count + 1; if (count == 1) &#123; wakeup(consumer); &#125; &#125;&#125;void consumer(void) &#123; int item; while (TURE) &#123; if (count == 0) &#123; sleep(); &#125; item = remove_item(); count = count - 1; if (count == N - 1) &#123; wakeup(producer); &#125; consume_item(item); &#125;&#125; 5.信号量 引入一个信号量来累计唤醒次数，可以为 0 或正数 使用 down 和 up 操作代替 sleep 和 wakeup #define N 100 typedef int semaphore semaphore mutex = 1; // 控制对临界区的访问 semaphore empty = N; // 计数缓冲区的空槽数目 semaphore full = 0; // 计数缓冲区的满槽数目 void producer(void) { int item; while (TRUE) { utem = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); } } void consumer(void) { int item; while (TRUE) { down(&amp;full); down(&amp;mutex); item = remove_item(); up(&amp;mutex); up(&amp;empty); consume_item(item); } } mutex : 用于互斥，保证任一时刻只有一个进程读写缓冲区 full &amp;&amp; empty : 实现同步，保证某种时间的顺序发生或者不发生 6.互斥量 仅仅适用于管理共享资源或一小段代码 7.管程8.消息传递9.屏障1.4 调度 当有多个进程处于就绪态时就面临调度的选择。内核管理线程时调度可以认为是线程级别的。进程行为有 计算密集型 和 I/O 密集型。而现在由于 CPU 改进速度加快，进程行为更倾向于后者，所以应该多运行该类进程保持 CPU 的利用率。 调度算法 批处理 先来先服务 最短作业优先 最短剩余时间优先 交互式 轮转调度（每个进程一个时间片，用完就轮转） 优先级调度 多级队列 最短进程优先 （aT0 + (1 - a)T1） 保证优先 彩票调度 公平分享调度 实时 线程调度 和系统支持的线程实现方式有关（理解 : 线程表存在哪的区别） 用户级线程 : 内核并不知道，内核只是选中该进程，至于进程中跑哪个线程由用户态调度决定。内核级线程 : 直接调度某个进程内的线程。以上两种方式在性能上有主要差别 : 前面提及 I/O 操作其实是很耗时的，所以在进程间切换比在线程间切换更加耗时。因为线程轻量，而进程完成切换要完整的山下文切换，修改内存映像。而且同一进程内的线程 I/O 访问 cache 的局部性更高，不同进程间切换的清理缓存，这也会消耗时间。 2. 存储管理 主要思想就是内存抽象 2.1 空闲内存管理使用位图的存储管理使用链表的存储管理2.2 虚拟内存 程序产生的地址为虚拟地址，在没有虚拟内存的操作系统上，直接将地址输送到内存总线上。而有虚拟内存的操作系统上，把虚拟地址输送到 MMU（Memory Management Unit），由 MMU 将虚拟地址映射为为物理地址。 分页虚拟地址空间 : 页面 物理内存地址 : 叶框 4k大小 虚拟地址 = 虚拟页号(高位) + 偏移量(低位) 页表 : 把虚拟地址的页面映射为页框，每个进程都有自己的页表 加速分页方法 : 转换检测缓冲区（TLB）主要是优先在 TLB 中查找页面号。 大内存页表 多级页表 倒排页表 : 每个页框一个表项 + TLB 快表 2.3 页面置换算法 最优页面置换算法不可实现，因为无法确定未来。 1.最近未使用页面置换算法(NRU) 设置访问（读、写）位 R，页面修改位 M。 2.先进先出页面置换算法(FIFO)3.第二次机会页面置换算法 设置一个检测最老页面位 R 4.时钟页面置换算法 链表实现页面选择 5.最近最少使用页面置换算法(LRU) 利用矩阵模拟 : 增加自身权重减少其他权重，行置 1，列置 0。 6.用软件模拟 LRU 老化算法 7.工作集页面置换算法8.工作集时钟页面置换算法 算法 注释 最优算法 不可实现，但可作为基准 NRU(最近未使用)算法 LRU 的很粗糙近似 FIFO(先进先出)算法 可能抛弃重要页面 第二次机会算法 比 FIFO 有大的改善 时钟算法 现实的 LRU(最近最少使用)算法 很优秀，但很难实现 NFU(最不经常使用)算法 LRU 的相对粗略的近似 老化算法 非常近似 LRU 的有效算法 工作集算法 实现起来开销很大 工作集时钟算法 好的有效算法 2.4 内存映射文件 进程发起系统调用，把文件映射到其虚拟地址空间的一部分。一般实现是开始不加载，在程序访问时在按页加载。 // Linux 待填 2.5 实现分页工作 进程创建时 : 操作系统要确定程序和数据在初始时有多大，并为它们创建一个页表，操作系统还要在内存中为页表分配空间并对其进行初始化。 进程运行时 : 页表必须在内存中(反之不需要)，并且在磁盘交换区中分配空间。 调度一个进程执行时 : 为新进程充值 MMU，刷新 TLB，更换页表。 缺页中断发生时 : 操作系统必须通过读硬件寄存器确定是哪个虚拟地址造成了缺页中断通过该信息计算需要哪个页面，定位磁盘位置并找到合适的页框来存放新页面，必要的话要置换老页面，然后把所需页面读入页框。最后，备份程序计数器，是程序计数器指向引起缺页中断的指令，并重新执行该指令。 进程退出时 : 释放页表，页面和页面在硬盘上占的空间。 缺页中断处理 硬件陷入内核，在堆栈中保存程序计数器。大多数机器将当前的指令的各种状态信息保存在特殊的 CPU 寄存器中。 启动一个汇编代码例程保存通用寄存器和其他易失信息，以免被操作系统破坏。这个例程将操作系统做为一个函数来调用。 当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看他在缺页中断时正在做什么。 一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致，如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。 如果选择的页框“脏”了，安排该页面写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。 一旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行用户进程，则选择另一个用户进程运行。 当磁盘中断发生时，表明该页已被装入，页表已经更新可以反映他的位置，页框也被标记为正常状态。 恢复发生缺页中断指令以前的状态，程序计数器重新定向这条指令。 调度引发缺页中断的进程，操作系统返回调用他的汇编语言例程。 该例程恢复寄存器和其他状态信息，放回到用户空间继续执行，就好像缺页中断没有发生过一样。 2.6 分段 段是逻辑实体，大小不固定。 2.7 分段和分页结合 : MULTICS 还有 Intel Pentuium 未介绍 34 位的 MULTICS 虚拟地址 段号 页号 页内偏移 18 6 10 根据段号找到段描述符 检查该段的页表是否存在内存中。如果在，则找到他；如果不再，则产生一个段错误。如果访问违反了段的保护要求就要求发出一个越界错误(陷阱)。 检查所请求虚拟页面的页表项，如果该页面不再内存中则产生一个缺页中断，如果在内存就从页表中取出这个页面在内存中的起始地址。 把偏移量加到页面的起始地址上，得到要访问的字在内存中的地址。 最后进行读或写操作。 3. 文件系统 文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。磁盘的 0 号盘扇区称为主引导记录(Master Boot Record, MBR)，用来引导计算机。在 MBR 的结尾是分区表，该表给出了每个分区的其实和结束地址。表中的一个分区被标记为活动分区。在计算机被引导时，BIOS 读入并执行 MBR。MBR 做的第一件事是确定活动分区，读入它的第一个块，称为引导块，并执行。 整个分区: MBR 分区表 磁盘分区 磁盘分区 磁盘分区… 磁盘分区: 引导块 超级块 空闲空间管理 i 节点 根目录 文件和目录 3.1 文件实现连续分配 把每个文件作为一连串连续数据块存储在磁盘上。 链表分配 一个文件由几个磁盘块组成。 在内存中采用表的链表分配 把每个磁盘块的指针字放在内存的一个表中 i 节点 每个文件赋予一个称为 i 节点(index-node)的数据结构，列出文件属性和文件快的磁盘地址。 4. 输入/输出4.1 I/O 硬件原理I/O 设备块设备 : 以块为单位传输，可寻址字符设备 : 以字符为单位收发字符流，不可寻址 设备控制器内存映射 I/O直接存储器存取DMA 工作原理: CPU 对 DMA 控制器进行编程 DMA 请求磁盘传送数据到内存 磁盘传送数据到内存 磁盘给 DMA 控制器应答 完成中断 5. 死锁5.1 资源 在进程对设备，文件等取得了排他性访问权限的时候，有可能会出现死锁。这类需要排他性使用的对象称为资源。 可抢占资源 可以从拥有它的进程中抢占而不会产生任何副作用。（存储器） 不可抢占资源 指在不引起相关的计算失败的情况下，无法把他从占有它的进程处抢占过来。（ CD 刻录） 资源使用步骤: 请求资源 使用资源 释放资源 5.2 死锁概述 如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。 资源死锁条件发生资源死锁的四个必要条件: 互斥条件 : 每个资源要么已经分配了一个进程，要么就是可用的。 占有和等待条件 : 已经得到了某个资源的进程可以再请求新的资源。 不可抢占条件 : 已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显示地释放。 环路等待条件 : 死锁发生时，系统中一定有两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。 5.3 死锁检测与死锁恢复 死锁检测主要是判断当前空闲资源在某种合理分配下是否能使所有进程都运行完并且最终资源都能够释放。 恢复方法 : 利用抢占式恢复 利用回滚恢复 利用杀死进程恢复 5.4 死锁避免资源轨迹图安全状态和不安全状态单个资源的银行家算法多个资源的银行家算法5.5 死锁预防 死锁避免从本质上来说是不可能的，因为他要获取未来的信息。 破坏互斥条件 如果资源不被一个进程独占死锁不会发生。（假脱机打印机） 破坏占有和等待条件 开始执行前请求所有资源就不会造成等待。另一种是请求资源时先释放自己所持有的资源，再尝试一次请求资源。 破坏不可抢占条件 针对某些资源进行虚拟化，实现可抢占。 破坏环路等待条件 保证每个进程在任何时刻只能占用一个资源如果要请求另外一个资源它必须先释放第一个资源。另一种是将所有资源统一编号，进程可以在任何时刻提出资源请求，但是请求必须按照资源编号顺序(升序)提出。 5.6 其他问题两阶段加锁通讯死锁活锁饥饿","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://fitzeng.org/tags/C-C/"},{"name":"OS","slug":"OS","permalink":"http://fitzeng.org/tags/OS/"}]},{"title":"Why Marvel ?","date":"2017-08-02T16:00:00.000Z","path":"2017/08/03/WhyMarvel/","text":"先给自己挖个坑, 记录一下从 12 - 17 这五年间的点点滴滴.很久之前就很想写写自己心中的 Marvel. 人总得有些爱好是与理想相关的, 不是吗?","tags":[{"name":"Life","slug":"Life","permalink":"http://fitzeng.org/tags/Life/"},{"name":"Marvel","slug":"Marvel","permalink":"http://fitzeng.org/tags/Marvel/"}]},{"title":"重拾数据结构","date":"2017-08-01T16:00:00.000Z","path":"2017/08/02/reDS/","text":"在大三到大四过渡期中, 从四月到七月, 经历过几场面试, 找实习. (如果八月份拿到[真.offer]的话我也想把这段经历记录下来) 结果很悲剧, 觉得方向不是什么障碍, 基础比较重, 所以要重拾数据结构不涉及算法具体实现, 因为是重拾, 所以先前有一定基础, 只要有一点提示便能唤醒无限回忆. 这里主要是记录各种数据结构的结构体, 这是经过重重思维过程得出的精华, 十分有价值. 至于具体实现和讲解日后回会以链接形式提供, 这里只提供一个思维树, 建立一个数据机构的思维体系, 后续更新欢迎关注 GitHub. 1 线性表1.1 动态分配空间12345typedef struct &#123; ElemType * elem; int length; int listsize;&#125; SqList; 1.2 线性链表1234typedef struct LNode &#123; ElemType data; struct LNode * next;&#125; LNode, * LinkList; 1.3 静态链表1234typedef struct &#123; ElemType data; int cur; // 游标指向下一个元素的数组下标&#125; component, SlinkList[MAXSIZE]; 1.4 循环链表 &amp; 双向链表12345typedef struct DuLNode&#123; ElemType data; struct DuLNode * prior; struct DuLNode * next;&#125; DuLNode, * DuLinkList; 2 栈和队列2.1 栈12345typedef struct &#123; SELemType * base; SElemType * top;##### int stacksize;&#125; SqStack; 应用: 主要是利用先进后出的特性 数制转换 括号匹配检测 行编辑程序 迷宫非递归求解 表达式求值 Hanoi塔问题 2.2 队列 链队列 12345678typedef struct QNode &#123; QElemType data; struct QNode * next;&#125; QNode, * QueuePtr;typedef struct &#123; QueuePtr front; QueuePtr rear;&#125; LinkQueue; 循环队列 12345typedef struct &#123; QElemType * base; int front; int rear;&#125; SqQueue; 3 串3.1 定长串12typedef unsigned char SString[MAXSTRLEN + 1];SString s; 3.2 变长 堆分配存储 1234typedef struct &#123; char * ch; int length;&#125;HString; 块链存储 123456789typedef struct Chunk&#123; char ch[CHUNKSIZE]; struct Chunk * next;&#125; Chunk;typedef struct &#123; Chunk * head; Chunk * tail; int curlen;&#125; LString; 应用 子串定位 (KMP) 4 数组和广义表4.1 数组顺序存储123456typedef struct &#123; ElemType * base; int dim; // 数组维数 int * bounds; // 维界基址 int * constants; // 印象函数常量基址&#125; Array; 4.2 矩阵 讨论稀疏矩阵的存储 三元顺序表 1234567891011typedef struct &#123; int i; int j; ElemType e;&#125; Triple;typedef struct &#123; Triple data[MAXSIZE + 1]; int mu; // 行 int nu; // 列 int tu; // 非零个数&#125;TSMatrix; 行逻辑链接 12345typedef struct &#123; Triple data[MAXSIZE + 1]; int rpos[MAXRC + 1]; // 各行第一个非零元素位置表 int mu, nu, tu;&#125; RLSMatrix; 十字链表 123456789101112typedef struct OLNode &#123; int i; int j; ElemType e; struct OLNode * right; // 该非零元素所在行的右链域 struct OLNode * down; // 该非零元素所在列的下链域&#125; OLNode, * OLink;typedef struct &#123; OLink * rhead; // 行链表头指针地址 OLink * chead; // 列链表头指针地址 int mu, nu, tu;&#125; CrossLink; 4.3 广义表 表中有表 头尾链表存储 1234567891011typedef enum &#123; ATOM, LIST &#125; ElemTag; // 0 : 原子, 1 : 子表typedef struct GLNode &#123; ElemTag tag; union &#123; AtomType atom; struct &#123; struct GLNode * hp; // 表头 struct GLNode * tp; // 表尾 &#125; ptr; // 表节点指针域 &#125;;&#125; * GList; 扩展线性链表存储 1234567891011typedef enum &#123; ATOM, LIST &#125; ElemTag; // 0 : 原子, 1 : 子表typedef struct GLNode &#123; ElemTag tag; union &#123; AtomType atom; struct &#123; struct GLNode * hp; // 表头 &#125; ptr; // 表节点指针域 &#125;; struct GLNode * tp; // 表尾, 相当于 next.&#125; * GList; 5 树和二叉树5.1 二叉树存储结构 顺序存储结构 数组, 利用下标寻址 1typedef TElemType SqBiTree[MAX_TREE_SIZE]; 链式存储结构 12345typedef struct BiTNode &#123; TElemType data; struct BiTNode * lchild; struct BiTNode * rchild;&#125; BiTNode, * BiTree; 5.2 遍历二叉树 先序遍历 根节点 -&gt; 左子树 -&gt; 右子树 中序遍历 左子树 -&gt; 根节点 -&gt; 右子树 后序遍历 左子树 -&gt; 右子树 -&gt; 根节点 算数表达式 a + b * (c - d) - e / f 前缀表达式-先序遍历(逆波兰 : - + a * b - cd / ef) 中缀表达式-中序遍历(原表达式 : a + b * (c - d) - e / f) 后缀表达式-后续遍历(逆波兰式 : abcd - * + ef / -) 5.3 线索二叉树 保存比遍历过程中的节点相关性结果 前驱后继节点和左右孩子指示 lchild LTag data RTag rchild LTag 0 : lchild 域指示左孩子 1 : lchild 域指示前驱节点 RTag 0 : rchild 域指示右孩子 1 : rchild 域指示后继节点 12345678typedef enum PointerTag &#123;Link, Thread&#125;; // 0 : 指针 1 : 线索typedef struct BiThrNode &#123; TElemType data; struct BiThrNode * lchild; struct BiThrNode * rchild; PointerTag LTag; PointerTag RTag;&#125; BiThrNode, * BiThrTree; 5.4 树和森林 双亲表示法 123456789typedef struct PTNode &#123; TElemType data; int parent;&#125; PTNode;typedef struct &#123; PTNode nodes[MAX_TREE_SIZE]; int r; // 根的位置 int n; // 节点数&#125; PTree; 孩子表示法 12345678910111213typedef struct CTNode &#123; // 孩子节点 struct CTNode * next; int child;&#125; * ChildPtr;typedef struct &#123; TElemType data; ChildPtr firstchild; // 孩子链表头指针&#125; CTBox;typedef struct &#123; CTBox nodes[MAX_TREE_SIZE]; int r; // 根的位置 int n; // 节点数&#125; CTree; 孩子兄弟表示法 12345typedef struct CSNode &#123; ElemType data; struct CSNode * firstchild; struct CSNode * nextsibling;&#125; CSNode, * CSTree; 5.5 二叉树和森林互换 森林转换成二叉树 左孩子右兄弟(左右是对二叉树而言, 孩子兄弟是对森林而言, 下面同理) 二叉树转换成森林 左孩子转换成孩子, 右孩子转换成兄弟 5.6 树和森林遍历 先序遍历森林 第一棵树的根 先序遍历第一棵树中根节点的子树森林 先序遍历除第一棵树剩余的树构成的森林 中序遍历森林 中序遍历第一棵树中根节点的子树森林 第一棵树的根 中序遍历除第一棵树剩余的树构成的森林 7 图7.1 图的存储结构 数组表示法 123456789101112typedef enum &#123;DG, DN, UDG, UDN&#125; GraphKind; // &#123;有向图, 有向网, 无向图, 无向网&#125;typedef struct ArcCell &#123; VRType adj; // 顶点相关类型. 无权图 : 1/0 表示相邻与否 带权图 : 权值信息 InfoType * info; // 该弧相关的指针&#125; ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct &#123; VertexType vexs[MAX_VERTEX_NUM]; // 顶点向量 AdjMatrix arcs; // 邻接矩阵 int vexnum; // 顶点数 int arcnum; // 弧数 GraphKind kind; // 图的种类标志&#125; MGraph; 邻接表 表节点 adjvex nextarc info 头结点 data firstarc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748typedef struct ArcNode &#123; int adjvex; // 该弧所指向顶点位置 struct ArcNode * nextarc; // 指向下一条弧的指针 InfoType * info; // 该弧相关信息的指针&#125; ArcNode;typedef struct VNode &#123; VertexType data; // 顶点信息 ArcNode * firstarc; // 指向第一条依附该顶点的弧的指针&#125; VNode, AdjList[MAX_VERTEX_NUM];typedef struct &#123; AdjList vertices; int vexnum; // 顶点数 int arcnum; // 弧数 int kind; // 种类标记&#125; ALGraph;``` - 十字链表 &gt; 弧节点&gt; &gt; | tailvex | headvex | hlink | tlink | info |&gt; |---------|---------|-------|-------|------|&gt; &gt; 顶点节点&gt; &gt; | data | firstin | firstout |&gt; |------|---------|----------|&gt; ```Ctypedef struct ArcBox &#123; int tailvex; // 该弧的尾顶点位置 int headvex; // 该弧的头顶点位置 struct ArcBox * hlink; // 弧头相同的弧的链域 struct ArcBox * tlink; // 弧尾相同的弧的链域 InfoType * info; // 该弧相关信息指针&#125; ArcBox;typedef struct VexNode &#123; VertexType data; ArcBox * firstin; // 指向该节点第一条入弧 ArcBox * firstout; // 指向该节点第一条出弧&#125; VexNode;typedef struct &#123; VexNode xlist[MAX_VERTEX_NUM]; // 表头向量 int vexnum; // 有向图的当前顶点数 int arcnum; // 有向图的当前弧数&#125; OLGraph; 邻接多重表 每一条边用一个节点表示 mark ivex ilink jvex jlink info 每个顶点用一个节点表示 data firstedge 123456789101112131415161718typedef enum &#123;unvisited, visited&#125; VisitIf;typedef struct EBox &#123; VisitIf mark; // 访问标记 int ivex; // 依附顶点位置 int jvex; // 依附顶点位置 struct EBox * ilink; // 依附顶点的下一边 struct EBox * jlink; // 依附顶点的下一边 InfoType * info; // 该边的信息指针&#125; EBox;typedef struct VexBox &#123; VertexType data; EBox * firstedge; // 指向第一条依附该顶点的边&#125; VexBox;typedef struct &#123; VexBox adjmulist[MAX_VERTEX_NUM]; int vexnum; // 无向图的顶点数 int edgenum; // 无向图的边数&#125; AMLGraph 7.2 图的遍历 深度优先搜索 以迷宫为例子(面试中被问到, 印象比较深刻). 深度优先就是一条路走到黑, 所以返回的第一条路径不保证是最优解. 123456789101112131415161718192021222324Boolean visited[MAX]; // 访问标志数组Status (* VisiteFunc) (int v); // 函数变量 void DFSTraverse(Graph G, Status (* Visit)(int v)) &#123; // 深度优先遍历 VisitFunc = Visit; // 使用全局变量 VisitFunc, 使 DFS 不必设置函数指针参数 for (v = 0; v &lt; G.vexnum; ++v) &#123; visited[v] = FALSE; // 访问数组标志初始化 &#125; for (v = 0; v &lt; G.vexnum; ++v) &#123; if (!visited[v]) &#123; DFS(G, v); // 对未访问的顶点调用 DFS &#125; &#125;&#125; void DFS(Graph G, int v) &#123; // 从第 v 个顶点出发递归的深度优先遍历图 G. visited[v] = TRUE; VisitFunc(v); // 访问第 v 个顶点 for (w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w)) &#123; if (!visited[w]) &#123; DFS(G, w); // 对 v 的尚未访问的邻接顶点 w 递归调用 DFS. &#125; &#125;&#125; 广度优先搜索 有点层序遍历的意思, 在遍历完所有情况下(可以进行算法优化, 对有些情况进行舍弃)可以得出最优解. 123456789101112131415161718192021222324void BFSTraverse(Graph G, Status (* Visit) (int v)) &#123; for (v= 0; v &lt; G.vexnum; ++v) &#123; visited[v] = FALSE; &#125; InitQueue(Q); for (v = 0; v &lt; G.vexnum; ++v) &#123; if (!visited[v]) &#123; visited[v] = TRUE; Visit(v); EnQueue(Q, v); while (!QueueEmpty(Q)) &#123; DeQueue(Q, u); for (w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)) &#123; // w 为 u 尚未访问的邻接顶点 if (!visited[w]) &#123; visited[w] = TRUE; Visit(w); EnQueue(Q, w); &#125; // if &#125; // for &#125; // while &#125; // if &#125; // for&#125; // BFSTraverse // 以下待填 7.3 图的连通性问题 无向图的连通分量和生成树 有向图的强连通分量 7.4 最小生成树 Prim 算法 O(n2) 以点为主: 主要是分为两个集合, 一个是已加入的节点, 另一个是未加入节点. 在未加入的节点集合中找到一个离已加入集合最近的节点加入. 直至所有节点被加入. Kruskal 算法 O(eloge) 以边为主: 初始条件是把图的所有边去除变成 V 个连通图. 然后每次找一条代价最小的边加入, 确保每加入一条边连通图个数都减少一个(也就是确保无环路)。直至成一个连通图时就是最小生成树. 7.5 最短路径 Dijkstra 算法 O(n3) 主要是维护一个表和一个已加入路径集合, 表记录从原点到每一个点的当前最小权值. 如果已加入路径集合中的点通过某条路径对未加入集合中的点的最小权值有影响则更新该节点权值. 最后在每次更新完成后判断目前未加入集合中的最小权值节点加入集合, 再对该节点的边所达的节点做如上判断. 最终可以求出起点到每一个点的所有最短路径. Floyd 算法 O(n3) 主要是判断经过该点到达的临时目点的权值和该点目前权值(可以不考虑是否已经经过, 但是循环只会扫一遍所以没有什么影响)的大小来判断是否更新权值. 关键路径和拓扑排序 (KeyWord : 松弛) 8 动态存储管理查找","tags":[{"name":"Algo","slug":"Algo","permalink":"http://fitzeng.org/tags/Algo/"},{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"C/C++","slug":"C-C","permalink":"http://fitzeng.org/tags/C-C/"},{"name":"DataStruct","slug":"DataStruct","permalink":"http://fitzeng.org/tags/DataStruct/"}]},{"title":"Android 单元测试工具 Robolectric 中文文档","date":"2017-07-30T16:00:00.000Z","path":"2017/07/31/robolectric/","text":"为什么要翻译文档? 由于在大三暑假时间算是比较充裕的, 然后加上自己英语比较渣, 又对 gitbook 有兴趣, 所以就想翻译一些文档. 平时也是一直看别人的干货, 所以也想自己做点贡献, 希望能帮助英语是短板的部分人. 为什么是 Robolectric? 其实原因很简单, 就是我之前写过一篇 Android 单元测试和 Robolectric 源码解析 的文章, 直接看的二手资料, 感觉这种学习方式太被动了, 要自己尝试去啃第一手资料. 而正好网上没有对应的中文文档加上内容少, 一个人可以完成, 再加上前面的第一点就直接开始行动了. 阅读建议 我自知自己水平很渣, 所以一些实在想不通的直接给出了原文对应的英文文档供大家参考, 如果你已经是有了 4/6 级的水平, 推荐你直接看英文文档, 这份可以作参考. 当然如果可以的话, 欢迎大家留言提出修改意见. 对于翻译难理解, 有歧义, 有错误的地方欢迎大家指出来. 我在此先表示感谢. 项目 Robolectric Robolectric-cn GitHub GitBook 关于我 目前是一个 Android 开发者, 即将毕业面临就业, 希望在毕业前做一些自己喜欢的事情. 同时也希望能贡献自己的一份力, 和大家探讨学习. Blog GitHub","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"Android Unit Test","slug":"Android-Unit-Test","permalink":"http://fitzeng.org/tags/Android-Unit-Test/"}]},{"title":"JavaTips","date":"2017-07-25T03:27:00.000Z","path":"2017/07/25/JavaTips/","text":"这篇文章主要是个人在二次学习 Java 过程中, 对 Java 的一些常见特性误解的分析. 主要是以测试代码加测试结果的形式来记录. 这里只做收集整理和简单分析, 详情请见参考链接, 支持原作者. 目录 基本类型 == 和 equals String, StringBuffer 和 StringBuilder Array ArrayList LinkedList Exception Collction 基本概念 类变量和局部变量 基本类型== 和 equals123456789101112TestCode:Integer a = 100;Integer b = 100;System.out.println(a == b);Integer c = 1000;Integer d = 1000;System.out.println(c == d);Output:truefalse 其中 == 结果不一致是因为 Integer 类对在 -128 到 127 之间的数值进行了缓存. 1234567TestCode:Integer e = new Integer(100);Integer f = new Integer(100);System.out.println(e == f);Output:false Integer a = 100;涉及到自动装箱问题, 反编译之后就是 Integer a = Integer.valueOf(100);.而Integer e = new Integer(100); 反编译不改变. 所以在 a 和 e 这两个对象引用的堆区域一个是通过valueOf()获得, 另一个是通过new获得. 毫无疑问 new 出来的肯定不会是同一块区域. 而 valueOf() 123456&gt; public static Integer valueOf(int i) &#123;&gt; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&gt; return IntegerCache.cache[i + (-IntegerCache.low)];&gt; return new Integer(i);&gt; &#125;&gt; 这里就解释了前面的Integer 类对在 -128 到 127 之间的数值进行了缓存. 详情见源码. 123456789101112TestCode:String s1 = \"1234\";String s2 = \"1234\";System.out.println(s1 == s2);String s3 = new String(\"1234\");String s4 = new String(\"1234\");System.out.println(s3 == s4);Output:truefalse 这个比较简单, 就是在 JVM 中存在常量池. 还有要注意的是两种初始化方式的不同才造成了这个差异. 下面分析 equals ,详情见参考.这里只提几点易混淆的地方. equals 是属于类方法, 而且是 Object 类的. 而 Object 类的实现就是判断引用是否相等. 而对于某个类来说判断相等一般是判断里面的某些成员变量是否相等. 所以就要重写父类方法.这里要区分重写和重载. 12345&gt; 重写:&gt; public boolean equals(Object obj) &#123;&#125;&gt; 重载:&gt; public boolean equals(MyObject myObj) &#123;&#125;&gt; 所以要想实现自己想要的 equals 方法应该是重写. 其实这里面的主要内容就是了解了自动拆装箱和 JVM 内分配就不难了. 第一类：整型 byte Byte | short Short | int Integer | long Long 第二类：浮点型 float Float | double Double 第三类：逻辑型 boolean Boolean 第四类：字符型 char Character 在支持 equals 特性的时候, 往往还要支持 hashCode 参考: 让人疑惑的Java代码 Java字符串那些事儿 说说Java里的equals（上） Java自动装箱/拆箱 说说Java里的equals（中） String, StringBuffer 和 StringBuilder String final 类. String s=”sss”; 会在静态常量池中查找 String s = new String(“sss”); 直接在堆中开辟内存 使用场合: 在字符串不经常变化的场景中可以使用 String 类, 如: 常量的声明, 少量的变量运算等 StringBuffer 线程安全, 可自身修改 必须通过构造函数初始化 使用场合: 在频繁进行字符串的运算(拼接, 替换, 删除等), 并且运行在多线程的环境中, 则可以考虑使用 StringBuffer, 例如 XML 解析, HTTP 参数解析和封装等 StringBuilder 线程不安全, 操作最快 使用场合: 和 StringBuffer 类似的不要求线程安全场景, 效率比 StringBuffer 高 Array 是一个在 JVM 中的特殊对象, 可以使用反射查看 拷贝时注意深拷贝还是浅拷贝 ArrayList 首先要知道的是这是一个 Array 所以在进行修改操作时十分不方便的. 特别是增加或者删除元素, 扩大存储等方式相比链表结构来说麻烦太多.知道这个为出发点, 对于源码实现的理解就理所当然了.应该了解的几个点 在 ArrayList 中从有元素开始就会分配 10 的对象大小容量. 接下来以 currentSize * 1.5 的大小扩容. 对于修改空间是以 System.arraycopy() 形式修改的. 为了提高效率采用的是 native 方法. 123&gt; public static native void arraycopy(Object src, &gt; int srcPos, Object dest, int destPos, int length);&gt; 详情源码分析见参考. 参考: ArrayList初探 再探ArrayList（ArrayList的扩容） 三顾ArrayList LinkedList 实现方式是双向链表 Exception 尽可能的减小try块 保证所有资源都被正确释放, 充分运用finally关键词 catch语句应当尽量指定具体的异常类型, 而不应该指定涵盖范围太广的 Exception 类. 不要一个Exception试图处理所有可能出现的异常 既然捕获了异常, 就要对它进行适当的处理 在异常处理模块中提供适量的错误原因信息, 组织错误信息使其易于理解和阅读 不要在 finally 块中处理返回值 不要在构造函数中抛出异常 参考: 树上月 Collction List 列表(可重复) ArrayList (数组) LinkedList (链表) Map 映射(key-value) HashMap extends AbstractMap implements Map table 数组 + Enter 节点 默认初始容量(16) 默认加载因子(0.75) 查找采用 static int indexFor(int h, int length) { return h &amp; (length-1); } 提高效率, 而不是取模. TreeMap extends AbstractMap implements NavigableMap interface NavigableMap extends SortedMap interface SortedMap extends Map 红黑树 + Enter 节点 Set 集合(不能重复) HashSet extends AbstractSet implements Set 内部基于 HashMap 实现 TreeSet extends AbstractSet implements NavigableSet interface NavigableSet extends SortedSet interface SortedSet extends Set 基于 TreeMap 实现 基本概念类变量和局部变量1234public static void main(String[] args) &#123; int a; System.out.println(a);&#125; 类变量：准备阶段、初始化阶段都可赋值。局部变量：准备阶段不能检测，初始化阶段未初始化不能使用。","tags":[{"name":"Java","slug":"Java","permalink":"http://fitzeng.org/tags/Java/"},{"name":"Tips","slug":"Tips","permalink":"http://fitzeng.org/tags/Tips/"}]},{"title":"leetcode 算法集锦","date":"2017-07-17T03:27:00.000Z","path":"2017/07/17/AlgoAndMath/","text":"leetcode 算法集锦 主要是牛客网上 leetcode 的算法题实践. 在 Blog 包含自己的解法和对别人优秀解法的分析. 序号 考点 题目 C/C++ Java 01 树 Minimum Depth of Binary Tree NULL 题解 02 栈 evaluate-reverse-polish-notation NULL 题解 02 : evaluate-reverse-polish-notation Evaluate the value of an arithmetic expression in Reverse Polish Notation.Valid operators are+,-,*,/. Each operand may be an integer or another expression. Some examples: [“2”, “1”, “+”, “3”, ““] -&gt; ((2 + 1) 3) -&gt; 9 [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6 我的解法 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Stack;public class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;String&gt; s = new Stack&lt;&gt;(); int op1 = 0; int op2 = 0; for (int i = 0; i &lt; tokens.length; i++) &#123; switch (tokens[i]) &#123; case \"+\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 + op1)); break; &#125; case \"-\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 - op1)); break; &#125; case \"*\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 * op1)); break; &#125; case \"/\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 / op1)); break; &#125; default: &#123; s.push(tokens[i]); break; &#125; &#125; &#125; return Integer.parseInt(s.pop()); &#125;&#125; 其他解法 12345678910111213141516171819202122232425262728293031import java.util.Stack;public class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i = 0;i&lt;tokens.length;i++)&#123; try&#123; int num = Integer.parseInt(tokens[i]); stack.add(num); &#125;catch (Exception e) &#123; int b = stack.pop(); int a = stack.pop(); stack.add(get(a, b, tokens[i])); &#125; &#125; return stack.pop(); &#125; private int get(int a,int b,String operator)&#123; switch (operator) &#123; case \"+\": return a+b; case \"-\": return a-b; case \"*\": return a*b; case \"/\": return a/b; default: return 0; &#125; &#125;&#125; 01 : Minimum Depth of Binary Tree Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 我的解法 123456789101112131415深度优先遍历所有节点, 直至叶子节点后返回长度. 每次取当前节点左右子节点的 [最小值+1] 为该节点的最小深度. public class Solution &#123; public int run(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int length1 = run(root.left); int length2 = run(root.right); if (length1 == 0 || length2 == 0) &#123; return length1 + length2 + 1; &#125; return Math.min(length1, length2) + 1; &#125;&#125; 其他思路 1234567891011121314151617181920212223242526class Solution &#123;public: typedef TreeNode* tree; int run(TreeNode *root) &#123; //采用广度优先搜索，或者层序遍历，找到的第一个叶节点的深度即是最浅。 if(! root) return 0; queue&lt;tree&gt; qu; tree last,now; int level,size; last = now = root; level = 1;qu.push(root); while(qu.size())&#123; now = qu.front(); qu.pop(); size = qu.size(); if(now-&gt;left)qu.push(now-&gt;left); if(now-&gt;right)qu.push(now-&gt;right); if(qu.size()-size == 0)break; if(last == now)&#123; level++; if(qu.size())last = qu.back(); &#125; &#125; return level; &#125;&#125;;","tags":[{"name":"Algo","slug":"Algo","permalink":"http://fitzeng.org/tags/Algo/"},{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"Java","slug":"Java","permalink":"http://fitzeng.org/tags/Java/"},{"name":"C/C++","slug":"C-C","permalink":"http://fitzeng.org/tags/C-C/"}]},{"title":"Android Blog Collection","date":"2017-07-08T03:27:00.000Z","path":"2017/07/08/AndroidBlogCollection/","text":"this repo aims to collect some high quality basic knowledge Android Blog. Just like source code analysis or something. 这个仓库致力于收集我在学习 Android 开发过程所遇到的高质量的基础知识文章. 类似于源码分析之类的, 可以帮大家加深对基础原理的理解. 0. Start&gt; 前言 现在网络上有太多的知识可供学习, 但是作为一个自学者, 是好事也是坏事, 好事指不用担心没资源, 坏事是指对学习效率,理解程度和知识体系搭建都不太好.网上的文章不全是高质量的, 而且很多都是重复的碎片化知识,大家写的都差不多.所以为了自己的系统学习, 建议买书, 碰到哪个模块不懂再找大牛的 Blog 加深理解. 所以可以看到我推荐的基本都是成一个小体系的系列文章, 可以帮助我们形成一个好的”学习思维树”. 而不是一大堆”散叶”. 而其他文章主要是作为自己加深理解, 对某个知识点深入学习的参考. 首先可以肯定像我这种刚刚入门的在写文章的高度和视野都不如大牛. 而对于基础的知识,特别是涉及源码解析, 只要以一份资料为主就可以了. 最多加一两份做参考. 所以, 基本这种类型的文章, 我会收藏整理在这篇文章里并且永久更新. 同时自己也会利用课余时间把自己的实践项目以一个入门的学习者的视角解析, 相信这样对初学的开发者是比较友好的.如果你和我也一样处在这个阶段, 欢迎关注这篇文章. 这里永久更新这类基础知识解读. GitHub 和 Blog 永久更新练习项目. 如果对你有帮助欢迎 Star ^_^; &gt; 更新 v3 : 敬请期待… v2 : 添加 JVM 设计模式 常用框架 计算机基础 四大模块优质 Blog 收集 v1 : 以 Android View 基础知识为主的 Blog 收集. 1. UI&gt; View 的绘制源码解析 这里推荐的是Carson_Ho的一系列源码分析教程, 主要是从 View 和 ViewGroup 的测量, 布局和绘制过程进行详细分析, 很多图示十分清晰易懂, 对于初学者和进阶者都是很不错的学习资料. 如果有找到其他的好的教程我还会继续加上. 自定义View基础 - 最易懂的自定义View原理系列(1) 自定义View Measure过程 - 最易懂的自定义View原理系列(2) 自定义View Layout过程 - 最易懂的自定义View原理系列(3) 自定义View Draw过程- 最易懂的自定义View原理系列(4) 前面给了 View 的绘制最主要的三个过程进行了详细分析的 Blog, 在前面的阅读基础上,下面给出郭霖大神的 View 的工作原理系列文章. 相信在读完以下四篇文章之后你会对 View 有一个重新认识的. Android LayoutInflater原理分析，带你一步步深入了解View(一) Android视图绘制流程完全解析，带你一步步深入了解View(二) Android视图状态及重绘流程分析，带你一步步深入了解View(三) Android自定义View的实现方法，带你一步步深入了解View(四) 下面介绍扔物线的HenCoder：给高级 Android 工程师的进阶手册, 包含了视频讲解. 目前持续更新, 在学习完前面的 Blog 并进行了部分实践 Demo 后把这当做复习提高挺不错的, 同时我也会一直关注并更新. HenCoder Android 开发进阶: 自定义 View 1-1 绘制基础 &gt; View 相关类解析 这个主要是介绍一些对自定义 View 过程中需要仔细了解的一些类的使用. Path类的最全面详解 - 自定义View应用系列 Canvas类的最全面详解 - 自定义View应用系列 &gt; XML 使用示例 这里推荐Keegan小钢的Android样式的开发相关教程, 通过十分简洁的小例子帮你快速实现对 XML 的了解和使用. Android样式的开发:shape篇 Android样式的开发:selector篇 Android样式的开发:layer-list篇 Android样式的开发:drawable汇总篇 Android样式的开发:View Animation篇 Android样式的开发:Property Animation篇 Android样式的开发:Style篇 &gt; 动画 Android 动画介绍, 感谢阿祥JOKER 分享. Android动画解析 重点!!!这里还是推荐郭霖大神的文章. 然后后面补充一篇偏知识点式的文章供复习. Android属性动画完全解析(上)，初识属性动画的基本用法 Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法 Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法 补充参考:Android动画，一篇就够, 感谢Shaun白一辰的分享. &gt; 事件分发 事件分发是一个重要的知识点, 在面试中也有很大几率被问到.在开发中经常会遇到, 只有彻底理解好了在写代码时候才能思路清晰.希望以下文章能帮助你我弄清事件分发机制. Android事件分发机制详解：史上最全面、最易懂 &gt; 自成体系的 View 教程 这里主要是推荐一些其他优秀文章作为参考阅读, 同样也是自成体系的. GcsSloop : 安卓自定义View教程目录 2. Java API 这里主要是对 Java API 中的一些重要的源码解析进行收集. 同时也是面试重点, 希望能加深对 Java 的认识. 做到真的理解底层实现而不是只会使用. 由于 Java 面太广, 所以在这里主要是以知识点的形式覆盖基本概念. 这里推荐 树上月 的教程. 从 Blog 介绍看接触 Java 有一段时间, 所以分析会比较深入且正确. 更主要的是, 他把 Java 类文章基本都串起来了, 共有 38 篇可供学习. 文章太多就不一一贴链接了… 想学Java, 值得一阅 3. 浅析JVM 当然这块知识会推荐一本书, 是《深入理解 Java 虚拟机》， 而网上的那些分析大多数都是基于这本书的。这里会收集一些较好的讲解共在线阅读。 4. 深入理解设计模式 这块也有一本书《Android 源码设计模式解析与实战》推荐. Java 的 23 种设计模式全解析 LoveLion：史上最全设计模式导学目录（完整版） 5. Android 常用框架分析6. Android - 从文件到项目的最后一米 主要是提供开发过程中的非代码技术性问题的知识介绍和解决方案。 Android 项目编译过程 Android 使用android-support-multidex解决Dex超出方法数的限制问题,让你的应用不再爆棚 7. 计算机基础&gt; 数据库如果有人问你数据库的原理，叫他看这篇文章 &gt; 网络&gt; 操作系统","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"Collection","slug":"Collection","permalink":"http://fitzeng.org/tags/Collection/"}]},{"title":"Common Sense","date":"2017-07-05T02:00:00.000Z","path":"2017/07/05/tips/","text":"this aticle aims to collect some common sense when you meet during dev.这篇文章主要是记录我在 Android 开发过程中遇到的一些概念问题, 在这里提供简单快速的使用规范. 开源项目许可证 看懂UML类图 开源项目许可证MIT、GPLv2和Apache占据了前三位。choosealicense.com为许可证的选择给出了建议. MIT是一个几乎可以“为所欲为”的许可证，如果你希望简单、宽松，它是你的不二选择. 如果你关心软件的专利问题，但同样希望宽松，可以选择Apache. 如果你希望代码使用者同样能把他们的贡献分享出来，那就选择GPL. 参考: 曹知渊 : GitHub发布开源许可证使用情况 看懂UML类图 泛化关系 (A继承自B) eg: 实现关系 (继承抽象类) 聚合关系( A 聚合到 B 上或者 B 由 A 组成) 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合关系( A 组成 B 或者 B 由 A 组成) 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系 它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系 ( A 依赖于 B ) 他描述一个对象在运行期间会用到另一个对象的关系； 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 实例 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 注: “看懂UML类图” 内容全部取材自该网页. 在此做出感谢, 出于学习总结目的特意把内容搬至此处, 如有侵权立即删除. 参考: congestion : UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）","tags":[{"name":"Tips","slug":"Tips","permalink":"http://fitzeng.org/tags/Tips/"}]},{"title":"BMP压缩成JPEG过程实现与分析","date":"2017-06-12T16:00:00.000Z","path":"2017/06/13/BMP2JPEG/","text":"GitHub 前言由于最近做了图像相关的学习，所以想再深入点，但是自己的知识有限，目前只能把自己所学的通过这个小小的实验来加深理解。参考大牛的 Blog 加上自己亲手实践，写了这篇文章。以后还会继续添加图像处理的相关知识。 BMP介绍 BMP文件头文件头主要是包含一个文件的ID信息，所以BMP的文件头自然也是说明自己的文件格式，文件大小等信息，一般是14位表示。意义如下图所示： 位图信息头信息头主要是对图片特征的描述，比如说宽高，像素，压缩方式等，一般是40位。主要介绍如下表： 调色板调色板是可选的，使用索引来表示图像，调色板就是索引与其对应的颜色的映射表，这次实验选用的是24bit的图片。 位图数据这里就是存储图片的内容了。 JPEG介绍JPEG是有损压缩编码下的一种图片格式，目前压缩效果好，应用广泛。其原理主要是将传统的RGB模式下的图片转化成YCbCr格式。因为人眼的结构问题对亮度更加敏感，所以可以将亮度和色度分离开来，对色度可进行较大的舍弃从而进行较大程度的压缩而对视觉不造成太大影响。既然是压缩而成的格式，那必然有解压缩过程，而解压缩所以依赖的量化表和哈夫曼表自然要记录下来。所以和BMP对比自然而然头结构出来了，而且要比BMP复杂。下面只给出部分信息： BMP 读取 构建BMP的文件头和头信息结构体 12345678910111213141516171819202122//BMP 文件格式【文件头和头部信息】typedef struct &#123; unsigned short bfType; unsigned int bfSize; unsigned short bfReserved1; unsigned short bfReserved2; unsigned int bfOffBits;&#125; BITMAPFILEHEADER;typedef struct &#123; unsigned int biSize; int biWidth; int biHeight; unsigned short biPlanes; unsigned short biBitCount; unsigned int biCompression; unsigned int biSizeImage; int biXPelsPerMeter; int biYPelsPerMeter; unsigned int biClrUsed; unsigned int biClrImportant;&#125; BITMAPINFOHEADER; 图片校验 1234567891011121314151617181920212223242526272829303132//打开文件FILE* fp = fopen(fileName, \"rb\");if(fp==0) &#123; return false;&#125;BITMAPFILEHEADER fileHeader;BITMAPINFOHEADER infoHeader;// 读取头部 14字节if(1 != fread(&amp;fileHeader, sizeof(fileHeader), 1, fp)) &#123; return false;&#125;// 判断是不是BM类型if(fileHeader.bfType!=0x4D42) &#123; return false;&#125;// 读取头部信息 40字节if(1 != fread(&amp;infoHeader, sizeof(infoHeader), 1, fp)) &#123; return false;&#125;// 判断是不是24位类型。也就是RGB的存储格式if(infoHeader.biBitCount != 24 || infoHeader.biCompression != 0) &#123; return false;&#125;int width = infoHeader.biWidth;int height = infoHeader.biHeight &lt; 0 ? (-infoHeader.biHeight) : infoHeader.biHeight;// 判断二进制的最后三位是不是000，也就是判断是不是8的倍数if((width&amp;7) != 0 || (height&amp;7) != 0) &#123; return false;&#125; 图片内容读取 123456789101112131415161718192021222324252627// RGB三个分量int bmpSize = width*height*3;unsigned char* buffer = new unsigned char[bmpSize];if(buffer == 0) &#123; return false;&#125;// 将文件指针移到数据区域fseek(fp, fileHeader.bfOffBits, SEEK_SET);if(infoHeader.biHeight &gt; 0) &#123; for(int i = 0; i &lt; height; i++) &#123; // 读取第i行,每此读 3（size） * width （count）大小 if(width != fread(buffer + (height - 1 - i) * width * 3, 3, width, fp)) &#123; delete[] buffer; buffer = 0; return false; &#125; &#125;&#125; else &#123; if(width*height != fread(buffer, 3, width*height, fp)) &#123; delete[] buffer; buffer = 0; return false; &#125;&#125; 存储信息 1234567// 获取宽高和大小m_rgbBuffer = buffer;m_width = width;m_height = height;fclose(fp);fp=0; JPEG 写入在前期JPEG写入是，要进行一系列准备工作，根据JPEG官方提供的标准量化表和哈夫曼表进行自己的操作得到自己满意的压缩编码。 数值表： 直流分量表： 交流分量表： 下面给出具体代码： 亮度量化表 1234567891011// 亮度量化表const unsigned char Luminance_Quantization_Table[64] = &#123; 16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99&#125;; 色度量化表 1234567891011// 色度量化表const unsigned char Chrominance_Quantization_Table[64] = &#123; 17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99&#125;; 标准直流分量色度亮度哈夫曼表 12345const char Standard_DC_Luminance_NRCodes[] = &#123; 0, 0, 7, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 &#125;;const unsigned char Standard_DC_Luminance_Values[] = &#123; 4, 5, 3, 2, 6, 1, 0, 7, 8, 9, 10, 11 &#125;;const char Standard_DC_Chrominance_NRCodes[] = &#123; 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 &#125;;const unsigned char Standard_DC_Chrominance_Values[] = &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 &#125;; 标准交流分量色度亮度哈夫曼表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const char Standard_AC_Luminance_NRCodes[] = &#123; 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d &#125;;const unsigned char Standard_AC_Luminance_Values[] = &#123; 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa&#125;;const char Standard_AC_Chrominance_NRCodes[] = &#123; 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 &#125;;const unsigned char Standard_AC_Chrominance_Values[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa&#125;; 计算哈夫曼编码 123456789101112131415void JpegEncoder::_computeHuffmanTable(const char* nr_codes, const unsigned char* std_table, BitString* huffman_table) &#123; unsigned char pos_in_table = 0; unsigned short code_value = 0; for(int k = 1; k &lt;= 16; k++) &#123; for(int j = 1; j &lt;= nr_codes[k-1]; j++) &#123; huffman_table[std_table[pos_in_table]].value = code_value; huffman_table[std_table[pos_in_table]].length = k; pos_in_table++; code_value++; &#125; code_value &lt;&lt;= 1; &#125;&#125; 初始化量化表根据传入的参数调整量化程度，因为这个量化过程是有损的。所以其结果对图像质量有较大影响。 123456789101112131415161718192021222324252627282930// 初始化量化表void JpegEncoder::_initQualityTables(int quality_scale) &#123; if(quality_scale &lt;= 0) &#123; quality_scale = 1; &#125; if(quality_scale &gt;= 100) &#123; quality_scale = 99; &#125; for(int i = 0; i &lt; 64; i++) &#123; int temp = ((int)(Luminance_Quantization_Table[i] * quality_scale + 50) / 100); if (temp &lt;= 0) &#123; temp = 1; &#125; if (temp &gt; 0xFF) &#123; temp = 0xFF; &#125; m_YTable[ZigZag[i]] = (unsigned char)temp; temp = ((int)(Chrominance_Quantization_Table[i] * quality_scale + 50) / 100); if (temp&lt;=0) &#123; temp = 1; &#125; if (temp&gt;0xFF) &#123; temp = 0xFF; &#125; m_CbCrTable[ZigZag[i]] = (unsigned char)temp; &#125;&#125; 写文件头到这里文件头基本已经确定，可以写入JPEG文件了。 RGB 转化成 YCbCr每读取一个 8*8 的方块区域，就进行颜色空间转化。转换式和代码如下： 1234567891011121314151617181920212223Y= 0.299*R + 0.587*G + 0.114*BC_b= -0.168*R – 0.331*G + 0.449*BC_r= 0.5*R – 0.419*G – 0.018*B void JpegEncoder::_convertColorSpace(int xPos, int yPos, char* yData, char* cbData, char* crData) &#123; for (int y = 0; y &lt; 8; y++) &#123; // 跳行 unsigned char* p = m_rgbBuffer + (y + yPos) * m_width * 3 + xPos * 3; for (int x = 0; x &lt; 8; x++) &#123; unsigned char B = *p++; unsigned char G = *p++; unsigned char R = *p++; yData[y * 8 + x] = (char)(0.299f * R + 0.587f * G + 0.114f * B - 128); // yData[y * 8 + x] = 0; cbData[y * 8 + x] = (char)(-0.1687f * R - 0.3313f * G + 0.5f * B ); // cbData[y * 8 + x] = 0; crData[y * 8 + x] = (char)(0.5f * R - 0.4187f * G - 0.0813f * B); // crData[y * 8 + x] = 0; &#125; &#125;&#125; DCT变换和量化DCT变换式和量化代码： 12345678910111213141516171819202122232425// DCT变化 + 量化（未优化）void JpegEncoder::_forward_DCT(const char* channel_data, short* fdc_data) &#123; const float PI = 3.1415926f; for(int v = 0; v &lt; 8; v++) &#123; for(int u = 0; u &lt; 8; u++) &#123; float alpha_u = (u==0) ? 1 / sqrt(8.0f) : 0.5f; float alpha_v = (v==0) ? 1 / sqrt(8.0f) : 0.5f; float temp = 0.f; for(int x = 0; x &lt; 8; x++) &#123; for(int y = 0; y &lt; 8; y++) &#123; float data = channel_data[y * 8 + x]; data *= cos((2 * x + 1) * u * PI / 16.0f); data *= cos((2 * y + 1) * v * PI / 16.0f); temp += data; &#125; &#125; temp *= alpha_u * alpha_v / m_YTable[ZigZag[v * 8 + u]]; fdc_data[ZigZag[v*8+u]] = (short) ((short)(temp + 16384.5) - 16384); &#125; &#125;&#125; 哈夫曼编码 直流分量差分编码 123456789101112 // encode DCint dcDiff = (int)(DU[0] - prevDC);prevDC = DU[0];if (dcDiff == 0) &#123; outputBitString[index++] = HTDC[0];&#125; else &#123; BitString bs = _getBitCode(dcDiff); outputBitString[index++] = HTDC[bs.length]; outputBitString[index++] = bs;&#125; 交流分量游长编码 123456789101112131415161718192021222324252627 // encode ACsint endPos=63; //end0pos = first element in reverse order != 0while((endPos &gt; 0) &amp;&amp; (DU[endPos] == 0)) &#123; endPos--;&#125;for(int i = 1; i &lt;= endPos; ) &#123; int startPos = i; while((DU[i] == 0) &amp;&amp; (i &lt;= endPos)) &#123; i++; &#125; int zeroCounts = i - startPos; if (zeroCounts &gt;= 16) &#123; for (int j = 1; j &lt;= zeroCounts / 16; j++) &#123; outputBitString[index++] = SIXTEEN_ZEROS; &#125; zeroCounts = zeroCounts % 16; &#125; BitString bs = _getBitCode(DU[i]); outputBitString[index++] = HTAC[(zeroCounts &lt;&lt; 4) | bs.length]; outputBitString[index++] = bs; i++;&#125; 对三个通道进行以上同样的操作。（DCT变化-哈夫曼编码-写入） 1234567891011121314151617181920BitString outputBitString[128];int bitStringCounts;// Y通道压缩_forward_DCT(yData, yQuant);_doHuffmanEncoding(yQuant, prev_DC_Y, m_Y_DC_Huffman_Table, m_Y_AC_Huffman_Table, outputBitString, bitStringCounts);_write_bitstring_(outputBitString, bitStringCounts, newByte, newBytePos, fp);// Cb通道压缩_forward_DCT(cbData, cbQuant);_doHuffmanEncoding(cbQuant, prev_DC_Cb, m_CbCr_DC_Huffman_Table, m_CbCr_AC_Huffman_Table, outputBitString, bitStringCounts);_write_bitstring_(outputBitString, bitStringCounts, newByte, newBytePos, fp);// Cr通道压缩_forward_DCT(crData, crQuant);_doHuffmanEncoding(crQuant, prev_DC_Cr, m_CbCr_DC_Huffman_Table, m_CbCr_AC_Huffman_Table, outputBitString, bitStringCounts);_write_bitstring_(outputBitString, bitStringCounts, newByte, newBytePos, fp); 整个流程就是如下图所示： 实验结果测试图片 pic1.bmp 16进制 测试代码 12345678910111213const char* inputFileName = \"pic1.bmp\";JpegEncoder encoder;// 读取BMP格式的文件if(!encoder.readFromBMP(inputFileName)) &#123; return 1;&#125;// 将BMP格式的文件按照JPEG标准压缩成JPEG文件if(!encoder.encodeToJPG(\"out.jpeg\", 50)) &#123; printf(\"jpg\\n\"); return 1;&#125; 读取的BMP文件信息，大小和尺寸都符合原图 测试结果 out.jpeg 十六进制，可以和标准格式比较确实是通过BMP转成了JPEG格式 可以看到，压缩效果还是比较比较明显的，但是编码性能不是最好的，没有对数据前期进行优化，效率只是中规中矩。下面介绍对流程和结果的测试分析过程流程： 分析为什么转换成YCbCr域对色域的压缩会让人接受：从RGB到YCbCr的转换公式我们可以分析出Y所占比重较高，说明应该存储的细节相对较多，和人眼对亮度更加敏感符合。那么事实是否如此？ 从左到右依次是 Y（72.8k），Cb（37.4k），Cr（33.9k）分量，从光感上说，明显是Y的灰度图像给出了细节，其它两个分量只是给出色彩，没有细节。接着从大小分析也和我们的预测符合，大概比例是 2：1：1，说明存储的细节越多所需的空间自然越大。接下来对BMP原始通道RGB加扰动和YCbCr加相同的扰动，对图像的影响又会怎样？ 从左到右一次是在RGB通道和YCbCr通道加干扰。可以看到RGB收干扰的程度更大，原因不大好用数学分析，我觉得很可能是RGB通道对干扰是没有减弱直接进入通道转换，而YCrCb则是在色度通道进行压缩了，同时也是对干扰的舍弃，所以效果比较好。 下面分析为什么量化矩阵对结果会有很大影响，可以做一个实验，改变生成量化矩阵的算法，看看结果如何。 这两张的量化程度不同，但是可以看到的是他们都有或多或少的呈色块显示迹象，所以应该存储的空间应该是很小的。结果也确实如此，回到问题，我们的量化矩阵没有优化，造成数值过大，在量化过程中，导致过多数为0，也就是那些高频分量，而高频正是细节的体现，失去高频自然就失去了细节。所以量化矩阵的取值直接关系到了生成图像的品质。 以上是我对BMP转换成JPEG的过程分析，同时也辅以代码加以实现和测试。对于JPEG的解码过程那就是过程的逆过程了，但是由于编码是有损的，而且编码表量化表都是有转型损失的，所以解码之后的图像也会有部分损失。着呢个过程和读取解码BMP一样。先读取文件头，接下来初始化表，再就是直接读取数据根据表解码出YCbCr的值，反量化之后通过DCT逆变换还原。 其中的源码是thecodeway提供的，欢迎大家去他的 Blog 看看他的图像分析文章，我只是对他的代码加以自己的理解。 最后：如有不足，欢迎指正，共同进步。 多谢阅读 参考资料[1] 足迹 : https://www.cnblogs.com/Matrix_Yao/archive/2009/12/02/1615295.html [2] lakeone : https://www.cnblogs.com/lakeone/p/3596996.html [3] thecodeway : https://thecodeway.com/blog/?p=522 [4] SoC Design Lab http://twins.ee.nctu.edu.tw/courses/soclab_04/lab_hw_pdf/proj1_jpeg_introduction.pdf","tags":[{"name":"Algo","slug":"Algo","permalink":"http://fitzeng.org/tags/Algo/"},{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"C/C++","slug":"C-C","permalink":"http://fitzeng.org/tags/C-C/"},{"name":"图像处理","slug":"图像处理","permalink":"http://fitzeng.org/tags/图像处理/"}]},{"title":"Android 单元测试和 Robolectric 源码解析","date":"2017-05-13T16:00:00.000Z","path":"2017/05/14/Android 单元测试和 Robolectric 源码解析/","text":"前言作为一个 Android 开发的程序员，最痛苦的事情其实莫过于测试了，龟速的模拟器和麻烦的手机，基本上每测试一次都要浪费 1-2 min 去加载程序。而有了 Robolectric 这些就可以避免了。至于 Robolectric 的介绍推荐大家看看官网 （其中的用户指导是很好的学习资料）。我们用他的很大一个原因是他不需要再去把程序加载到 Android 手机或者模拟器中运行，他有自己的实现，能够调用 Android 中的很多库，下面的源码分析会提及。可是 Android Studio 对 Robolectric 不是很友好，而且在 Google 的官方教程中的测试工具也不是这个。。。同时 Robolectric 对于 Android Studio 的教程介绍似乎还是停留在 1.x 阶段，但是在 2.x 中的使用略有不同。 讲了这么多，所以 Robolectric 和 Junit 4 有什么不同？不都是测试吗？我的理解是 Junit 4 与 Robolectric 的关系和 Java 与 Android 的关系差不多。毕竟 Robolectric 是个第三方的测试库，其中很多还是要用到 Junit 的。 好了，基本的介绍完成了，下面开始使用，但是使用不是我们这次的重点，重点是源码分析。但是源码分析也是建立在知道使用的基础上，如果你之前没有使用过，推荐你看官方的 user guide。或者这两篇 Blog。 Android单元测试框架Robolectric3.0介绍(一) Android单元测试框架Robolectric3.0介绍(二) 准备其实前面 Blog 的介绍可能会有点偏差，现在的 Android Studio 2.3.1 在建立工程时除了自己的源码包，还有两个，分别是 test 和 androidTest。经过我的尝试， test 包下的测试文件可以直接测试，而 androidTest下面的还是要 android 运行环境的。个人更倾向于一个用做单元测试一个用于集成测试这种理解。所以在导入依赖包时要注意了。 121. testCompile \"org.robolectric:robolectric:3.3.2\"2. androidTestCompile \"org.robolectric:robolectric:3.3.2\" 第一种对应的测试文件要放在 test 包下，而第二种就是放在 androidTest 包下，如果搞错，你的 Robolectric 中的测试方法是无法使用的。 123456789101112dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support.constraint:constraint-layout:1.0.2' testCompile 'junit:junit:4.12' testCompile 'org.robolectric:robolectric:3.3.2' sourceCompatibility = 1.8 targetCompatibility = 1.8&#125; 至于运行的话，大家可以直接右键文件，title bar 点击运行或者在 cmd 运行都行。但是有一点要注意，一定要配置文件的 working directory，不然找不到 manifest.xml 等文件。 测试写一个如下布局 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"org.fitzeng.robolectrictest.MainActivity\"&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:id=\"@+id/et\" android:text=\"@string/app_name\" android:maxLines=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;Button android:id=\"@+id/btn_et\" android:text=\"EditText Test\" android:textAllCaps=\"false\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 1234567891011121314151617181920212223242526272829303132public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private EditText editText; private Button btnEt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); &#125; private void initViews() &#123; editText = (EditText) findViewById(R.id.et); btnEt = (Button) findViewById(R.id.btn_et); btnEt.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_et: &#123; btnEt.setText(editText.getText().toString()); break; &#125; default: break; &#125; &#125;&#125; 可以看到，这里就是测试一下点击事件，看看点击之后是否能获取 EditText 中的文本内容。 下面开始写测试代码，注意之前如果配置的是 testCompile 的话一定要把测试文件建在 test 包下，不然无法导入 Robolectric 。 1234567891011121314151617181920212223242526272829@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class, sdk = 24)public class MainActivityTest &#123; private Button btnEt; private EditText editText; @Before public void setUp() &#123; // get mainActivity obj MainActivity mainActivity = Robolectric.setupActivity(MainActivity.class); // get button btnEt = (Button) mainActivity.findViewById(R.id.btn_et); // get edittext editText = (EditText) mainActivity.findViewById(R.id.et); &#125; @Test public void testMainActivity() &#123; // simulate click event btnEt.performClick(); // get button content String expectedContent = btnEt.getText().toString(); // get edittext content String actualContent = editText.getText().toString(); // compare expectedContent and actualContent Assert.assertEquals(expectedContent, actualContent); &#125;&#125; 上面的代码我都加了注释，基本过程很清楚了，这里点击事件是只要点击，我们就把 EditText 中的文本替换 Button 的文本。测试结果如下：可以看到花的 27s 完成了点击测试，很方便。大家可以试试测试失败会是什么情况。 这里并没有开启模拟器，但是却完成了整个点击事件并进行了检测。事件虽小，但是意义很大。意味着我们不需要开启模拟器也可以对 Android 程序进行测试了。 源码分析在开始这个流程的分析之前，如果你之前对 Junit 没有任何了解，可以看看 Junit 的分析，这里仿照 Junit 对 Robolectric 进行类比分析。可以找到 Junit 的 main 入口下面一步一步分析就好了。 但是 Robolectric 代码量实在太大，去里面找东西实在太难，但是凭借程序员的直觉，相信大家最先找到的有价值的文件可能是下面几个：其中看到测试生命周期是不是眼前一亮？还有 Robolectric 类里面的函数，包含了 Fragment， AttributeSet， Activity， Service， IntentService， ContentProvider 等等熟悉的内容。可以肯定，这里就是“宇宙中心”。上面的测试代码其实也验证了这个观点。再看看 RobolectricTestRunner 这个类，还是和 Junit 4 有一腿的。里面的方法无非就是做一些初始化的工作，注释说的很明确了，就是提供一个模拟的 Android 运行时环境（和前面说的加载 manifest文件有关），这也是为什么可以直接在没有模拟器的情况下进行一些模拟点击测试的原因。 123456789/** * Installs a &#123;@link SandboxClassLoader&#125; and &#123;@link ResourceTable&#125; in order to * provide a simulation of the Android runtime environment. */// public class RobolectricTestRunner extends SandboxTestRunner// public class SandboxTestRunner extends BlockJUnit4ClassRunner// public class BlockJUnit4ClassRunner extends ParentRunner&lt;FrameworkMethod&gt;// public abstract class ParentRunner&lt;T&gt; extends Runner implements Filterable,Sortable// public abstract class Runner implements Describable 这样没有实例只看源码有点不知道往哪个方向解析，所以我们开始从源码角度看看前面测试过程怎么执行的来加深理解。 最开始是调用了 Robolectric.setupActivity(Class) 那么我们就从这里入手。 step 1 : Robolectric.setupActivity(Class)123public static &lt;T extends Activity&gt; T setupActivity(Class&lt;T&gt; activityClass) &#123; return buildActivity(activityClass).setup().get();&#125; 首先是获取 Activity 对象，正好 setUpActivity(Class) 是返回一个 Activity 对象的。那么是如何获取到的呢？那就要看源码具体实现了。大概过程是建立一个 Activity 然后 setup 一下再获取对象。 step 2.1 : Robolectric.buildActivity(Class)123public static &lt;T extends Activity&gt; ActivityController&lt;T&gt; buildActivity(Class&lt;T&gt; activityClass) &#123; return buildActivity(activityClass, null);&#125; step 2.2 : Robolectric.buildActivity(Class, Intent)123public static &lt;T extends Activity&gt; ActivityController&lt;T&gt; buildActivity(Class&lt;T&gt; activityClass, Intent intent) &#123; return ActivityController.of(getShadowsAdapter(), ReflectionHelpers.callConstructor(activityClass), intent);&#125; 到这里就可以看到利用这个类名和 Intent （null），采用反射机制可以获取这个类的对象。有兴趣的还可以深究下去。 step 3.1 : Robolectric.buildActivity(activityClass).setup()12345678910111213141516171819202122/*** Calls the same lifecycle methods on the Activity called by Android the first time the Activity is created.** @return Activity controller instance.*/public ActivityController&lt;T&gt; setup() &#123; return create().start().postCreate(null).resume().visible();&#125;/** * Calls the same lifecycle methods on the Activity called by Android when an Activity is restored from previously saved state. * * @param savedInstanceState Saved instance state. * @return Activity controller instance. */public ActivityController&lt;T&gt; setup(Bundle savedInstanceState) &#123; return create(savedInstanceState) .start() .restoreInstanceState(savedInstanceState) .postCreate(savedInstanceState) .resume() .visible();&#125; 前面的两个函数的注释很清楚，第一个是 Activity 第一次调用时调用，第二个是 Activity 之前被调用过并且在 Bundle 对象中保存了实例状态，可以将 Bundle 中的数据作为参数直接调用函数加载。返回的是一个 Activity 控制器实例。 step 3.2 : setup() -&gt; create().start().postCreate(null).resume().visible()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ActivityController.create()public ActivityController&lt;T&gt; create() &#123; return create(null);&#125;public ActivityController&lt;T&gt; create(final Bundle bundle) &#123; shadowMainLooper.runPaused(new Runnable() &#123; @Override public void run() &#123; ReflectionHelpers.callInstanceMethod(Activity.class, component, \"performCreate\", from(Bundle.class, bundle)); &#125; &#125;); return this;&#125;ActivityController.start()public ActivityController&lt;T&gt; start() &#123; invokeWhilePaused(\"performStart\"); return this;&#125;ActivityController.postCreate(Bundle)public ActivityController&lt;T&gt; postCreate(Bundle bundle) &#123; invokeWhilePaused(\"onPostCreate\", from(Bundle.class, bundle)); return this;&#125;ActivityController.resume()public ActivityController&lt;T&gt; resume() &#123; invokeWhilePaused(\"performResume\"); return this;&#125;ActivityController.visible()public ActivityController&lt;T&gt; visible() &#123; shadowMainLooper.runPaused(new Runnable() &#123; @Override public void run() &#123; ReflectionHelpers.setField(component, \"mDecor\", component.getWindow().getDecorView()); ReflectionHelpers.callInstanceMethod(component, \"makeVisible\"); &#125; &#125;); ViewRootImpl root = component.getWindow().getDecorView().getViewRootImpl(); if (root != null) &#123; // If a test pause thread before creating an activity, root will be null as runPaused is waiting // Related to issue #1582 Display display = Shadow.newInstanceOf(Display.class); Rect frame = new Rect(); display.getRectSize(frame); Rect insets = new Rect(0, 0, 0, 0); final RuntimeAdapter runtimeAdapter = RuntimeAdapterFactory.getInstance(); runtimeAdapter.callViewRootImplDispatchResized( root, frame, insets, insets, insets, insets, insets, true, null); &#125; return this;&#125; 这里看起来代码量有点多，但是大概意思应该就是为 Activity 提供一个 Android 运行环境的保障。从 Window ， DecorView 之类的就可以确认我们的想法。如果不熟悉的话可以再去了解 Android 的界面绘制过程，这里目前知道这层意思就可以了。 step 4 : Robolectric.buildActivity(activityClass).setup().get()123public T get() &#123; return component;&#125; 。。。我看到这里首先的感觉是一脸懵逼，怎么这么简单，我们的预期是返回一个 Activity 对象，也就是一个组件，从意思来看可以理解，但是这个 component 是怎么来的？下面就来慢慢分析。 1234567891011121314151617181920212223242526public abstract class ComponentController&lt;C extends ComponentController&lt;C, T&gt;, T&gt; &#123; protected final C myself; protected T component; protected final ShadowLooperAdapter shadowMainLooper; protected Intent intent; protected boolean attached; @SuppressWarnings(\"unchecked\") public ComponentController(ShadowsAdapter shadowsAdapter, T component, Intent intent) &#123; this(shadowsAdapter, component); this.intent = intent; &#125; @SuppressWarnings(\"unchecked\") public ComponentController(ShadowsAdapter shadowsAdapter, T component) &#123; myself = (C) this; this.component = component; shadowMainLooper = shadowsAdapter.getMainLooper(); &#125; public T get() &#123; return component; &#125;&#125; 看到这里我们可以确认的是 component 是来自 ComponentController() 构造函数来进行初始化的，这是你会发祥一个很熟悉的参数 ShadowsAdapter ，看看这个类。看完之后你会发现这其实是一个接口。这时你要思考的是，这些参数怎么来的，不可能凭空产生，肯定是在你的类生成 Activity 组件过程中构造的。看看 step 2.2 中的函数你会发现，第一个就是 getShadowsAdapter()，第二个是 ReflectionHelpers.callConstructor(activityClass)， 是不是发现了点什么，就是从这里开始，埋下了种子。同时 step 3.2 中有component ，发现他就是抽象类 ComponentController 中的变量，而且是 protected 的。那么现在唯一的猜想就是 ActivityController 继承自 ComponentController ，从类的命名来说是很合理的。那么源码是这样的吗？ 12// public class ActivityController&lt;T extends Activity&gt; extends org.robolectric.util.ActivityController&lt;T&gt; // abstract public class ActivityController&lt;T extends Activity&gt; extends ComponentController&lt;org.robolectric.android.controller.ActivityController&lt;T&gt;, T&gt; 看到这说明我们的想法完全正确！总算弄清楚 component 的身份，但是还是不知道他是怎么生成的？我们的预测是和 Activity 要有关联，目前的分析还看不出来，而且这里的 step 3.2 中的 component 直接作为参数传递了，说明在之前就已经被初始化了，也就是构造函数 ComponentController(ShadowsAdapter shadowsAdapter, T component) 已经被调用了。那么我们还是要回到 step 2.2 中的 ActivityController.of(getShadowsAdapter(), ReflectionHelpers.callConstructor(activityClass), intent) 因为那是 Activity 的消失和 component 出现的临界点。开始看看 of 函数。 123456789public static &lt;T extends Activity&gt; ActivityController&lt;T&gt; of(ShadowsAdapter shadowsAdapter, T activity, Intent intent) &#123; return new ActivityController&lt;&gt;(shadowsAdapter, activity, intent).attach();&#125;private ActivityController(ShadowsAdapter shadowsAdapter, T activity, Intent intent) &#123; super(shadowsAdapter, activity, intent); this.shadowsAdapter = shadowsAdapter; shadowReference = shadowsAdapter.getShadowActivityAdapter(this.component);&#125; 这时看到 activity 传给了super，应该有点警觉，前面不是验证了 ActivityController 继承自 ComponentController 吗？而 component 又是在 ComponentController 中的，难道。。。 接着 super 123456789101112protected ActivityController(ShadowsAdapter shadowsAdapter, T activity, Intent intent) &#123; super(shadowsAdapter, activity, intent);&#125;public ComponentController(ShadowsAdapter shadowsAdapter, T component, Intent intent) &#123; this(shadowsAdapter, component); this.intent = intent;&#125;public ComponentController(ShadowsAdapter shadowsAdapter, T component) &#123; myself = (C) this; this.component = component; shadowMainLooper = shadowsAdapter.getMainLooper();&#125; 费了这么一大圈最终还是找到了，就是和之前的猜想一致。就是 Activity 经过一系列的操作 (这里操作是指 ReflectionHelpers.callConstructor(activityClass), intent) ) 最终直接传递给 component 。 所以获取 Activity 对象的分析就告一段落了。至于构建细节，怎么在 JVM 中绘制 View 的我也不怎么清楚，要想了解可以对 step 3.1 中的函数进一步深究。我大概可以确定应该是在那个过程中完成的。 过程总结看图 模拟点击 -&gt; performClick()接下来就是根据获取的 Activity 来获取布局中的控件进行测试。 这里分析的是一个点击事件： 12345678910111213141516171819202122/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 你会发现这里的 performClick() 中其实是调用了 onClick() 的。下面就是要验证确定会执行这个点击事件。首先 li != null 这个条件是怎么成立的？ 12345678static class ListenerInfo &#123; /** * Listener used to dispatch focus change events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ ......&#125; 通过上述代码你会发现这是一个 View 的静态内部类。所以其实 mListenerInfo 应该是类中的一个变量。那么这个变量是在何时被初始化的呢？ 123456789ListenerInfo mListenerInfo;ListenerInfo getListenerInfo() &#123; if (mListenerInfo != null) &#123; return mListenerInfo; &#125; mListenerInfo = new ListenerInfo(); return mListenerInfo;&#125; 经过一番查找可以肯定的是，前面应该是调用了 getListenerInfo() 函数。而对于一个 Button 的 listenerInfo 凭直觉可以猜测下很大可能是 setOnClickListener() 中调用的。因为设置点击监听应该是要获取监听信息的吧。。。再就是前面除了对 Button 设置了点击事件就没做其他操作了，而且如果事件得到触发的话意味着 mListenerInfo 一定是被初始化了的。种种猜测都指向 setOnClickListener() ，那就看看源码吧。 1234567891011121314/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125; 确实是如此，如果你没有进行前面的猜测的话，可以直接搜这个函数看看在哪些地方调用了，这时你会发现一个共同点：所有和视图监听有关的函数都有调用 getListenerInfo() 。至于为什么这样？很简单，因为他们都是 Listener ，自然需要 ListenerInfo 来确定自己是什么监听，并且通过 ListenerInfo 进行管理，只要 ListenerInfo 中的某个变量是 null 就意味着这个 Listener 是未注册的。这点可以从 li.mOnClickListener != null 这个条件验证，也就是前面点击事件的触发条件。 1234567891011121314151617public void setOnScrollChangeListener(OnScrollChangeListener l) &#123; getListenerInfo().mOnScrollChangeListener = l;&#125;public void setOnFocusChangeListener(OnFocusChangeListener l) &#123; getListenerInfo().mOnFocusChangeListener = l;&#125;public void addOnLayoutChangeListener(OnLayoutChangeListener listener) &#123; ListenerInfo li = getListenerInfo(); if (li.mOnLayoutChangeListeners == null) &#123; li.mOnLayoutChangeListeners = new ArrayList&lt;OnLayoutChangeListener&gt;(); &#125; if (!li.mOnLayoutChangeListeners.contains(listener)) &#123; li.mOnLayoutChangeListeners.add(listener); &#125;&#125; 好了，点击事件就分析到这，总结一下：最开始就是设置监听，设置监听过程中会在 View 中将点击事件用 ListenerInfo 记录。在模拟点击事件中调用 performClick() ，下面就是对事件是否注册来确定是否触发点击事件。 之后就是自己写逻辑了，对你的预期和模拟跑出来的结果是否一致进行测试。这里就是 Junit 内容了。 总结通过这次源码分析，发现只要细心，很多大牛的代码慢慢读也是可以读懂的。虽然代码量太大不可能一行不落地阅读，但是从一个小例子出发，慢慢分析就可以得出你自己理解，其实代码的逻辑就是常人的逻辑，其中值得学习的恰恰是这种常人逻辑之间的协调和对代码整个的宏观把控。 这是我第一次写关于源码分析的文章，其中肯定有很多不足，欢迎大家指正。还有推荐下我的个人 Blog 最后感谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"Android Unit Test","slug":"Android-Unit-Test","permalink":"http://fitzeng.org/tags/Android-Unit-Test/"}]},{"title":"实现一个类似QQ的社交聊天工具-4","date":"2017-04-14T06:00:00.000Z","path":"2017/04/14/ZZChatApp4/","text":"GitHub 实现一个类似QQ的社交聊天工具-4准备做好【ZZChatApp3】中的内容并且下载了实现一个类似QQ的社交聊天工具-1中的资料就可以开始下面的了环境自己尝试是否能配好，下面只是给出一些提示和建议。Xampp + Java EE 实现目标这里已经实现基本的通讯了。由于最近特别忙，所以打算写两篇的网络编程总结成一篇，细节应该都会提到，只是不会太详细。希望大家多利用身边的网络资源。基本在网上都有现成的答案。 实现过程 这就是大体的方向，所以目前目标很简单，为了不打断以后的编码思路，前期工作要做好。 环境配置 下载Xampp 开启 Apache 和 mySql, 在浏览器中输入 127.0.0.1: 看看有 Xampp 界面就成功，点击 admin 出现数据库就说明数据库可以访问了。 至于 Java EE 自身是不携带 WindowBuilder 也就是你无法使用 JFrame 的图形界面进行设计。怎么安装动手搜搜就知道了。之后就只要添加访问数据库的一个库到工程里面。在资料4已经给出，导入 buildpath 就可以了。 数据库创建 这里只是效果图，数据库的内容我们通过代码来创建，可以保证每一次的测试环境一样。 通讯协议这一部分的目的是数据解析要用到的。可以这样想，我发送一个登录消息和聊天消息服务器能区分吗？如果能够区分，那是怎么区分的？这就是设计通讯协议的最原始原因。其实如果学过网络通讯就知道，TCP/IP协议有个头，这个头就存在这某些信息，代表着自己身份，之后的信息就按这身份的协议去解析。这里就用一个很简单的 [Action]:[info, info, … , info] 来作为对象传输。[Action]就是一个头，后面连着消息，至于消息如何解析，就要看你自己协议的具体约定了。这里我提供一个很简陋的在资源4中，也就是 Version lab版 所遵守的协议。 服务端这里我们使用 socket 来编写。如果之前你没有接触过这方面，可能现在想知道手机怎么和电脑通讯？别急，先看看这个例子在电脑上怎么访问自己写的服务器。 演示很简单，就是一个简单的界面来开启服务，如果你是测试,可以先不编写界面，直接运行就开启服务 serverListener.start(); 之后在cmd telnet 中通过 127.0.0.1 这个 IP 访问端口 27777 。可以看到控制台输出 “haha”， 如果你的电脑没有 telnet 可以开启或者直接在浏览器中访问 127.0.0.1:27777. 效果一样。这是就代表有一个和服务器建立的连接。 从这里可以猜想，手机如果连接的是电脑的无线，也就是处于同一个局域网内的话，是不是也可以访问到浏览器。可以试试，手机连接电脑无线，那么通过什么访问端口呢？ 127.0.0.1？仔细思考就知道应该是行不通的，手机和电脑建立的连接走的是哪条线路呢？我们连的是无线，所以通过无线适配器和电脑建立连接，所以我们要访问电脑上的端口肯定是要经过这个适配器的。所以找到无线网络适配器的 IPv4, 就可以 通过 IPv4:27777 访问了。 下面解释一下代码。 1234567891011121314151617public class ServerListener extends Thread&#123; private ServerSocket serverSocket; @Override public void run() &#123; try &#123; serverSocket = new ServerSocket(27777, 27); while (true) &#123; Socket socket = serverSocket.accept(); System.out.println(\"haha\"); ChatSocket chatSocket = new ChatSocket(socket); chatSocket.start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以看到，这是一个死循环。只要不发生异常和手动关闭，这段代码是会一直运行下去的。其中 1Socket socket = serverSocket.accept(); 这一行是关键，代表的是没有 socket 接入的话，程序会一直阻塞在这句代码处，一旦有 socket 接入，则返回一个 socket ，由于一个服务器必然是有多个客户端连接的。所以我们给每个 socket 连接都分配一个线程并且开启线程，接着循环进入阻塞，直到有下一个连接建立，重复上述步骤。这就是这段代码的运行状态。 现在假设有线程已经开启了。怎么接收数据？ socket 是以流的形式传输数据。所以只要获取流，再将这个流进行相关操作就行了。下面解释一下我们的主要代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ChatSocket extends Thread&#123; private Socket socket; private String message = null; private BufferedReader bufferedReader; private BufferedWriter bufferedWriter; public ChatSocket(Socket s) &#123; this.socket = s; try &#123; this.bufferedReader = new BufferedReader(new InputStreamReader(s.getInputStream(), \"UTF-8\")); this.bufferedWriter = new BufferedWriter(new OutputStreamWriter(s.getOutputStream(), \"UTF-8\")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; try &#123; String line = null; while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; message += line; &#125; else &#123; delMessage(message); line = null; message = null; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; MainWindow.getMainWindow().setShowMsg(this.username + \" login out !\"); MainWindow.getMainWindow().removeOfflineUsers(this.username); ChatManager.getChatManager().remove(socketMsg); bufferedWriter.close(); bufferedReader.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 首先定义一个 BufferedReader 和 BufferedWriter ，作用是接受客户端的数据和向客户端发送数据。很好记，Reader 对于自己来说就是读取别处的数据，Writer 是向目标对象写数据。所以 BufferedReader 是接受客户端的数据，BufferedWriter 是向客户端发送数据。 那么如何获取呢？ 在构造函数中可以看到这两句 12this.bufferedReader = new BufferedReader(new InputStreamReader(s.getInputStream(), \"UTF-8\"));this.bufferedWriter = new BufferedWriter(new OutputStreamWriter(s.getOutputStream(), \"UTF-8\")); 可以一起写也可以分开。如下： 123456// 从 socket 获取输入流InputStream inputStream = s.getInputStream();// 将位流通过 “UTF-8” 的格式读取为字符流InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");// 将字符流放入 Buffer。方便使用BufferedReader bufferedReader = new BufferedReader(inputStreamReader); 多想想整个数据的传输过程就很明朗了。有点像 OSI 的那个七层模型，一层一层封装与解封装。 上面只是获取到了流，并没有进行数据读写操作。开始下面介绍读取流中的数据。 12345678910String line = null;while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; message += line; &#125; else &#123; delMessage(message); line = null; message = null; &#125;&#125; 看着有点乱。。再看一下下面的吧。 1234567891011121314public void sendMsg(String msg) &#123; try &#123; while (socket == null) ; if (bufferedWriter != null) &#123; System.out.println(\"send :\" + msg); bufferedWriter.write(msg + \"\\n\"); bufferedWriter.flush(); bufferedWriter.write(\"-1\\n\"); bufferedWriter.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 可以清楚的看到，发送消息之后后面会加一个 “-1” 作为消息的终止符，也就是接接收方在接收到 -1 时，说明前面的数据是作为一整个信息的，将数据传出进行处理。接着清空继续接收接下来的消息，循环往复。可以看到 bufferedReader 这个流只要不关闭，这个会永远循环下去。 好了消息的发送和接收都基本算是处理好了，接下来就是数据处理，数据处理必然是要依赖协议的。所以依赖协议自己实现如下的函数。 123456789101112131415161718192021222324public void delMessage(String msg) &#123; if (msg != null) &#123; String action = getAction(msg); switch(action) &#123; case \"LOGIN\": &#123; dealLogin(msg); break; &#125; case \"REGISTER\": &#123; dealRegister(msg); break; &#125; case \"DRESSUP\": &#123; dealDressUp(msg); break; &#125; case \"GETDRESSUP\": &#123; dealGetDressUp(msg); break; &#125; case \"PROFILE\": &#123; dealProfile(msg); break; &#125; case \"GETPROFILE\": &#123; dealGetProfile(msg); break; &#125; case \"GETFRIENDLIST\": &#123; dealGetFriendList(msg); break; &#125; case \"GETGROUPLIST\": &#123; dealGetGroupList(msg); break; &#125; case \"GETFRIENDPROFILE\": &#123; dealGetFriendProfile(msg); break; &#125; case \"STATE\": &#123; dealState(msg); break; &#125; case \"CHATMSG\": &#123; dealChatMsg(msg); break; &#125; case \"USERLIST\": &#123; dealUserList(msg); break; &#125; case \"ADDFRIEND\": &#123; dealAddFriend(msg); break; &#125; case \"GROUPMEMBERLIST\": &#123; dealGroupMemberList(msg); break; &#125; case \"ADDGROUP\": &#123; dealAddGroup(msg); break; &#125; case \"GETALLGROUPLIST\": &#123; dealGetAllGroupList(msg); break;&#125; default : dealError(); break; &#125; &#125;&#125; 服务端的线程是随连接数的增加而增加，所以创建一个线程管理的类（ChatManager）就有必要了，这样我们可以轻松的对消息进行跨进程转发（聊天）。 1234567891011121314151617181920212223242526272829303132333435public class ChatManager &#123; private ChatManager()&#123;&#125;; List&lt;SocketMsg&gt; socketList = new ArrayList&lt;&gt;(); private static final ChatManager chatManager = new ChatManager(); public static ChatManager getChatManager() &#123; return chatManager; &#125; public void add(SocketMsg cs) &#123; socketList.add(cs); &#125; public void remove(SocketMsg cs) &#123; socketList.remove(cs); &#125; &#125;public class SocketMsg &#123; private ChatSocket chatSocket; private String username; public SocketMsg(ChatSocket chatSocket, String username) &#123; this.chatSocket = chatSocket; this.username = username; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public ChatSocket getChatSocket() &#123; return chatSocket; &#125; public void setChatSocket(ChatSocket chatSocket) &#123; this.chatSocket = chatSocket; &#125;&#125; 就是这么简单。 服务端基本就讲到这里。细心的人会发现我们的接收消息和发送消息是不在同一个线程中的，稍微思考思考对客户端的代码编写有好处。 客户端在不考虑信息处理的情况下客户端仿照服务端很容易写出接受发送流的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758server/ServerManager.javapublic class ServerManager extends Thread &#123; private static final String IP = \"192.168.191.1\"; private Socket socket; private String message = null; private BufferedReader bufferedReader; private BufferedWriter bufferedWriter; public static ServerManager getServerManager() &#123; return serverManager; &#125; private ServerManager() &#123; &#125; public void run() &#123; try &#123; socket = new Socket(IP, 27777); bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\")); bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), \"UTF-8\")); String m = null; String line; while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; m += line; &#125; else &#123; Log.d(\"TAG\", \"receive : \" + m); if (ParaseData.getAction(m).equals(\"GETCHATMSG\")) &#123; receiveChatMsg.delChatMsg(m); &#125; else &#123; message = m; &#125; m = null; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bufferedWriter.close(); bufferedReader.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void sendMessage(Context context, String msg) &#123; try &#123; while (socket == null) ; if (bufferedWriter != null) &#123; bufferedWriter.write(msg + \"\\n\"); bufferedWriter.flush(); bufferedWriter.write(\"-1\\n\"); bufferedWriter.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码是不是很熟悉？基本和服务端没什么变化，因为毕竟这是要和服务端建立连接的。 可以看到这是一个线程，所以从哪里开启这个线程呢？我是在这里： 12345678AtyLoginOrRegister.javapublic class AtyLoginOrRegister extends AppCompatActivity implements View.OnClickListener &#123; private ServerManager serverManager = ServerManager.getServerManager(); private void initViews() &#123; serverManager.start(); &#125;&#125; 下面就是进行数据传输处理了，我举两个例子。 数据传输 登录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AtyLoginOrRegister extends AppCompatActivity implements View.OnClickListener &#123; private void initViews() &#123; btnLogin.setOnClickListener(this); btnRegister.setOnClickListener(this); serverManager.start(); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_login: &#123; String username = etLoginUsername.getText().toString(); String password = etLoginPassword.getText().toString(); if (login(username, password)) &#123; serverManager.setUsername(username); Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); &#125; else &#123; etLoginUsername.setText(\"\"); etLoginPassword.setText(\"\"); &#125; break; &#125; case R.id.btn_register: &#123; Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); break; &#125; default: break; &#125; &#125; private boolean login(String username, String password) &#123; // check username and password whether legal if (username == null || username.length() &gt; 10 || password.length() &gt; 20) &#123; return false; &#125; // send msg to servers String msg = \"[LOGIN]:[\" + username + \", \" + password + \"]\"; serverManager.sendMessage(this, msg); // get msg from servers return String ack = serverManager.getMessage(); // deal msg if (ack == null) &#123; return false; &#125; serverManager.setMessage(null); String p = \"\\\\[ACKLOGIN\\\\]:\\\\[(.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(ack); return matcher.find() &amp;&amp; matcher.group(1).equals(\"1\"); &#125;&#125; 既然是登录，那么事件是发生在按钮的点击之后。下面我们来理一下登录过程： 点击登录按钮-&gt;获取登录信息-&gt;封装信息传输-&gt;服务端接收-&gt;解析信息-&gt;从服务器获取信息进行登录验证-&gt;返回验证结果-&gt;客户端获取数据-&gt;解析信息-&gt;进行登录状态调整 这就是一整个流程。下面就具体介绍。 点击登录按钮 1234case R.id.btn_login: &#123; String username = etLoginUsername.getText().toString(); String password = etLoginPassword.getText().toString();&#125; 获取登录信息 12String username = etLoginUsername.getText().toString();String password = etLoginPassword.getText().toString(); 封装信息传输 12345if (username == null || username.length() &gt; 10 || password.length() &gt; 20) &#123; return false;&#125;String msg = \"[LOGIN]:[\" + username + \", \" + password + \"]\";serverManager.sendMessage(this, msg); 服务端接收 1234567891011String line = null;while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; message += line; &#125; else &#123; delMessage(message); System.out.println(\"receive : \" + message); line = null; message = null; &#125;&#125; 解析信息 123456789String iusername = null;String iPassword = null;String p = \"\\\\[LOGIN\\\\]:\\\\[(.*), (.*)\\\\]\";Pattern pattern = Pattern.compile(p);Matcher matcher = pattern.matcher(msg);if (matcher.find()) &#123; iusername = matcher.group(1); iPassword = matcher.group(2);&#125; 从服务器获取信息进行登录验证 &amp;&amp; 返回验证结果 1234567891011121314151617String sql = \"SELECT password FROM USERS WHERE username = '\" + iusername + \"';\";try &#123; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql); if (resultSet.next() &amp;&amp; iPassword.equals(resultSet.getString(1)) ) &#123; sendMsg(\"[ACKLOGIN]:[1]\"); this.username = iusername; MainWindow.getMainWindow().setShowMsg(this.username + \" login in!\"); MainWindow.getMainWindow().addOnlineUsers(this.username); socketMsg = new SocketMsg(this, this.username); ChatManager.getChatManager().add(socketMsg); return ; &#125;&#125; catch (SQLException e) &#123; e.printStackTrace();&#125;sendMsg(\"[ACKLOGIN]:[0]\"); 客户端获取数据 1String ack = serverManager.getMessage(); 解析信息 12345678if (ack == null) &#123; return false;&#125;serverManager.setMessage(null);String p = \"\\\\[ACKLOGIN\\\\]:\\\\[(.*)\\\\]\";Pattern pattern = Pattern.compile(p);Matcher matcher = pattern.matcher(ack);return matcher.find() &amp;&amp; matcher.group(1).equals(\"1\"); 进行登录状态调整 123456789if (login(username, password)) &#123; serverManager.setUsername(username); Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish();&#125; else &#123; etLoginUsername.setText(\"\"); etLoginPassword.setText(\"\");&#125; 发送信息 流程一样只是处理消息的时候复杂一点，因为我们只为聊天设置一个协议。所以要提高信息的区分度而对数据进行的繁复操作是必须的。 发送： 1234567891011121314151617181920212223242526272829303132333435363738394041btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String content = myMsg.getText().toString(); if (!content.isEmpty()) &#123; ChatMsg msg = new ChatMsg(); msg.setContent(content); msg.setUsername(ServerManager.getServerManager().getUsername()); msg.setIconID(ServerManager.getServerManager().getIconID()); msg.setMyInfo(true); msg.setChatObj(chatObj); msg.setGroup(group.equals(\"0\") ? chatObj : \" \"); if (sendToChatObj(msg.getContent())) &#123; ChatMsg.chatMsgList.add(msg); chatMsgList.add(msg); myMsg.setText(\"\"); &#125; else &#123; Toast.makeText(AtyChatRoom.this, \"send failed\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125;);private boolean sendToChatObj(String content) &#123; String msg = \"[CHATMSG]:[\" + chatObj + \", \" + content + \", \" + ServerManager.getServerManager().getIconID() +\", Text]\"; ServerManager serverManager = ServerManager.getServerManager(); serverManager.sendMessage(this, msg); try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String ack = serverManager.getMessage(); if (ack == null) &#123; return false; &#125; String p = \"\\\\[ACKCHATMSG\\\\]:\\\\[(.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(ack); return matcher.find() &amp;&amp; matcher.group(1).equals(\"1\");&#125; 接收： 由于日后扩展可能不只是文本信息，所以在对聊天信息的处理上我们直接再建一个类。 1234567891011121314151617181920212223242526272829303132class ReceiveChatMsg &#123; void delChatMsg(String msg) &#123; String sendName = null; String content = null; String avatarID = null; String fileType = null; String group = null; ServerManager.getServerManager().setMessage(null); String p = \"\\\\[GETCHATMSG\\\\]:\\\\[(.*), (.*), (.*), (.*), (.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(msg); if (matcher.find()) &#123; sendName = matcher.group(1); content = matcher.group(2); avatarID = matcher.group(3); fileType = matcher.group(4); group = matcher.group(5); ChatMsg chatMsg = new ChatMsg(); chatMsg.setMyInfo(false); chatMsg.setContent(content); chatMsg.setChatObj(sendName); chatMsg.setUsername(ServerManager.getServerManager().getUsername()); chatMsg.setGroup(group); chatMsg.setIconID(Integer.parseInt(avatarID)); AtyChatRoom.chatMsgList.add(chatMsg); ChatMsg.chatMsgList.add(chatMsg); &#125; &#125;&#125; 细节就不多说了，注意区分同一个对象发信息给你是通过群还是私人。 还有就是当聊天窗口关闭后在再次打开聊天信息怎么加载？大家自己想想。不同可以看代码或者留言。 下面看下服务器的数据转发代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void dealChatMsg(String msg) &#123; String chatObj = null; String content = null; String avatarID = null; String msgType = null; String p = \"\\\\[CHATMSG\\\\]:\\\\[(.*), (.*), (.*), (.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(msg); if (matcher.find()) &#123; chatObj = matcher.group(1); content = matcher.group(2); avatarID = matcher.group(3); msgType = matcher.group(4); &#125; else &#123; return; &#125; String out = null; String sqlGroup = \"SELECT * FROM GROUPS WHERE groupName = '\" + chatObj+ \"';\"; try &#123; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sqlGroup); // gruop chat if (resultSet.next()) &#123; // find all group members to send msg String sql = \"SELECT groupMemberName FROM GROUPINFO WHERE groupName = '\" + chatObj + \"';\"; resultSet = statement.executeQuery(sql); while (resultSet.next()) &#123; // if user is online , then send. for (SocketMsg SocketMsg : ChatManager.getChatManager().socketList) &#123; if (SocketMsg.getUsername().equals(resultSet.getString(1)) &amp;&amp; !SocketMsg.getUsername().equals(username)) &#123; out = \"[GETCHATMSG]:[\" + username + \", \" + content + \", \" + avatarID + \", Text, \" + chatObj + \"]\"; SocketMsg.getChatSocket().sendMsg(out); &#125; &#125; &#125; // private chat &#125; else &#123; for (SocketMsg socketManager : ChatManager.getChatManager().socketList) &#123; if (socketManager.getUsername().equals(chatObj)) &#123; out = \"[GETCHATMSG]:[\" + username + \", \" + content + \", \" + avatarID + \", Text, ]\"; socketManager.getChatSocket().sendMsg(out); &#125; &#125; &#125; out = \"[ACKCHATMSG]:[1]\"; sendMsg(out); &#125; catch (SQLException e) &#123; out = \"[ACKCHATMSG]:[0]\"; sendMsg(out); e.printStackTrace(); &#125;&#125; 其实逻辑不是很复杂，慢慢看很容易懂的。其他的实现自己慢慢摸索可以实现。不想再拖长篇幅了，看代码可能比我讲的效率更高，理解更加深刻。在这个过程中可能你会遇到一个小 Bug 卡了一天，但是每个人都是这么成长过来的，一起加油! 到这里目前的就算完了，这个系列 Blog 可能不会更新了。但是 GitHub 上会对代码继续更新的。此外这个 Lab 版还有很多 Bug 欢迎大家提建议，很希望和大家一起交流学习。 多谢阅读。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-3","date":"2017-04-14T05:00:00.000Z","path":"2017/04/14/ZZChatApp3/","text":"GitHub 实现一个类似QQ的社交聊天工具-3准备做好【ZZChatApp2】中的内容并且下载了实现一个类似QQ的社交聊天工具-1中的资料就可以开始下面的了 实现目标看演示效果就知道，这次主要的任务是实现两个界面，一个是 Dressup 选图片的，另一个是聊天界面。如果你对 RecyclerView 有一定认识了，可以自己自行编写 Dressup 界面。我们的聊天信息使用的是 listview ，尝试尽可能多的控件。好消息是这次 lab 之后基本的界面工作就完成了，下次 lab 我们开始进行网络编程。 实现过程 Profile 界面就不讲了，自己参照源码或者自己写，这里为了方便就直接把 username 作为 id 和 nickname 主要是为了后期数据库的建立不太麻烦，毕竟是个小练习。数据处理不是我们关注的重点，重点是整个开发流程。 Dressup实现 我的习惯是先写界面 123456789101112131415161718192021aty_dress_up.xml&lt;LinearLayout &gt; &lt;org.fitzeng.zzchat.view.TitleBar android:id=\"@+id/tb_dress_up\" &gt; &lt;/org.fitzeng.zzchat.view.TitleBar&gt; &lt;TextView android:text=\"Choose an avatar\" /&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_avatar\" &gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;TextView android:text=\"Choose a background\" /&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_background\" &gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;Button android:id=\"@+id/btn_save\" /&gt;&lt;/LinearLayout&gt; 布局很简单，接下来就是建一个Aty去加载布局。布局好了，这是应该是加载资源，而加载资源又不得不用到我们的适配器。所以先写适配器。 下面以加载 Avatar 为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859adapter/AdapterAvatar.javapublic class AdapterAvatar extends RecyclerView.Adapter&lt;AdapterAvatar.BaseViewHoder&gt;&#123; private List&lt;ImageMsg&gt; imageViews; private Context context; private LayoutInflater inflater; private static int selectedImageAvatar = 0; private List&lt;RelativeLayout&gt; imageContainer = new ArrayList&lt;&gt;(); private Drawable bgImageDrawable; @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public AdapterAvatar(Context context, List&lt;ImageMsg&gt; imageViews) &#123; this.context = context; this.imageViews = imageViews; this.inflater = LayoutInflater.from(context); selectedImageAvatar = 0; bgImageDrawable = context.getResources().getDrawable(R.drawable.bgimage, null); &#125; @Override public BaseViewHoder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = inflater.inflate(R.layout.choose_image, parent, false); return new BaseViewHoder(view); &#125; @Override public void onBindViewHolder(final BaseViewHoder holder, final int position) &#123; holder.imageView.setImageResource(imageViews.get(position).getImageID()); imageContainer.get(selectedImageAvatar).setBackground(bgImageDrawable); holder.imageView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (position != selectedImageAvatar) &#123; imageContainer.get(position).setBackground(bgImageDrawable); imageContainer.get(selectedImageAvatar).setBackgroundColor(0); selectedImageAvatar = position; &#125; &#125; &#125;); &#125; @Override public int getItemCount() &#123; return imageViews == null ? 0 : imageViews.size(); &#125; class BaseViewHoder extends RecyclerView.ViewHolder &#123; ImageView imageView; BaseViewHoder(View itemView) &#123; super(itemView); imageView = (ImageView) itemView.findViewById(R.id.image); RelativeLayout layout = (RelativeLayout) itemView.findViewById(R.id.imageContainer); imageContainer.add(layout); &#125; &#125;&#125; 代码很简洁，都是套路。唯一注意的一点是点击的逻辑处理。还有就是把图片资源（util/ImageManager）用一个类封装一下，和创建一个对象（util/ImageMsg）用来存储加载数据的信息。用起来就比较方便了。适配器好了，下面利用适配器把数据加载进 RecyclerView 。思路还是比较清晰的。 具体实现看代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)private void initViews() &#123; titleBar = (TitleBar) findViewById(R.id.tb_dress_up); rvAvatar = (RecyclerView) findViewById(R.id.rv_avatar); rvBackground = (RecyclerView) findViewById(R.id.rv_background); btnSave = (Button) findViewById(R.id.btn_save); addAvatarView(); titleBar.setTitleBarClickListetner(new TitleBar.titleBarClickListener() &#123; @Override public void leftButtonClick() &#123; finish(); &#125; @Override public void rightButtonClick() &#123; &#125; &#125;); btnSave.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(AtyDressUp.this, \"saved\", Toast.LENGTH_SHORT).show(); finish(); &#125; &#125;);&#125;private void addAvatarView() &#123; List&lt;ImageMsg&gt; imageMsgs = new ArrayList&lt;&gt;(); for (int anImagesAvatar : ImageManager.imagesAvatar) &#123; ImageMsg imagemsg = new ImageMsg(); imagemsg.setImageID(anImagesAvatar); imageMsgs.add(imagemsg); &#125; AdapterAvatar avatarAdapter = new AdapterAvatar(this, imageMsgs); LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false); rvAvatar.setLayoutManager(layoutManager); rvAvatar.setAdapter(avatarAdapter);&#125; 之后加载 Background 的代码自己写吧,这一部分就算完成了，不懂的可以参照源码。 聊天界面看过第一行代码的应该有点了解，大家可以先上网搜搜其他资源。 主要问题是怎么让消息自适应气泡。有一种图片时.9.png格式，至于如何制作，很简单。选中图片右键，在最下面的选项中有一个Create 9-Patch file…点击之后就会弹出界面，自己把要缩放的区域集中在黑线的交汇区域。 聊天界面布局如下，这里有一个Bug，下面会陈述。 1234567891011121314151617181920&lt;LinearLayout &gt; &lt;org.fitzeng.zzchat.view.TitleBar android:id=\"@+id/tb_chat_room\" &gt; &lt;/org.fitzeng.zzchat.view.TitleBar&gt; &lt;ScrollView &gt; &lt;LinearLayout &gt; &lt;ListView android:id=\"@+id/lv_chat_room\" &gt; &lt;/ListView&gt; &lt;LinearLayout &gt; &lt;Button android:text=\"emoji\" /&gt; &lt;Button android:text=\"draw\" /&gt; &lt;Button android:text=\"file\" /&gt; &lt;Button android:text=\"call\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout&gt; &lt;EditText android:id=\"@+id/myMsg\"/&gt; &lt;Button android:id=\"@+id/btnSend\"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 接下来就是消息界面的设计，也就是适配器加载的布局。一个头像，一个 username 一个内容。OK。但是要区分是自己发送的消息还是别人发送的消息。所以有两个布局。 这时我们要建立一个聊天信息的Msg 12345private boolean myInfo;private int iconID;private String username;private String content;private String chatObj; 数据什么的都贮备好了，下面进行是适配器的编写。由于 ListView 没有实现 ViewHolder 所以要自己实现。主要是为了视图缓存，减小视图加载时的资源消耗。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859adaptar/AdapterChatMsg.javapublic class AdapterChatMsg extends ArrayAdapter&lt;ChatMsg&gt; &#123; private LayoutInflater inflater; private List&lt;ChatMsg&gt; chatMsgs; public AdapterChatMsg(@NonNull Context context, @LayoutRes int resource, List&lt;ChatMsg&gt; chatMsgs) &#123; super(context, resource); this.inflater = LayoutInflater.from(context); this.chatMsgs = chatMsgs; &#125; @Override public int getCount() &#123; return chatMsgs.size(); &#125; @Nullable @Override public ChatMsg getItem(int position) &#123; return chatMsgs.get(position); &#125; @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; ChatMsg msg = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; assert msg != null; if (msg.isMyInfo()) &#123; view = inflater.inflate(R.layout.chat_me, parent, false); &#125; else &#123; view = inflater.inflate(R.layout.chat_other, parent, false); &#125; viewHolder = new ViewHolder(); viewHolder.icon = (ImageView) view.findViewById(R.id.icon); viewHolder.username = (TextView) view.findViewById(R.id.username); viewHolder.content = (TextView) view.findViewById(R.id.content); view.setTag(viewHolder); &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; viewHolder.icon.setImageResource(chatMsgs.get(position).getIconID()); viewHolder.username.setText(chatMsgs.get(position).getUsername()); viewHolder.content.setText(chatMsgs.get(position).getContent()); return view; &#125; private class ViewHolder &#123; ImageView icon; TextView username; TextView content; &#125;&#125; 其中通过 12345if (msg.isMyInfo()) &#123; view = inflater.inflate(R.layout.chat_me, parent, false);&#125; else &#123; view = inflater.inflate(R.layout.chat_other, parent, false);&#125; 来加载聊天左右视图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667AtyChatRoom.javapublic class AtyChatRoom extends AppCompatActivity&#123; private TitleBar titleBar; private ListView listView; private EditText myMsg; private Button btnSend; private List&lt;ChatMsg&gt; chatMsgList; private AdapterChatMsg adapterChatMsgList; private String chatObj; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getSupportActionBar().hide();// getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.aty_chat_room); getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE | WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);// AndroidBug5497Workaround.assistActivity(this); initViews(); &#125; private void initViews() &#123; titleBar = (TitleBar) findViewById(R.id.tb_chat_room); listView = (ListView) findViewById(R.id.lv_chat_room); myMsg = (EditText) findViewById(R.id.myMsg); btnSend = (Button) findViewById(R.id.btnSend); chatMsgList = new ArrayList&lt;&gt;(); chatObj = getIntent().getStringExtra(\"username\"); titleBar.setTitleText(chatObj); adapterChatMsgList = new AdapterChatMsg(AtyChatRoom.this, R.layout.chat_other, chatMsgList); listView.setAdapter(adapterChatMsgList); btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String content = myMsg.getText().toString(); if (!content.isEmpty()) &#123; ChatMsg msg = new ChatMsg(); msg.setContent(content); msg.setUsername(\"hello\"); msg.setIconID(R.drawable.avasterwe); msg.setMyInfo(true); msg.setChatObj(chatObj); chatMsgList.add(msg); myMsg.setText(\"\"); &#125; &#125; &#125;); titleBar.setTitleBarClickListetner(new TitleBar.titleBarClickListener() &#123; @Override public void leftButtonClick() &#123; finish(); &#125; @Override public void rightButtonClick() &#123; &#125; &#125;); &#125;&#125; 这次我把整个Aty都贴出来了，主要是为了说明一个Bug。点击输入框软键盘弹出时 TitleBar 会被顶上去。为了解决这个问题，在onCreate函数中，加 SOFT_INPUT_ADJUST_RESIZE ，但是在全屏下同时设置 SOFT_INPUT_ADJUST_RESIZE 这个属性，TitleBar 又会被顶上去。所以，在 Stack Overflow 有大神给出了解决方案。就是 util 多出的那个 AndroidBug5497Workaround.java 文件。讲道理在 setContentView() 之后添加一句 AndroidBug5497Workaround.assistActivity(this); 就可以解决。。。。。。但是。。。可能是我的手机太渣，还是没能实现效果。据说这个是适合市面上大部分手机的。。。希望在你的手机上能行，所以我就保留了这些文件。为了取舍，我只能不实现全屏了。。。日后找到好的解决方案会在github更新。 目前好像。。完了。。。。看着少，其实里面的有些东西是值得深究的。至于如何实现 Moments 和 Contacts 滑动的留给大家自己探索了。 感谢大家的耐心阅读和支持，再下次开始之前，希望你已经搭建好了本地服务器。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-2","date":"2017-04-14T04:00:00.000Z","path":"2017/04/14/ZZChatApp2/","text":"GitHub 实现一个类似QQ的社交聊天工具-2准备做好【ZZChatApp1】中的内容并且下载了实现一个类似QQ的社交聊天工具-1中的资料就可以开始下面的了 实现目标前面只是实现一个基本的框架，这次我们要往主界面里面添加内容，代码较多，最好自己看这篇文章时也参考我提供的第二阶段源码。主要练习的是自定义控件 实现过程 这次的文件比上次多了，所以文件管理和控件ID的命名不能太随意，这是要注意的一点。代码难度不高，只要命名好了，不写注释其实也能看懂的。 TitleBar在开始写三个页面和一个侧滑视图之前，我们先做个自定义控件。其实这此实验总共用到了两个，我在这只叙述复杂的那个，剩下的可以参考源码自己实现。在学习之前推荐观看慕课，时间不是很长，但是对理清思路视频讲解更直接。 设计属性 其实就是两个button加一个textView。属性设计如下 123456789101112131415161718values/atts.xml&lt;declare-styleable name=\"TitleBar\"&gt; &lt;attr name=\"titleText\" format=\"string\" /&gt; &lt;attr name=\"titleTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"titleTextColor\" format=\"color\" /&gt; &lt;attr name=\"titleBackground\" format=\"reference|color\" /&gt; &lt;attr name=\"leftText\" format=\"string\" /&gt; &lt;attr name=\"leftTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"leftTextColor\" format=\"color\" /&gt; &lt;attr name=\"leftBackground\" format=\"reference|color\" /&gt; &lt;attr name=\"rightText\" format=\"string\" /&gt; &lt;attr name=\"rightTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"rightTextColor\" format=\"color\" /&gt; &lt;attr name=\"rightBackground\" format=\"reference|color\" /&gt;&lt;/declare-styleable&gt; 绑定属性 可以根据前面设计的属性来判断需要哪些变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private Button btnLeft;private Button btnRight;private TextView tvTitle;private String leftText;private float leftTextSize;private int leftTextColor;private Drawable leftBackground;private String rightText;private float rightTextSize;private int rightTextColor;private Drawable rightBackground;private String titleText;private float titleTextSize;private int titleTextColor;private Drawable titleBackground;/** * @param attrs this is titlebar's attribute set for binding with widgets */private void findAttrs(AttributeSet attrs) &#123; TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TitleBar); leftText = typedArray.getString(R.styleable.TitleBar_leftText); leftTextSize = typedArray.getDimension(R.styleable.TitleBar_leftTextSize, 24); leftTextColor = typedArray.getColor(R.styleable.TitleBar_leftTextColor, 0); leftBackground = typedArray.getDrawable(R.styleable.TitleBar_leftBackground); titleText = typedArray.getString(R.styleable.TitleBar_titleText); titleTextSize = typedArray.getDimension(R.styleable.TitleBar_titleTextSize, 24); titleTextColor = typedArray.getColor(R.styleable.TitleBar_titleTextColor, 0); titleBackground = typedArray.getDrawable(R.styleable.TitleBar_titleBackground); rightText = typedArray.getString(R.styleable.TitleBar_rightText); rightTextSize = typedArray.getDimension(R.styleable.TitleBar_rightTextSize, 24); rightTextColor = typedArray.getColor(R.styleable.TitleBar_rightTextColor, 0); rightBackground = typedArray.getDrawable(R.styleable.TitleBar_rightBackground); typedArray.recycle();&#125;/** * Init titlebar's widgets */private void initViews() &#123; btnLeft = new Button(context); btnRight = new Button(context); tvTitle = new TextView(context); btnLeft.setText(leftText); btnLeft.setTextSize(leftTextSize); btnLeft.setTextColor(leftTextColor); btnLeft.setBackground(leftBackground); btnRight.setText(rightText); btnRight.setTextSize(rightTextSize); btnRight.setTextColor(rightTextColor); btnRight.setBackground(rightBackground); tvTitle.setText(titleText); tvTitle.setTextSize(titleTextSize); tvTitle.setTextColor(titleTextColor); tvTitle.setBackground(titleBackground); tvTitle.setGravity(Gravity.CENTER); setBackgroundColor(0xFF01AAFF);&#125;/** * Setting titlebar's layout */private void setTitleBarLayoutParams() &#123; btnLeft.setAllCaps(false); btnRight.setAllCaps(false); LayoutParams btnLeftLayoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); btnLeftLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT, TRUE); addView(btnLeft, btnLeftLayoutParams); LayoutParams btnRightLayoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); btnRightLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, TRUE); addView(btnRight, btnRightLayoutParams); LayoutParams titleLayoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT); titleLayoutParams.addRule(RelativeLayout.CENTER_IN_PARENT, TRUE); addView(tvTitle, titleLayoutParams);&#125; 其实从使用角度来说，可以理出一条我们为什么这么做的线。因为在 XML 中我们使用一般都是 android : layout_width = “match_parent”很明显 layout_width 可以看做一个 Key ，而 match_parent 是一个 Value.所以 findAttrs(AttributeSet attrs) 就是把之前设计属性是所能识别的 Key 的值取出来，也就是 “XXX” 中的 XXX 数据，但是仅仅取出数据并没有什么用，最终还是要把数据赋值到控件上去，数据才能显示我们想要的效果。所以 initViews() 便是做这件事的。接下来的 setTitleBarLayoutParams() 只是对里面控件的属性的一个约束。 对于 Key-Value 的理解，其实可以这样看，如果声明了一个 app:no_name=”12” 在 xml 中，而实际你并没有声明这个属性在 atts.xml 中，所以编译器知道的是找不到 Key ，而不是判定 Value 的对错。所以对于属性文件 atts.xml 就自然而然有了存在的意义。我理解为就是规范作用，而之后的值传递给 TextView 或者其他已有控件，就是之后的绑定属性值的操作就顺理成章了。 文笔不好，不知道讲清了没。。。大家还是好好看看前面推荐的视频和自己写一个小控件实现一下加深理解。 目前这个控件只是静态的，不能响应点击事件。可以参考之前的 Button 怎么实现的。一般 Button.setOnClickListener()所以可以在控件中加一个 setTitleBarClickListetner() 方法。接下来就是有点难度的了。Button 自己的点击事件响应其实是由自己在 onClick() 方法中实现自己的逻辑的。 所以此时自定义控件就要对外提供一个接口，让实现者自己定义自己的点击事件。讲到这估计差不多了，看看代码就理解了。 12345678910111213141516171819202122232425262728293031323334view/TitleBar.javaprivate titleBarClickListener listener;/** * implement click events */public interface titleBarClickListener &#123; // 这两个方法相当于 Button 的 onCLick() void leftButtonClick(); void rightButtonClick();&#125;// 类似于 Button 的setOnClickListener();public void setTitleBarClickListetner(titleBarClickListener listetner) &#123; this.listener = listetner;&#125;// 内部设置按钮点击监听private void setButtonClickListener() &#123; btnLeft.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.leftButtonClick(); &#125; &#125;); btnRight.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.rightButtonClick(); &#125; &#125;);&#125; 下面剩下的一个 PicAndTextBtn 大家可以自己实现，就是作为左侧滑动视图中的小控件，一个 ImageView 和 TextView组成的。 侧滑界面如果前面都写好了下面就使用上面的控件来写滑动界面，布局很简单。 12345678910111213141516171819202122232425262728&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;RelativeLayout&gt; &lt;LinearLayout&gt; &lt;LinearLayout&gt; &lt;ImageView/&gt; Avatar &lt;TextView/&gt; Username &lt;/LinearLayout&gt; &lt;TextView/&gt; Sign &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;Dress Up&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;Profile&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;/LinearLayout&gt; &lt;LinearLayout&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;setting&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;night&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 接下来就是实现其逻辑了，这次主要实现以下setting，dressup和profile下次实验实现。实现控件的点击，虽然这个点击事件是你们自己写的，为了后面的实验一致，推荐命名最好和我一致。。。虽然我的命名也很烂。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647view/LayoutSlide.javaprivate void initViews() &#123; this.addView(LayoutInflater.from(context).inflate(R.layout.layout_slide, null)); dressUp = (PicAndTextBtn) findViewById(R.id.patb_dressup); profile = (PicAndTextBtn) findViewById(R.id.patb_profile); setting = (PicAndTextBtn) findViewById(R.id.patb_setting); night = (PicAndTextBtn) findViewById(R.id.patb_night); dressUp.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, AtyDressUp.class); context.startActivity(intent); &#125; &#125;); profile.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, AtyProfile.class); context.startActivity(intent); &#125; &#125;); setting.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, AtySetting.class); context.startActivity(intent); &#125; &#125;); night.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; if (nightMode) &#123; findViewById(R.id.layout_slide).setBackgroundColor(0xff878787); nightMode = false; &#125; else &#123; findViewById(R.id.layout_slide).setBackgroundColor(0xffe9e9e9); nightMode = true; &#125; &#125; &#125;);&#125; setting 界面的布局就不贴代码了，很简单。只分析 java 代码，其实目前也很水，也就实现了一个 Guide View 是否播放的功能。但是在之前的 Welcome 页面中还要做一点小小的修改。大家可以试验不该会怎么样。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768AtySetting.javaprivate void initViews() &#123; titleBar = (TitleBar) findViewById(R.id.tb_setting); guide = (ImageView) findViewById(R.id.iv_setting_guide); password = (ImageView) findViewById(R.id.iv_setting_password); offline = (ImageView) findViewById(R.id.iv_setting_offline); guideMode = getSharedPreferences(\"zzchat\", MODE_PRIVATE).getBoolean(\"guide\", true); guide.setImageResource(guideMode ? R.drawable.btnselected : R.drawable.btnunselected); password.setImageResource(passwordMode ? R.drawable.btnselected : R.drawable.btnunselected); offline.setImageResource(offlineMode ? R.drawable.btnselected : R.drawable.btnunselected); guide.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (guideMode) &#123; guide.setImageResource(R.drawable.btnunselected); guideMode = false; &#125; else &#123; guide.setImageResource(R.drawable.btnselected); guideMode = true; &#125; &#125; &#125;); password.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (passwordMode) &#123; password.setImageResource(R.drawable.btnunselected); passwordMode = false; &#125; else &#123; password.setImageResource(R.drawable.btnselected); passwordMode = true; &#125; &#125; &#125;); offline.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (offlineMode) &#123; offline.setImageResource(R.drawable.btnunselected); offlineMode = false; &#125; else &#123; offline.setImageResource(R.drawable.btnselected); offlineMode = true; &#125; &#125; &#125;); titleBar.setTitleBarClickListetner(new TitleBar.titleBarClickListener() &#123; @Override public void leftButtonClick() &#123; SharedPreferences sharedPreferences = getSharedPreferences(\"zzchat\", MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putBoolean(\"guide\", guideMode); editor.apply(); finish(); &#125; @Override public void rightButtonClick() &#123; &#125; &#125;);&#125; night 功能也基本没有实现，留给大家完善了。。。 chats下面开始 Chat 页面的设计。同理后面的 Contact 和 Moment 也是和这个类似，大家参考源码可以把代码写了，当做练习。有些坑自己不踩不知道多深。 把 titleBar 引进来是很简单的。直接在主界面中加就是了。 实现 Chats 这个列表功能我们使用更加易用的 RecyclerView 下次实验实现的聊天界面我们可以试试 ListView。好了，都决定好了就开始写代码吧。 和前面一样，一个 RecyclerView 怎么加载数据？答案就是通过 Adapter ，问题又来了，那么加载的怎样的数据呢？所以现在目的很明确，就是设计数据 Item 布局是一个头像，一个Username, 一个签名 123456789item_user.xml&lt;LinearLayout&gt; &lt;ImageView android:id=\"@+id/iv_item_avatar\" /&gt; &lt;LinearLayout&gt; &lt;TextView android:id=\"@+id/tv_item_username\" /&gt; &lt;TextView android:id=\"@+id/tv_item_sign\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 有了布局，接下来就是自己构造适配器加载布局。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950adapter/AdapterUserItem.javapublic class AdapterUserItem extends RecyclerView.Adapter&lt;AdapterUserItem.BaseViewHolder&gt; &#123; private Context context; private List&lt;UserItemMsg&gt; userItemMsgList; public AdapterUserItem(Context context, List&lt;UserItemMsg&gt; userItemMsgList) &#123; this.context = context; this.userItemMsgList = userItemMsgList; &#125; @Override public BaseViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new BaseViewHolder(LayoutInflater.from(context).inflate(R.layout.item_user, parent, false)); &#125; @Override public void onBindViewHolder(BaseViewHolder holder, int position) &#123; holder.ivAvatar.setImageResource(userItemMsgList.get(position).getIconID()); holder.tvUsername.setText(userItemMsgList.get(position).getUsername()); holder.tvSign.setText(userItemMsgList.get(position).getSign()); &#125; @Override public int getItemCount() &#123; return (userItemMsgList == null ? 0 : userItemMsgList.size()); &#125; class BaseViewHolder extends RecyclerView.ViewHolder&#123; private ImageView ivAvatar; private TextView tvUsername; private TextView tvSign; BaseViewHolder(View itemView) &#123; super(itemView); ivAvatar = (ImageView) itemView.findViewById(R.id.iv_item_avatar); tvUsername = (TextView) itemView.findViewById(R.id.tv_item_username); tvSign = (TextView) itemView.findViewById(R.id.tv_item_sign); itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, tvUsername.getText().toString(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; &#125;&#125; 我把代码全贴上来了，其实这算是一个经常用的模板了吧。RecyclerView 内部自己实现了 ViewHolder 类，所以说使用方便。 下面就是比较有代表性的 recyclerView 代码实现，可以注意注意 setLayoutManager() 函数。 1234567891011private void initViews() &#123; context = getContext(); recyclerView = (RecyclerView) rootView.findViewById(R.id.chatsRecycleView); loadData(); adapterUserItem = new AdapterUserItem(context, userItemMsgList); recyclerView.setLayoutManager(new LinearLayoutManager(context)); recyclerView.setAdapter(adapterUserItem);&#125; 怕篇幅过多，细的知识点不会太陈述，主要是对整个一个 App 实现过程中思考的一个介绍，不会觉得自己无从下手。 。。。。。。。。好像篇幅有点长了，还没有涉及服务端就这么多了。。。剩下的效果大家可以按动图显示的自己实现，方法其实全概括了。 最后说下 TabHost 的一点东西 1234567891011121314151617181920tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; tabList.get(tab.getPosition()).setIcon(ImageManager.imageID[tab.getPosition() + 3]); tabLayout.setTabTextColors( ContextCompat.getColor(AtyMain.this, R.color.colorBlack), ContextCompat.getColor(AtyMain.this, R.color.colorBlue) ); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; tabList.get(tab.getPosition()).setIcon(ImageManager.imageID[tab.getPosition()]); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125;&#125;); 为什么要把下面的代码放在监听中执行，而不是在外面。大家可以做做实验，点击Tab和滑动ViewPager就能发现异同。 1234tabLayout.setTabTextColors( ContextCompat.getColor(AtyMain.this, R.color.colorBlack), ContextCompat.getColor(AtyMain.this, R.color.colorBlue)); 还有前面遗留的登录界面 Tab 上面的字母是大写，怎么解决？大家可以自己查资料，再看看我提供的源码。这次就这样，下次实现剩下的 DressUp，Profile 和聊天界面。再下次就是网络编程啦！","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-1","date":"2017-04-14T03:00:00.000Z","path":"2017/04/14/ZZChatApp1/","text":"GitHub 实现一个类似QQ的社交聊天工具-1准备 AndroidStudio 模拟器 资料 密码: jme4大家将图片复制到drawable供接下来的使用，部分图片源于网络，不做商业用途应该不算侵权吧。如果有，我会删除资源的。 实现目标按照最先开始的计划，我们只实现一个静态的ZZChat界面，考验的就是Android控件的基本知识。如果碰到没见到过的控件可以去Google看开发文档。 实现过程 在看到实现的设计下，我们最先想到的是有四的Activity（欢迎界面，引导页，登录注册，主界面），同时对应四个布局 修改Manifest12345678910111213141516171819AndroidManifest.xml&lt;application android:allowBackup=\"true\" android:icon=\"@drawable/icon\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".aty.AtyWelcome\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".aty.AtyGuide\" /&gt; &lt;activity android:name=\".aty.AtyLoginOrRegister\" /&gt; &lt;activity android:name=\".aty.AtyMain\" /&gt;&lt;/application&gt; 欢迎界面 全屏 1234onCreate()getSupportActionBar().hide();getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); 引导界面只在首次开启时显示 123456789101112131415161718192021222324252627282930313233AtyWelcome.javaprivate void initLoad() &#123; SharedPreferences sharedPreferences = getSharedPreferences(\"zzchat\", MODE_PRIVATE); boolean welcome = sharedPreferences.getBoolean(\"welcome\", true); if (!welcome) &#123; handler.sendEmptyMessageDelayed(GO_HOME, DELAY); &#125; else &#123; handler.sendEmptyMessageDelayed(GO_GUIDE, DELAY); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putBoolean(\"welcome\", false); editor.apply(); &#125;&#125;Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case GO_GUIDE: &#123; goGuide(); break; &#125; case GO_HOME: &#123; goHome(); break; &#125; default: break; &#125; &#125;&#125;; 引导页引导页我们使用一个ViewPager实现，如果之前不熟悉的可以看我的另一个利用ViewPager做的轮播图。 布局 相信看了前面动图的效果对布局实现应该是有底了 123456789101112131415161718192021222324252627282930313233343536373839404142434445aty_guide.xml&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/vp_guide\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;LinearLayout android:orientation=\"horizontal\" android:layout_centerHorizontal=\"true\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"20dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;ImageView android:id=\"@+id/iv_indicator_dot1\" android:src=\"@drawable/selected\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_width=\"10dp\" android:layout_height=\"10dp\" /&gt; &lt;ImageView android:id=\"@+id/iv_indicator_dot2\" android:src=\"@drawable/unselected\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_width=\"10dp\" android:layout_height=\"10dp\" /&gt; &lt;ImageView android:id=\"@+id/iv_indicator_dot3\" android:src=\"@drawable/unselected\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_width=\"10dp\" android:layout_height=\"10dp\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 适配布局 到这了，如何实现ViewPager加载布局就是我们现在应该想的事了。目前可以最先想到和做到的是实现三个加载的布局，为了方便我们只使用一个ImageView来实现，同理其他三个页面也是类似，第三个多加一个Enter入口进入主页。 1234567891011guide_page1.xml&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:src=\"@drawable/shot2\" android:scaleType=\"centerCrop\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; 适配器 现在的情况是有了布局和资源页面，怎么把资源页面加载进布局，这时就要用到Adapter了，也就是适配器。新建一个adapter资源包新建一个AdapterGuideViewPager类继承PagerAdapter 123456789101112131415161718192021222324252627282930313233adapter/AdapterGuideViewPager.javapublic class public class AdapterGuideViewPager extends PagerAdapter&#123; private Context context; private List&lt;View&gt; viewList; public AdapterGuideViewPager(Context context, List&lt;View&gt; viewList) &#123; this.context = context; this.viewList = viewList; &#125; @Override public int getCount() &#123; return viewList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return (view == object); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(viewList.get(position)); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(viewList.get(position)); return viewList.get(position); &#125;&#125; 一定要注意getCount()和isViewFromObject()函数的实现。 有了适配器，只要给adapter添加之前的guide视图作为资源，再给viewPager设置资源适配器。基本效果就实现了。 12345678910111213141516171819202122232425262728293031AtyGuide.javaprivate void initViews() &#123; // load view final LayoutInflater inflater = LayoutInflater.from(this); viewList = new ArrayList&lt;&gt;(); viewList.add(inflater.inflate(R.layout.guide_page1, null)); viewList.add(inflater.inflate(R.layout.guide_page2, null)); viewList.add(inflater.inflate(R.layout.guide_page3, null)); // bind Id with imageView for (int i = 0; i &lt; indicatorDotIds.length; i++) &#123; imageViews[i] = (ImageView) findViewById(indicatorDotIds[i]); &#125; adapterGuideViewPager = new AdapterGuideViewPager(this, viewList); viewPager = (ViewPager) findViewById(R.id.vp_guide); viewPager.setAdapter(adapterGuideViewPager); viewPager.addOnPageChangeListener(this); btnToMain = (Button) (viewList.get(2)).findViewById(R.id.btn_to_main); btnToMain.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(AtyGuide.this, AtyLoginOrRegister.class); startActivity(intent); &#125; &#125;);&#125; 指示器实现 当前页面是第几页，要给用户一个比较明显的提示，可以利用两个不同颜色的小圆点。但是要想知道移动的改变就要实现监听事件 实现onPageSelected()方法就可以了。 1234567891011AtyGuide.javapublic void onPageSelected(int position) &#123; for (int i = 0; i &lt; indicatorDotIds.length; i++) &#123; if (i != position) &#123; imageViews[i].setImageResource(R.drawable.unselected); &#125; else &#123; imageViews[i].setImageResource(R.drawable.selected); &#125; &#125;&#125; 登录注册 界面 这里可以自己设计，我使用TabHost实现，学习使用不同控件，不过布局值得主页的是ID的设置，自己可以试试如果不这样会出现什么效果。 12345678910111213141516&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:background=\"@drawable/shot1\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TabHost android:id=\"@+id/tabHost\"&gt; &lt;TabWidget android:id=\"@android:id/tabs\"&gt; &lt;/TabWidget&gt; &lt;FrameLayout android:id=\"@android:id/tabcontent\"&gt; &lt;LinearLayout&gt; Login Layout &lt;/LinearLayout&gt; &lt;LinearLayout&gt; Register Layout &lt;/LinearLayout&gt; &lt;/FrameLayout&gt; &lt;/TabHost&gt;&lt;/RelativeLayout&gt; 跳转 目前还没进行数据处理，所以我们直接跳转进入界面 123456789101112131415161718192021222324252627282930313233343536373839private void initViews() &#123; tabHost = (TabHost) findViewById(R.id.tabHost); btnLogin = (Button) findViewById(R.id.btn_login); etLoginUsername = (EditText) findViewById(R.id.et_login_username); etLoginPassword = (EditText) findViewById(R.id.et_login_password); btnRegister = (Button) findViewById(R.id.btn_register); etRegisterUsername = (EditText) findViewById(R.id.et_register_username); etRegisterPassword = (EditText) findViewById(R.id.et_register_password); etInsurePassword = (EditText) findViewById(R.id.et_insure_password); tabHost.setup(); tabHost.addTab(tabHost.newTabSpec(\"Login\").setIndicator(\"Login\").setContent(R.id.layout_login)); tabHost.addTab(tabHost.newTabSpec(\"Register\").setIndicator(\"Register\").setContent(R.id.layout_register)); btnLogin.setOnClickListener(this); btnRegister.setOnClickListener(this);&#125;@Overridepublic void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_login: &#123; Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); break; &#125; case R.id.btn_register: &#123; Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); break; &#125; default: break; &#125;&#125; 添加依赖库 如果你遇到上面的bug，说明到现在我们的TabHost是无法工作的，因为缺少一个依赖库。compile ‘com.android.support:design:2x.x.x’ 添加方式是在File-&gt;Project Structure 在弹出的窗口中选择app,之后操作看图此时需要重新Gradle, 这时可能一个错误在build.gradle。按Alt + Enter, 选择忽略就好。 12345678910dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.1' testCompile 'junit:junit:4.12' compile 'com.android.support:design:26.0.0-alpha1'&#125; 主界面之前的页面基本实现，那么主界面如何实现，参考QQ，为了避免控件上的使用难度，我们直接用google提供的DrawerLayout写代码之前先理清思路，这个主界面明显是包含三个页面加一个侧换页面，也就是四个。新建一个view资源文件，创建四个视图类接着新建四个布局供类加载 布局 这个布局有要主页的地方侧滑视图要设置android:layout_gravity=”start” 属性。DrawerLayout最好为根容器推荐如下布局最外层就是DrawerLayout，中间只有一个主内容和一个侧滑布局。你要添加的内容全部在主内容中实现。 这里采用ViewPager + TabLayout 来实现，不熟悉的点这里 123456789101112aty_main.xml&lt;android.support.v4.widget.DrawerLayout &gt; &lt;LinearLayout &gt; &lt;android.support.v4.view.ViewPager &gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;android.support.design.widget.TabLayout &gt; &lt;/android.support.design.widget.TabLayout&gt; &lt;/LinearLayout&gt; &lt;org.fitzeng.zzchat.view.SlideLayout android:layout_gravity=\"start\"&gt;侧换视图&lt;/org.fitzeng.zzchat.view.SlideLayout&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 加载页面 以Chats为例 123456&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:background=\"#09868f\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/LinearLayout&gt; 1234567891011public class LayoutChats extends Fragment &#123; private View rootView; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; rootView = inflater.inflate(R.layout.layout_chats, container, false); return rootView; &#125;&#125; 十分简单，看代码就能懂 之前已经使用了侧滑视图，接下来的三个视图分别对应加载进了三个类。如何将这些视图加载进主界面，前面已经说过如何加载经viewPager了，这里也是一样的。实现一个适配器。 适配器 和前面不一样的是前面直接inflate一个布局进资源列表，而这里是把布局加载进类中了。所以实现方式稍微有点不一样, 这样对布局的内容控制性个人认为较好,因为布局中的子控件逻辑可以在各自的类中实现。看代码就懂了。 123456789101112131415161718192021222324adapter/AdapterMainViewPager.javapublic class AdapterMainViewPager extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); public AdapterMainViewPager(FragmentManager fragmentManager) &#123; super(fragmentManager); &#125; public void addFragment(Fragment fragment) &#123; fragmentList.add(fragment); &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentList.size(); &#125;&#125; 123456789101112131415161718192021222324private void initViews() &#123; drawable = (DrawerLayout) findViewById(R.id.dl_main); viewPager = (ViewPager) findViewById(R.id.vp_main); tabLayout = (TabLayout) findViewById(R.id.tl_main); tabList = new ArrayList&lt;&gt;(); AdapterMainViewPager adapter = new AdapterMainViewPager(getSupportFragmentManager()); adapter.addFragment(new LayoutChats()); adapter.addFragment(new LayoutContacts()); adapter.addFragment(new LayoutMoments()); viewPager.setAdapter(adapter); tabLayout.setupWithViewPager(viewPager); tabList.add(tabLayout.getTabAt(0)); tabList.add(tabLayout.getTabAt(1)); tabList.add(tabLayout.getTabAt(2)); tabList.get(0).setIcon(R.drawable.icon).setText(\"Chats\"); tabList.get(1).setIcon(R.drawable.icon).setText(\"Contacts\"); tabList.get(2).setIcon(R.drawable.icon).setText(\"Moments\");&#125; 代码比较简洁，不知道意思的可以按ctrl点击类名或方法名看源码注释。 到这里基本的效果实现了，不清楚了可以参考阶段性源码。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-0","date":"2017-04-14T02:00:00.000Z","path":"2017/04/14/ZZChatApp0/","text":"GitHub 实现一个类似QQ的社交聊天工具-0 实现效果 原因由于在间间断断的学Android，所以学的知识比较杂，想做个小项目来复习复习。所以之前在课后十天左右的时间完成了一个刚刚具备聊天功能的App，由于这几天拼命的搜寻资料，发现网上并没有一个完整的开发过程的文章。平时也就是看看大牛们的博客学习，现在觉得也要多和大家分享自己学到的知识，共同进步。可能你在这学不到技术深度的东西，但是说不定可以扩展你的技术广度。 目标人群推荐给正处于Android进阶的人群，想写一个App却不知道如何开始。希望我的这些文字对你能有帮助。最少基本过了一遍《第一行代码》，读过《Android群英传》就更好了。由于我是以一个遇到问题解决问题的视角来写的，所以基本会让你的开发过程思路清晰，知道这么做的目的和好处。同时这也是一个开始完全不知道怎么写到实现基本功能的心路历程描述。所以应该会有点价值吧。当然涉及的东西确实有点多，所以不可能一一叙述，欢迎大家留言讨论。 知识数据库相关知识（基本的增删改查）Java（Java可视化界面编程，Socket网络通信）Android 软件Android: Android Studio本地服务器搭建： XAMPP（Apache + MySQL）服务器界面：Eclipse JavaEE 实现思路在电脑上利用Apache + MySQL搭建一个供服务端访问的数据库，有了数据库，就要写一个服务端在电脑上运行，读写数据库数据。开启一个线程一直检测是否有客户发送连接请求，有的话accept，并且给这个连接的用户开一个单独线程供客户端进行通讯。而客户端发送请求给服务器，所以客户端要有一个Action来激活发送请求，也就是我们的点击滑动等事件。但是同时又要接受来自服务端的数据，所以我们要使客户端的Action操作和与服务端通讯分别用两个不同的线程管理。不知道我讲没讲请，下面用图来描述一下。 实现程度由于学业较忙，博客只会更新到目前程度，接下的过程大家可以定制属于你自己的聊天软件。逻辑框架完成度：60%界面设计完成度：40%已实现：服务端，通讯协议，登录，聊天。接下来的功能基本可以根据上面的功能实现。 建议1 使用真机调试2 在整个过程中一定会遇到各种问题 Log + 断点 -&gt; StackOverflow 基本可以解决初学者99%的问题。 开始学习实现一个类似QQ的社交聊天工具-1实现一个类似QQ的社交聊天工具-2实现一个类似QQ的社交聊天工具-3实现一个类似QQ的社交聊天工具-4 最后这个App我会继续在GitHub完善，Blog是否更看课余时间，欢迎大家关注。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个表情键盘控件","date":"2017-04-07T05:00:00.000Z","path":"2017/04/07/EmojiKeyboard/","text":"GitHub 任务目的 学习android控件的封装，viewPager的使用，以及SpannableString对文字加图片的处理 任务描述 能进行表情的输入，删除 表情大于一页，且可以翻页 表情键盘和输入法键盘的弹出逻辑要正确 结果演示 实现过程 一开始，其实也不知道从哪里下手，开始在网上浏览了一些博客，大概有了解决的思路，下面就从我个人的解决思路出发实现一个一个小功能。 step 1: 设计总体布局 采用LinearLayout基本上是上(textView)中(func Bar)下(keyboard)的设计，为了方便控制，keyboard的布局采用自定义，布局代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;org.fitzeng.emojikeyboard.simpleemojikeyboard.SimpleEmojiEditLayout android:id=\"@+id/etSimpleEmojiEdit\" android:hint=\"@string/typeing_something_here\" android:maxLines=\"30\" android:textSize=\"24sp\" android:gravity=\"top\" android:background=\"@null\" android:layout_margin=\"8dp\" android:layout_weight=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" /&gt;&lt;RelativeLayout android:background=\"@color/colorPrimary\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\"&gt; &lt;ImageView android:id=\"@+id/touchIcon\" android:src=\"@mipmap/ic_launcher\" android:layout_centerInParent=\"true\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:contentDescription=\"@string/an_icon_button\" /&gt; &lt;ImageView android:id=\"@+id/btnDelete\" android:src=\"@drawable/icon_delete_normal\" android:layout_alignParentRight=\"true\" android:layout_centerVertical=\"true\" android:layout_width=\"wrap_content\" android:layout_height=\"@dimen/dp40\" android:contentDescription=\"@string/delete\" /&gt;&lt;/RelativeLayout&gt;&lt;org.fitzeng.emojikeyboard.simpleemojikeyboard.SimpleEmojiKeyboardLayout android:id=\"@+id/simpleEmojiKeyboardLayout\" android:visibility=\"gone\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\"&gt;&lt;/org.fitzeng.emojikeyboard.simpleemojikeyboard.SimpleEmojiKeyboardLayout&gt; step 2：大概实现布局控件 设计好控件，就进行实现，通过对func Bar的设计，实现键盘的收缩功能。 1234567891011121314151617181920212223242526272829303132// Click icon to make keyboard hide or appeartouchIcon.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (simpleEmojiKeyboardLayout.getVisibility() == View.GONE) &#123; simpleEmojiKeyboardLayout.setVisibility(View.VISIBLE); simpleEmojiKeyboardLayout.slipUp(); &#125; else &#123; simpleEmojiKeyboardLayout.setVisibility(View.GONE); &#125; &#125;&#125;);// Make keyboard appear when click to editsimpleEmojiEditLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (simpleEmojiKeyboardLayout.getVisibility() == View.GONE) &#123; simpleEmojiKeyboardLayout.slipUp(); simpleEmojiKeyboardLayout.setVisibility(View.VISIBLE); &#125; &#125;&#125;);/** * keyboard slip out */public void slipUp() &#123; LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) this.getLayoutParams(); layoutParams.height = (int) (getMeasuredWidth() * 0.7); this.setLayoutParams(layoutParams);&#125; step 3: 封装表情加入keyboard 将emoji封装成一个对象 1234567891011121314151617181920212223242526public class Smile &#123; private int resId; private String info; public Smile(int resId, String info) &#123; this.resId = resId; this.info = info; &#125; public int getResId() &#123; return resId; &#125; public void setResId(int resId) &#123; this.resId = resId; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125;&#125; 为了方便管理，把表情资源都添加进一个Manager类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class EmojiManager &#123; private static List&lt;Smile&gt; smileList; private static Context context; public EmojiManager(Context context) &#123; this.context = context; &#125; public static List&lt;Smile&gt; getSmileList() &#123; if(smileList==null)&#123; smileList=new ArrayList&lt;&gt;(); smileList.add(new Smile(R.drawable.emotion_1001,\"[e]1001[/e]\")); smileList.add(new Smile(R.drawable.emotion_1002,\"[e]1002[/e]\")); smileList.add(new Smile(R.drawable.emotion_1003,\"[e]1003[/e]\")); smileList.add(new Smile(R.drawable.emotion_1004,\"[e]1004[/e]\")); smileList.add(new Smile(R.drawable.emotion_1005,\"[e]1005[/e]\")); smileList.add(new Smile(R.drawable.emotion_1006,\"[e]1006[/e]\")); smileList.add(new Smile(R.drawable.emotion_1007,\"[e]1007[/e]\")); smileList.add(new Smile(R.drawable.emotion_1008,\"[e]1008[/e]\")); smileList.add(new Smile(R.drawable.emotion_1009,\"[e]1009[/e]\")); smileList.add(new Smile(R.drawable.emotion_1010,\"[e]1010[/e]\")); smileList.add(new Smile(R.drawable.emotion_1011,\"[e]1011[/e]\")); smileList.add(new Smile(R.drawable.emotion_1012,\"[e]1012[/e]\")); smileList.add(new Smile(R.drawable.emotion_1013,\"[e]1013[/e]\")); smileList.add(new Smile(R.drawable.emotion_1014,\"[e]1014[/e]\")); smileList.add(new Smile(R.drawable.emotion_1015,\"[e]1015[/e]\")); smileList.add(new Smile(R.drawable.emotion_1016,\"[e]1016[/e]\")); smileList.add(new Smile(R.drawable.emotion_1017,\"[e]1017[/e]\")); smileList.add(new Smile(R.drawable.emotion_1018,\"[e]1018[/e]\")); smileList.add(new Smile(R.drawable.emotion_1019,\"[e]1019[/e]\")); smileList.add(new Smile(R.drawable.emotion_1020,\"[e]1020[/e]\")); smileList.add(new Smile(R.drawable.emotion_1021,\"[e]1021[/e]\")); smileList.add(new Smile(R.drawable.emotion_1022,\"[e]1022[/e]\")); smileList.add(new Smile(R.drawable.emotion_1023,\"[e]1023[/e]\")); smileList.add(new Smile(R.drawable.emotion_1024,\"[e]1024[/e]\")); smileList.add(new Smile(R.drawable.emotion_1025,\"[e]1025[/e]\")); smileList.add(new Smile(R.drawable.emotion_1026,\"[e]1026[/e]\")); smileList.add(new Smile(R.drawable.emotion_1027,\"[e]1027[/e]\")); smileList.add(new Smile(R.drawable.emotion_1028,\"[e]1028[/e]\")); smileList.add(new Smile(R.drawable.emotion_1029,\"[e]1029[/e]\")); smileList.add(new Smile(R.drawable.emotion_1030,\"[e]1030[/e]\")); smileList.add(new Smile(R.drawable.emotion_1031,\"[e]1031[/e]\")); smileList.add(new Smile(R.drawable.emotion_1032,\"[e]1032[/e]\")); smileList.add(new Smile(R.drawable.emotion_1033,\"[e]1033[/e]\")); smileList.add(new Smile(R.drawable.emotion_1034,\"[e]1034[/e]\")); smileList.add(new Smile(R.drawable.emotion_1035,\"[e]1035[/e]\")); smileList.add(new Smile(R.drawable.emotion_1036,\"[e]1036[/e]\")); smileList.add(new Smile(R.drawable.emotion_1037,\"[e]1037[/e]\")); smileList.add(new Smile(R.drawable.emotion_1038,\"[e]1038[/e]\")); smileList.add(new Smile(R.drawable.emotion_1039,\"[e]1039[/e]\")); smileList.add(new Smile(R.drawable.emotion_1040,\"[e]1040[/e]\")); smileList.add(new Smile(R.drawable.emotion_1041,\"[e]1041[/e]\")); smileList.add(new Smile(R.drawable.emotion_1042,\"[e]1042[/e]\")); smileList.add(new Smile(R.drawable.emotion_1043,\"[e]1043[/e]\")); smileList.add(new Smile(R.drawable.emotion_1044,\"[e]1044[/e]\")); smileList.add(new Smile(R.drawable.emotion_1045,\"[e]1045[/e]\")); smileList.add(new Smile(R.drawable.emotion_1046,\"[e]1046[/e]\")); smileList.add(new Smile(R.drawable.emotion_1047,\"[e]1047[/e]\")); smileList.add(new Smile(R.drawable.emotion_1048,\"[e]1048[/e]\")); smileList.add(new Smile(R.drawable.emotion_1049,\"[e]1049[/e]\")); smileList.add(new Smile(R.drawable.emotion_1050,\"[e]1050[/e]\")); smileList.add(new Smile(R.drawable.emotion_1051,\"[e]1051[/e]\")); smileList.add(new Smile(R.drawable.emotion_1052,\"[e]1052[/e]\")); smileList.add(new Smile(R.drawable.emotion_1053,\"[e]1053[/e]\")); smileList.add(new Smile(R.drawable.emotion_1054,\"[e]1054[/e]\")); smileList.add(new Smile(R.drawable.emotion_1055,\"[e]1055[/e]\")); smileList.add(new Smile(R.drawable.emotion_1056,\"[e]1056[/e]\")); smileList.add(new Smile(R.drawable.emotion_1057,\"[e]1057[/e]\")); smileList.add(new Smile(R.drawable.emotion_1058,\"[e]1058[/e]\")); smileList.add(new Smile(R.drawable.emotion_1059,\"[e]1059[/e]\")); smileList.add(new Smile(R.drawable.emotion_1060,\"[e]1060[/e]\")); smileList.add(new Smile(R.drawable.emotion_1061,\"[e]1061[/e]\")); smileList.add(new Smile(R.drawable.emotion_1062,\"[e]1062[/e]\")); smileList.add(new Smile(R.drawable.emotion_1063,\"[e]1063[/e]\")); smileList.add(new Smile(R.drawable.emotion_1064,\"[e]1064[/e]\")); smileList.add(new Smile(R.drawable.emotion_1065,\"[e]1065[/e]\")); smileList.add(new Smile(R.drawable.emotion_1066,\"[e]1066[/e]\")); smileList.add(new Smile(R.drawable.emotion_1067,\"[e]1067[/e]\")); smileList.add(new Smile(R.drawable.emotion_1068,\"[e]1068[/e]\")); smileList.add(new Smile(R.drawable.emotion_1069,\"[e]1069[/e]\")); smileList.add(new Smile(R.drawable.emotion_1070,\"[e]1070[/e]\")); smileList.add(new Smile(R.drawable.emotion_1071,\"[e]1071[/e]\")); smileList.add(new Smile(R.drawable.emotion_1072,\"[e]1072[/e]\")); smileList.add(new Smile(R.drawable.emotion_1073,\"[e]1073[/e]\")); smileList.add(new Smile(R.drawable.emotion_1074,\"[e]1074[/e]\")); smileList.add(new Smile(R.drawable.emotion_1075,\"[e]1075[/e]\")); smileList.add(new Smile(R.drawable.emotion_1076,\"[e]1076[/e]\")); smileList.add(new Smile(R.drawable.emotion_1077,\"[e]1077[/e]\")); smileList.add(new Smile(R.drawable.emotion_1078,\"[e]1078[/e]\")); smileList.add(new Smile(R.drawable.emotion_1079,\"[e]1079[/e]\")); smileList.add(new Smile(R.drawable.emotion_1080,\"[e]1080[/e]\")); smileList.add(new Smile(R.drawable.emotion_1081,\"[e]1081[/e]\")); smileList.add(new Smile(R.drawable.emotion_1082,\"[e]1082[/e]\")); smileList.add(new Smile(R.drawable.emotion_1083,\"[e]1083[/e]\")); smileList.add(new Smile(R.drawable.emotion_1084,\"[e]1084[/e]\")); smileList.add(new Smile(R.drawable.emotion_1085,\"[e]1085[/e]\")); smileList.add(new Smile(R.drawable.emotion_1086,\"[e]1086[/e]\")); smileList.add(new Smile(R.drawable.emotion_1087,\"[e]1087[/e]\")); smileList.add(new Smile(R.drawable.emotion_1088,\"[e]1088[/e]\")); smileList.add(new Smile(R.drawable.emotion_1089,\"[e]1089[/e]\")); smileList.add(new Smile(R.drawable.emotion_1090,\"[e]1090[/e]\")); smileList.add(new Smile(R.drawable.emotion_1091,\"[e]1091[/e]\")); smileList.add(new Smile(R.drawable.emotion_1092,\"[e]1092[/e]\")); smileList.add(new Smile(R.drawable.emotion_1093,\"[e]1093[/e]\")); smileList.add(new Smile(R.drawable.emotion_1094,\"[e]1094[/e]\")); smileList.add(new Smile(R.drawable.emotion_1095,\"[e]1095[/e]\")); &#125; return smileList; &#125;&#125; 表情资源基本准备好，现在要实现的功能是把表情添加进keyboard。可以通过GridView添加资源。 但是在添加资源时，需要借助适配器，所以还要自己构造一个表情的适配器，基本实现是将一个imageView(表情)添加进LinearLayout作为一个布局元素。 12345678910111213141516171819202122232425262728293031323334353637383940public class EmojiAdapter extends BaseAdapter &#123; private static List&lt;Smile&gt; smileList; private static Context context; public EmojiAdapter(Context context, List&lt;Smile&gt; list) &#123; EmojiAdapter.context = context; smileList = list; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ImageView imageView = new ImageView(context); imageView.setImageResource(smileList.get(position).getResId()); LinearLayout layout = new LinearLayout(context); layout.setGravity(Gravity.CENTER); layout.addView(imageView, dp2px(28), dp2px(28 + 20)); return layout; &#125; private static int dp2px(float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; @Override public int getCount() &#123; return smileList.size(); &#125; @Override public Object getItem(int position) &#123; return smileList.get(position); &#125; @Override public long getItemId(int position) &#123; return smileList.get(position).getResId(); &#125;&#125; 构造好了资源适配器就可以往GridView中加载资源了，再把GridView添加进键盘这个视图 1234567891011private void addEmojiToKeyBoard() &#123; gridView.setNumColumns(8); gridView.setId(R.id.gridView); EmojiAdapter adapter = new EmojiAdapter(getContext(), EmojiManager.getSmileList()); gridView.setAdapter(adapter);&#125;private void init() &#123; addEmojiToKeyBoard(); this.addView(gridView, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);&#125; step 4：实现编辑相关功能模块 现在基本UI已经实现，接下来就是实现对emoji的点击事件监听，从而实现在EditText中显示表情元素 表情的添加，在主Activity实现监听 参考: 在EditText中添加QQ表情 android EditText获取光标位置并插入字符删除字符 1234567891011121314151617181920212223// Called by click an emojigridView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; // Calc lineHeight for ensure icon size int lineHeight = simpleEmojiEditLayout.getLineHeight(); // Create a bitmap Bitmap bitmap = BitmapFactory.decodeResource(getResources(), (int) id); // Set width and height bitmap = Bitmap.createScaledBitmap(bitmap, lineHeight - 10, lineHeight - 10, true); // ImageSpan imageSpan = new ImageSpan(SimpleEmojiKeyboardActivity.this, bitmap); SpannableString spannableString = new SpannableString(\"e\"); spannableString.setSpan(imageSpan, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); // Get texts from textView content = simpleEmojiEditLayout.getText(); // Get cursor location location = simpleEmojiEditLayout.getSelectionStart(); // Insert text content.insert(location, spannableString); &#125;&#125;); 接下来实现func Bar的delete功能 123456789101112btndelete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; content = simpleEmojiEditLayout.getText(); location = simpleEmojiEditLayout.getSelectionStart(); if (location != 0) &#123; content.delete(location - 1, location); &#125; else &#123; Toast.makeText(SimpleEmojiKeyboardActivity.this, \"Nothing to delete\", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;); 到这一个简单的表情键盘就实现了，其中还有很多小bug需要优化，最后把文件名列出来熟悉下这个过程。 emoji Smile EmojiManager EmojiAdapter SimpleEmojiKeyboard SimpleEmojiEditLayout SimpleEmojiKeyboardLayout SimpleEmojiKeyboardActivity 推荐阅读： Android 软键盘和emoji表情切换方案，和微信几乎一样的体验 The handler for the keyboard and panel layout conflict in Android 有机会要写一个更加完善的^_^ Tips: 作为一个Android小白，自然有很多不知道不理解的地方。如果文中有错或者有哪些值得改进的地方，欢迎大家提意见，我很开心能和大家一起交流学习，共同进步。 多谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"实现一个自动无线循环轮播图","date":"2017-04-07T04:00:00.000Z","path":"2017/04/07/SlideShow/","text":"GitHub 任务描述 每隔3秒轮播图自动滚动触摸改轮播图的时候，轮播图停止自动滚动轮播图能够循环滚动，并且第一幅图向左滚动的效果和其他图片滚动的效果要求一致。同理，最后一幅图向右滚动的效果也要求和其他图片的效果一致demo的轮播图至少包含3幅图 实现效果 实现过程 界面设计 首先要知道我们的UI界面是怎么样的，此处的设计如下图所示 代码： 1234567891011121314151617&lt;android.support.v4.view.ViewPager android:id=\"@+id/vpWallpaper\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;LinearLayout android:id=\"@+id/dotLayout\" android:gravity=\"center\" android:orientation=\"horizontal\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"28dp\" android:layout_centerInParent=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\"&gt;&lt;/LinearLayout&gt; 绘制UI(先设计滚动的页面，再设计指示器) 要给ViewPager添加图片，就要设置适配器和资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Set ViewPager Fragment */public static class ViewPagerFragment extends Fragment &#123; private ImageView image; private int id; public ViewPagerFragment(int id) &#123; this.id = id; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_adapter, container, false); image = (ImageView) rootView.findViewById(R.id.image); image.setImageResource(id); return rootView; &#125;&#125;// fragement layout(fragment_adapter)&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:id=\"@+id/image\" android:scaleType=\"fitXY\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:contentDescription=\"@string/image\" /&gt;&lt;/LinearLayout&gt;/** * Set ViewPager Adapter */private class ViewPagerAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); // Add pages to ViewPager private void addPage(Fragment fragment) &#123; fragmentList.add(fragment); &#125; ViewPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentList.size(); &#125;&#125; 添加资源 123456789101112131415161718private static final int[] srcId = &#123; R.drawable.pic0, R.drawable.pic1, R.drawable.pic2, R.drawable.pic3, R.drawable.pic4, R.drawable.pic5, R.drawable.pic6&#125;;ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager());// Add Fragmentsfor (int i = 0; i &lt; 7; i++) &#123; ViewPagerFragment fragment = new ViewPagerFragment(srcId[i]); adapter.addPage(fragment);&#125;viewPager.setAdapter(adapter); 设置循环效果 这里就是难点，要想实现两端的平缓循环滚动可以在两端添加一个cache page，[ 0 ( 1 2 3 4 0) 1]，只显示（）中的页，但是一旦出现cache page立马进行跳转。这样就能实现循环。接下来就是设置计时器了。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Set page change timer */@RequiresApi(api = Build.VERSION_CODES.KITKAT)private void setTimer() &#123; timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; handler.sendEmptyMessage(viewPager.getCurrentItem()); &#125; &#125;, 2000, 2000);&#125;private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 1: case 2: case 3: case 4: case 5: &#123; viewPager.setCurrentItem(msg.what + 1, true); break; &#125; // To make start or end slip smoothly case 0: &#123; viewPager.setCurrentItem(5, false); viewPager.setCurrentItem(6, true); break; &#125; case 6: &#123; viewPager.setCurrentItem(1, false); viewPager.setCurrentItem(2, true); break; &#125; default: break; &#125; &#125;&#125;; 设置平缓的滑动效果但是这种效果不能满足要求,我们可以设计一个滑动延时 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Set Duration */@RequiresApi(api = Build.VERSION_CODES.KITKAT)private void setDuration() &#123; try &#123; Field field = ViewPager.class.getDeclaredField(\"mScroller\"); field.setAccessible(true); FixSpeedScroller scroller = new FixSpeedScroller(this, new AccelerateInterpolator()); scroller.setDuration(500); field.set(viewPager, scroller); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125;/** * Set scroller duration, make it smoothly */class FixSpeedScroller extends Scroller &#123; private int _duration = 1000; FixSpeedScroller(Context context, Interpolator interpolator) &#123; super(context, interpolator); &#125; @Override public void startScroll(int startX, int startY, int dx, int dy) &#123; super.startScroll(startX, startY, dx, dy, _duration); &#125; @Override public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; super.startScroll(startX, startY, dx, dy, _duration); &#125; public void setDuration(int duration) &#123; _duration = duration; &#125;&#125; 基本效果就已经实现了，但是如果有触摸事件发生，我们要另行处理 添加点击监听 123456789101112131415161718viewPager.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; // Cancel the timer if (timer != null) &#123; timer.cancel(); timer = null; &#125; // when slip out cache view(page0, page6), set an another same page instantly if (viewPager.getCurrentItem() == 0) &#123; viewPager.setCurrentItem(5, false); &#125; if (viewPager.getCurrentItem() == 6) &#123; viewPager.setCurrentItem(1, false); &#125; return false; &#125;&#125;); 在滑动监听中恢复计时 12345678910111213141516171819viewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @RequiresApi(api = Build.VERSION_CODES.KITKAT) @Override public void onPageSelected(int position) &#123; &#125; @RequiresApi(api = Build.VERSION_CODES.KITKAT) @Override public void onPageScrollStateChanged(int state) &#123; // if this page was showed by figure slip, then set timer to continue auto slip for next page if (timer == null) &#123; setTimer(); &#125; &#125;&#125;); ViewPager的效果已经实现。下面开始实现指示器 指示器UI 利用两张图片实现选中和没选中效果，每张图片添加进一个LinearLayout，把所有的LinearLayout排列经另一个LinearLayout就可以实现效果 值得注意的是，在添加视图时，要加判断 123if (viewSelected.getParent() != null) &#123; ((ViewGroup) viewSelected.getParent()).removeView(viewSelected);&#125; 否则在有父布局的情况下添加不进别的视图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Create a dot view for an select view * @return view */private View createViewSelected() &#123; LinearLayout view = new LinearLayout(this); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(10, 0, 10, 0); view.setLayoutParams(lp); ImageView imageView = new ImageView(this); imageView.setImageResource(R.drawable.dot_selected); imageView.setLayoutParams(new LinearLayout.LayoutParams(30, 30)); imageView.setScaleType(ImageView.ScaleType.FIT_XY); view.addView(imageView); return view;&#125;/** * Create a dot view for an unselected view * @return view */private View createViewUnselected() &#123; LinearLayout view = new LinearLayout(this); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(10, 0, 10, 0); view.setLayoutParams(lp); ImageView imageView = new ImageView(this); imageView.setImageResource(R.drawable.dot_unselect); imageView.setLayoutParams(new LinearLayout.LayoutParams(30, 30)); imageView.setScaleType(ImageView.ScaleType.FIT_XY); view.addView(imageView); return view;&#125;/** * Refresh the Dot View when sliped * @param selectId current Id */private void refreshDotView(int selectId) &#123; dotLayout.removeAllViews(); for (int i = 1; i &lt; 6; i++) &#123; if (selectId != i) &#123; View viewUnselect = createViewUnselected(); if (viewUnselect.getParent() != null) &#123; ((ViewGroup) viewUnselect.getParent()).removeView(viewUnselect); &#125; dotLayout.addView(viewUnselect); &#125; else &#123; View viewSelected = createViewSelected(); if (viewSelected.getParent() != null) &#123; ((ViewGroup) viewSelected.getParent()).removeView(viewSelected); &#125; dotLayout.addView(viewSelected); &#125; &#125;&#125; 实现指示器功能 UI实现了之后就是实现指示功能就是直接在PageChange监听处加码就可以了，逻辑很简单，不过注意在恶劣环境下有可能会滑到cache page，这是传入的page ID要进行相应的变换 123456789101112131415161718192021222324252627282930313233// Delay to change dotviewTimer timer = new Timer();timer.schedule(new TimerTask() &#123; @Override public void run() &#123; handler.sendEmptyMessage(DOT_VIEW_CHANGE_SELECTED); &#125;&#125;, 500);// Refresh the dotView when page was loadedcase DOT_VIEW_CHANGE_SELECTED: int currentId = viewPager.getCurrentItem(); switch (currentId) &#123; case 0: &#123; refreshDotView(5); break; &#125; case 1: case 2: case 3: case 4: case 5: &#123; refreshDotView(currentId); break; &#125; case 6: &#123; refreshDotView(1); break; &#125; default: break; &#125; onCreate()调用顺序如下 12345678910public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_wallpaper); init(); listener(); setTimer(); setDuration();&#125; 不足不足比较多，在极端的操作下不流畅，比如在设置的延时中滑动次数过多会造成切换不自然，在手指滑动时更好的做法是直接监听手机的移动速度进行相关图片的移动。还有就是耗内存，内存溢出的话，可以自己在Manifest文件加两句代码 12android:hardwareAccelerated=\"false\"android:largeHeap=\"true\"","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"自定义滑动删除列表","date":"2017-04-07T03:00:00.000Z","path":"2017/04/07/SlideDeleteList/","text":"GitHub 任务描述 实现一个可以滑动删除的ListView列表，列表中的每一行可以通过从左向右滑动显示出删除按钮，点击该按钮之后删除该行 实现效果 实现过程 最开始还是要设计layout，这决定着你的代码写法。 layout activity_listview listitem content_view menu_view 我们可以把每一个Item设为一个布局控件，也就是listitem 1234567891011121314151617&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\"&gt; &lt;LinearLayout android:id=\"@+id/content\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/menu\" android:orientation=\"horizontal\" android:layout_width=\"80dp\" android:layout_height=\"match_parent\" &gt; &lt;/LinearLayout&gt;&lt;/merge&gt; 接着分别连个布局设置content和menu 12345678910111213141516171819202122232425262728content_view&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/textView\" android:text=\"@string/init_text\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:gravity=\"center_vertical\" android:layout_marginLeft=\"20dp\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt;menu_view&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/delete\" android:text=\"@string/delete\" android:textAllCaps=\"false\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:background=\"@color/colorAccent\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; 接下来就很清楚了。利用listview添加控件listitem作为适配器的布局。 ViewHolder缓存加载 避免重复加载控件，采用缓存机制是比较合理的下面我们看看adapter的getView() 1234567891011121314151617181920212223242526272829303132333435363738394041public View getView(final int position, View convertView, ViewGroup parent) &#123; ViewHolder holder; SlideItemView slideItemView = (SlideItemView) convertView; if (convertView == null) &#123; // get content and menu view View contentView = inflater.inflate(R.layout.content_view, null); View menuView = inflater.inflate(R.layout.menu_view, null); // add content and menu to slideItemView slideItemView = new SlideItemView(context); slideItemView.setContentView(contentView); slideItemView.setMenuView(menuView); // setting widgets holder = new ViewHolder(contentView, menuView); // setting slide listener slideItemView.setOnSlideListener((SlideItemView.OnSlideListener) context); slideItemView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; // init widgets ItemMsg itemMsg = itemMsgList.get(position); itemMsg.setSlideItemView(slideItemView); itemMsg.getSlideItemView().shrink(); holder.text.setText(itemMsg.getContent()); holder.btnDel.setText(R.string.delete); holder.btnDel.setOnClickListener((View.OnClickListener) context); return slideItemView;&#125;private final class ViewHolder &#123; TextView text; Button btnDel; ViewHolder(View content, View menu) &#123; text = (TextView) content.findViewById(R.id.textView); btnDel = (Button) menu.findViewById(R.id.delete); &#125;&#125; 代码基本都有注释，逻辑比较清晰，主要是对适配器的控件初始化。注意返回的是slideItemView，同时也设置了监听，所以此处是加载两个布局（content,menu）合成一个slideItemView，这样便于以后的布局更改。也方便视图的添加和控件的监测。 构造slideItemView 部分函数 12345678910111213141516private void initView() &#123; Context context = getContext(); scroller = new Scroller(context); // inflate layout View.inflate(context, R.layout.listitem, this); contentView = (LinearLayout) findViewById(R.id.content); menuView = (LinearLayout) findViewById(R.id.menu);&#125;public void setContentView(View content) &#123; contentView.addView(content);&#125;public void setMenuView(View menu) &#123; menuView.addView(menu);&#125; 滑动监听 这个才是重点难点代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public boolean onTouchEvent(MotionEvent event) &#123; // Get event start coordinate int x = (int) event.getX(); int y = (int) event.getY(); int scrollX = getScrollX(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; // if another event unfinished, then finished if (!scroller.isFinished()) &#123; scroller.abortAnimation(); &#125; // get menu width btnWidth = menuView.getMeasuredWidth(); if (onSlideListener != null) &#123; onSlideListener.onSlide(this, OnSlideListener.STATUS_SLIDE_SCROLL); &#125; // represent the event was handled or consumed, see the resource code return true; &#125; case MotionEvent.ACTION_MOVE: &#123; // get offset int offsetX = x - lastX; int offsetY = y - lastY; // if offsetX miner than offsetY or offsetY more than 20, then cancel this event if (offsetY &gt; 20) &#123; break; &#125; int newScrollX = scrollX - offsetX; if (offsetX != 0) &#123; if (newScrollX &lt; 0) &#123; newScrollX = 0; &#125; else if (newScrollX &gt; btnWidth)&#123; newScrollX = btnWidth; &#125; scrollTo(newScrollX, 0); &#125; break; &#125; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: &#123; int newScroll = 0; // more than half of button width, scroll out. otherwise scroll in. if (scrollX - btnWidth * 0.7 &gt; 0) &#123; newScroll = btnWidth; &#125; smoothScrollTo(newScroll); // set item slide status if (onSlideListener != null) &#123; onSlideListener.onSlide(this, newScroll == 0 ? OnSlideListener.STATUS_SLIDE_OFF : OnSlideListener.STATUS_SLIDE_ON); &#125; break; &#125; &#125; lastX = x; lastY = y; return super.onTouchEvent(event);&#125;private void smoothScrollTo(int x) &#123; int scrollX = getScrollX(); int offsetX = x - scrollX; scroller.startScroll(scrollX, 0, offsetX, 0, Math.abs(offsetX)); invalidate();&#125;@Overridepublic void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; scrollTo(scroller.getCurrX(), scroller.getCurrY()); postInvalidate(); &#125;&#125;public void shrink() &#123; if (getScaleX() != 0) &#123; this.smoothScrollTo(0); &#125;&#125; 参考 列表滑动删除效果 Android触摸屏事件派发机制详解与源码分析一(View篇) android中的dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent 后两篇主要是讲Android中的事件分发，也就是为什么在MotionEvent.ACTION_DOWN中return true才能实现滑动效果。看了源码我们知道true代表这个控件的函数消耗这个事件，不会再分发，所以我们后面的处理事件的代码才能够执行。 设置接口 123456789101112131415161718192021222324interface OnSlideListener &#123; int STATUS_SLIDE_OFF = 0; int STATUS_SLIDE_ON = 1; int STATUS_SLIDE_SCROLL = 2; void onSlide(View view, int status);&#125;public void setOnSlideListener(OnSlideListener onSlideListener) &#123; this.onSlideListener = onSlideListener;&#125;@Overridepublic void onSlide(View view, int status) &#123; // if last slide item is on, close it if (mLastSlideViewWithStatusOn != null &amp;&amp; mLastSlideViewWithStatusOn != view) &#123; mLastSlideViewWithStatusOn.shrink(); &#125; // if a new item slide out, mark it if (status == STATUS_SLIDE_ON) &#123; mLastSlideViewWithStatusOn = (SlideItemView) view; &#125;&#125; 这个接口的主要目的是对这个ListView中Item的管理，保证当前只有一个侧滑出来。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"实现一个TAB布局","date":"2017-04-07T02:30:00.000Z","path":"2017/04/07/TabLayout/","text":"GitHub 任务描述 实现常见的标签tab，并且点击tab跳转至对应页面实现页面滑动效果 实现效果 TabLayout + ViewPager（GIF） 实现过程 绘制页面 12345678910111213141516171819&lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPager\" android:scrollbars=\"none\" android:layout_weight=\"8\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;android.support.design.widget.TabLayout android:id=\"@+id/tabLayout\" android:layout_weight=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" app:tabGravity=\"fill\" app:tabIndicatorHeight=\"0dp\" app:tabMode=\"fixed\" app:tabSelectedTextColor=\"#FF4081\" app:tabTextColor=\"#000\"&gt;&lt;/android.support.design.widget.TabLayout&gt; 需要在配置文件中添加 compile ‘com.android.support:design:23.2.0’ 准备Adapter 1234567891011121314151617181920212223242526272829class ViewPagerAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); private List&lt;String&gt; fragmentTitleList = new ArrayList&lt;&gt;(); ViewPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; void addPage(Fragment fragment, String title) &#123; fragmentList.add(fragment); fragmentTitleList.add(title); &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentTitleList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return fragmentTitleList.get(position); &#125;&#125; 准备Fragment布局 1234567891011121314151617181920public class ViewPagerFragment extends Fragment &#123; private String content; public ViewPagerFragment(String content) &#123; this.content = content; &#125; public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_view_pager, container, false); TextView tvContent = (TextView) rootView.findViewById(R.id.tvContent); tvContent.setText(content); return rootView; &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125;&#125; 12345678&lt;TextView android:id=\"@+id/tvContent\" android:textSize=\"30sp\" android:hint=\"@string/default_text\" android:layout_gravity=\"center\" android:textAlignment=\"center\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 为了方便，此处所有Fragment共用一个 初始化布局 123456789101112131415161718192021222324252627/** * Init Layout, Load Fragments and draw Layouts. */private void initLayout() &#123; viewPager = (ViewPager) findViewById(R.id.viewPager); tabLayout = (TabLayout) findViewById(R.id.tabLayout); ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager()); // Add Fragments for (int i = 0; i &lt; 4; i++) &#123; adapter.addPage(new ViewPagerFragment(\"PAGE\" + i), \"PAGE\" + i); &#125; viewPager.setAdapter(adapter); // Connect TabLayout and ViewPage tabLayout.setupWithViewPager(viewPager); // Draw Tab View for (int i = 0; i &lt; 4; i++) &#123; tabListView.add(tabLayout.getTabAt(i)); if (i == 0) &#123; tabListView.get(i).setIcon(R.mipmap.selected_icon); &#125; else &#123; tabListView.get(i).setIcon(R.mipmap.ic_launcher); &#125; tabListView.get(i).setText(\"PAGE\" + i); &#125;&#125; 设置监听 123456789101112131415161718192021222324/** * Setting Tab Click Listener */private void initEvents() &#123; tabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; // Called when the tab was selected tabListView.get(tab.getPosition()).setIcon(R.mipmap.selected_icon); viewPager.setCurrentItem(tab.getPosition()); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; // Called when a tab from selected switch to unselected tabListView.get(tab.getPosition()).setIcon(R.mipmap.ic_launcher); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; // Called when a tab selected more than twice consecutively &#125; &#125;);&#125; 不足 利用控件已有的性质，基本的Tab切换已经实现。但是没有自己手动实现滑动等控件的效果。实现方式有很多种，以后来补充。 Tips: 作为一个Android小白，自然有很多不知道不理解的地方。如果文中有错或者有哪些值得改进的地方，欢迎大家提意见，我很开心能和大家一起交流学习，共同进步。 多谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"复现ANR","date":"2017-04-07T02:00:00.000Z","path":"2017/04/07/RecurrentANR/","text":"GitHub 任务描述写出不少于3种常见ANR错误的Android代码 主线程复现ANR BroadcastReceiver复现ANR Service复现ANR 1.什么是ANR? ANR(Application Not Responding),应用程序无响应. 参考ANR完全解析 2.ANR的三种类型 KeyDispatchTimeout(5 seconds) 主要类型按键或触摸事件在特定时间内无响应 BroadcastTimeout(10 seconds) BroadcastReceiver在特定时间内无法处理完成 ServiceTimeout(20 seconds) 小概率类型 Service在特定的时间内无法处理完成 3.复现ANRI 主线程复现ANR 代码 1234567891011121314/** * Recurrent ANR in main Thread */private void mainThreadANR() &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"MainThreadANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(20 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(\"MainThreadANR\", \"mainThreadANR() Done\");&#125; 结果 II BroadcastReceiver复现ANR 代码 1234567891011121314public class BroadcastANR extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"BroadcastANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(80 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; III Service复现ANR 代码 1234567891011121314151617181920public class ServiceANR extends Service &#123; @Override public void onCreate() &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"ServiceANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(60 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 4.避免ANR要想避免ANR，首先要分析为什么会发生ANR，主要是在一些不能耗时操作的函数中处理代码的时间过长，所以把耗时长的程序写入其他子进程中就可以避免。ANR机制以及问题分析写的很详细。 首先我们看看Log 12345678MainThreadANR: I/MainThreadANR: myLooper=Looper (main, tid 1) &#123;13467e36&#125;; mainLooper=Looper (main, tid 1) &#123;13467e36&#125;BroadcastANR:I/BroadcastANR: myLooper=Looper (main, tid 1) &#123;33c6137&#125;; mainLooper=Looper (main, tid 1) &#123;33c6137&#125;ServiceANR:I/ServiceANR: myLooper=Looper (main, tid 1) &#123;303e756a&#125;; mainLooper=Looper (main, tid 1) &#123;303e756a&#125; 前面的三个ANR都有一个特点，那就是当前的线程都是主线程，细心点会发现其实还有一句丢帧Log打印 1Skipped 1204 frames! The application may be doing too much work on its main thread. 我实现下通过在主线程中创建一个新线程的方法来避免ANR 代码 1234567891011121314151617181920/** * Deal ANR in main Thread */private void mainThreadNotANR() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"MainThreadNotANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(20 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(\"MainThreadNotANR\", \"Thread Run() Done\"); &#125; &#125;).start(); Log.i(\"MainThreadNotANR\", \"mainThreadNotANR() Done\");&#125; 下面我们来对比下和主线程中直接处理的Log有什么不同 12345678910111213141516MainThreadNotANR:点击按钮MainThreadNotANRI/MainThreadNotANR: mainThreadNotANR() DoneI/MainThreadNotANR: myLooper=null; mainLooper=Looper (main, tid 1) &#123;303e756a&#125;I/MainThreadNotANR: ThreadRun() DoneW/art: Suspending all threads took: 6.032msMainThreadANR:点击按钮MainThreadANRI/MainThreadANR: myLooper=Looper (main, tid 1) &#123;303e756a&#125;; mainLooper=Looper (main, tid 1) &#123;303e756a&#125;I/MainThreadANR: mainThreadANR() Done再多次点击按钮MainThreadANRI/Choreographer: Skipped 1200 frames! The application may be doing too much work on its main thread.I/MainThreadANR: myLooper=Looper (main, tid 1) &#123;303e756a&#125;; mainLooper=Looper (main, tid 1) &#123;303e756a&#125;I/art: Thread[5,tid=2037,WaitingInMainSignalCatcherLoop,Thread*=0xef70d400,peer=0x12c00080,&quot;Signal Catcher&quot;]: reacting to signal 3I/art: Wrote stack traces to &apos;/data/anr/traces.txt&apos; 从Log中可以看出MainThreadNotANR中先打印mainThreadNotANR() Done后打印ThreadRun() Done说明代码没在MainThreadNotANR这个线程中运行，从myLooper=null; mainLooper=Looper (main, tid 1) {303e756a}可以验证我们的猜想。而MainThreadANR中就很明显，各种丢帧奔溃。不过I/art: Wrote stack traces to ‘/data/anr/traces.txt’告诉我们可以在/data/anr/traces.txt中追踪奔溃的缘由1234567891011121314151617181920212223242526traces.txtDALVIK THREADS (18):&quot;main&quot; prio=5 tid=1 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x73581970 self=0xf4306800 | sysTid=2030 nice=0 cgrp=apps sched=0/0 handle=0xf7761160 | state=S schedstat=( 545706267 72336573 314 ) utm=30 stm=23 core=3 HZ=100 | stack=0xff7c7000-0xff7c9000 stackSize=8MB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x2ce90c0d&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x2ce90c0d&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at org.fitzeng.recurrentanr.MainActivity.mainThreadANR(MainActivity.java:47) at org.fitzeng.recurrentanr.MainActivity.onClick(MainActivity.java:81) at android.view.View.performClick(View.java:4756) at android.view.View$PerformClick.run(View.java:19749) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:135) at android.app.ActivityThread.main(ActivityThread.java:5221) at java.lang.reflect.Method.invoke!(Native method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:899) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:694) 这是定位ANR的有效手段。 Tips: 作为一个Android小白，自然有很多不知道不理解的地方。如果文中有错或者有哪些值得改进的地方，欢迎大家提意见，我很开心能和大家一起交流学习，共同进步。 多谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]}]