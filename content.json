[{"title":"重拾计算机网络","date":"2017-08-30T16:00:00.000Z","path":"2017/08/31/reCN/","text":"主要是把在重读 《计算机网络》 和 《数据通讯与网络》中觉得有价值的东西记录下来。 1. 计算机网络基础概念 一些互相连接的、自治的计算机的集合。 1.1 网络分类不同作用范围的网络 广域网 WAN (Wide Area Network) 城域网 MAN (Metropolitan Area Network) 局域网 LAN (Local Area Network) 个人区域网 PAN (Personal Area Network) 不同使用者的网络 公用网 (public network) 专用网 (private network) 用来把用户接入到因特网的网络 接入网 AN (Access Network) 1.2 计算机网络的性能指标速率 (bit/s)带宽 信号具有的频带宽度 (xxxHZ) 在计算机网络中，从来表示通讯线路所能传送数据的能力。因此网络中的带宽表示在单位时间内ongoing 网络中的某一点到另一点所能通过的最高数据率。单位是比特每秒(b/s) 吞吐量 单位时间通过某个网络(或信道、接口)的数据量 时延 数据从网络的一端发送到另一端所需的时间 总延时 = 发送时延 + 传播时延 + 处理时延 + 排队时延 发送时延(传输时延) 发送数据帧的时间 发送时延 = 数据帧长度(b) / 信道带宽(b/s) 传播时延 电磁波在信道中传播一定距离花费的时间 传播时延 = 信道长度(m) / 电磁波在信道上的传播速率(m/s) 处理时延 主机或路由器在收到分组时要花费一定时间处理。 排队时延 在路由器中输入队列中排队等待的时间sw 时延带宽积以比特为单位的链路长度(可以理解为 体积 = 截面 * 长度) 时延带宽积 = 传播时延 * 带宽 往返时间 RTT (Round-Trip Time) 从发送方发送数据开始到发送方接收到来自接收方的确认总共经历的时间。 利用率信道利用率 某信道有百分之几的时间是被利用的 网络利用率 D0 : 网络空闲时的时延 D : 当前网络的时延 U : 利用率 D = D0 / (1 - U) 1.3 计算机网络的体系结构 每层的具体介绍后面章节给出 2. 物理层","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://fitzeng.org/tags/计算机网络/"}]},{"title":"重拾操作系统","date":"2017-08-06T16:00:00.000Z","path":"2017/08/07/reOS/","text":"主要是把在重读 《现代操作系统》 中觉得有价值的东西，以 Tips 的形式记录下来。不可能面面俱到，但是如果有一定的基础应该是会回想起很多知识的。具体解释将会以链接形式补充。 1. 进程与线程1.1 进程 主要是为了支持伪并发能力 运行态 : 实际占用 CPU 资源 就绪态 : 可运行，但是由于没有时间片而被暂停等待 CPU 重新调度 阻塞态 : 外部某种事件导致（资源不足）不可运行 CPU 利用率 = 1 - p ^ n p : IO 等待时间比 n : 进程数 1.2 线程 每一个进程有一个地址空间和一个控制线程，主要是使某个进程内的任务之间不被相互阻塞，实现一种进程内并行操作的假象。创建销毁更加轻量级。 共享一组资源，协同完成任务。每个线程有自己的堆栈区（因为要区分同一进程内的线程，CPU 调度要进行状态的保存） 线程模型用户空间中实现线程内核中实现线程混合实现1.3 进程间通信（IPC）1.竞争条件 两个或者多个进程读写某些共享数据 2.临界区 将共享内存的访问代码称为临界区，确保在每个时刻两个进程不可能同时处于临界区中，这样可以避免竞争条件。核心思想为互斥。 并发程序准确高效要满足一下四个条件 任何两个进程不能同时处于其临界区 不应对 CPU 的速度和数量做任何假设 临界区外运行的程序不得阻塞其他进程 不得使进程无限期等待进入临界区 3.忙等待的互斥 互斥实现方案 屏蔽中断 每个进程进入临界区后立即屏蔽所有中断，这样 CPU 无法进行进程切换，就要离开临界区是打开中断。 锁变量 设置一个共享锁变量，初始值为 0。当一个进程想要进入临界区，必须检测锁的值是否为 0，是则置 1 进入临界区。不是则等待其他进程退出临界区时释放锁直到自己能获取到锁开始进入临界区。 锁变量还是会产生竞争条件 严格轮换法 一直循环等待直到出现允许该进程进入临界区的条件才开始运行，十分消耗 CPU 资源。 避免了竞争条件，但是临界区外运行的程序会发生阻塞 用于忙等待的锁称为自旋锁。 123456789101112131415A:while (TRUE) &#123; while (turn != 0); critical_region(); turn = 1; noncritical_region();&#125;B:while (TRUE) &#123; while (turn != 1); critical_region(); turn = 0; noncritical_region();&#125; Peterson 解法 一种互斥算法 12345678910111213141516171819#define FALSE 0#define TRUE 1#define N 2int turn;int interested[N];void enter_region(int process) &#123; int other; other = 1 - process; interested[process] = TRUE; turn = process; // 如果有另一个程序进入临界区的话则一直空循环 while (turn == process &amp;&amp; interested[other] == TRUE);&#125;void leave_region(int process) &#123; interested[process] = FALSE;&#125; 4.睡眠与唤醒 前面的弊端是忙等待会消耗 CPU 资源。如果在等待进入临界区时可以挂起，等到某个信号到达再唤醒就可以避免这种情况了。 生产者-消费者问题 利用资源缓冲区实现进程间的协调 1234567891011121314151617181920212223242526272829303132#define N 100 int count = 0;void producer(void) &#123; int item; while (TURE) &#123; item = produce_item(); if (count == N) &#123; sleep(); &#125; insert_item(item); count = count + 1; if (count == 1) &#123; wakeup(consumer); &#125; &#125;&#125;void consumer(void) &#123; int item; while (TURE) &#123; if (count == 0) &#123; sleep(); &#125; item = remove_item(); count = count - 1; if (count == N - 1) &#123; wakeup(producer); &#125; consume_item(item); &#125;&#125; 5.信号量 引入一个信号量来累计唤醒次数，可以为 0 或正数 使用 down 和 up 操作代替 sleep 和 wakeup #define N 100 typedef int semaphore semaphore mutex = 1; // 控制对临界区的访问 semaphore empty = N; // 计数缓冲区的空槽数目 semaphore full = 0; // 计数缓冲区的满槽数目 void producer(void) { int item; while (TRUE) { utem = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); } } void consumer(void) { int item; while (TRUE) { down(&amp;full); down(&amp;mutex); item = remove_item(); up(&amp;mutex); up(&amp;empty); consume_item(item); } } mutex : 用于互斥，保证任一时刻只有一个进程读写缓冲区 full &amp;&amp; empty : 实现同步，保证某种时间的顺序发生或者不发生 6.互斥量 仅仅适用于管理共享资源或一小段代码 7.管程8.消息传递9.屏障1.4 调度 当有多个进程处于就绪态时就面临调度的选择。内核管理线程时调度可以认为是线程级别的。进程行为有 计算密集型 和 I/O 密集型。而现在由于 CPU 改进速度加快，进程行为更倾向于后者，所以应该多运行该类进程保持 CPU 的利用率。 调度算法 批处理 先来先服务 最短作业优先 最短剩余时间优先 交互式 轮转调度（每个进程一个时间片，用完就轮转） 优先级调度 多级队列 最短进程优先 （aT0 + (1 - a)T1） 保证优先 彩票调度 公平分享调度 实时 线程调度 和系统支持的线程实现方式有关（理解 : 线程表存在哪的区别） 用户级线程 : 内核并不知道，内核只是选中该进程，至于进程中跑哪个线程由用户态调度决定。内核级线程 : 直接调度某个进程内的线程。以上两种方式在性能上有主要差别 : 前面提及 I/O 操作其实是很耗时的，所以在进程间切换比在线程间切换更加耗时。因为线程轻量，而进程完成切换要完整的山下文切换，修改内存映像。而且同一进程内的线程 I/O 访问 cache 的局部性更高，不同进程间切换的清理缓存，这也会消耗时间。 2. 存储管理 主要思想就是内存抽象 2.1 空闲内存管理使用位图的存储管理使用链表的存储管理2.2 虚拟内存 程序产生的地址为虚拟地址，在没有虚拟内存的操作系统上，直接将地址输送到内存总线上。而有虚拟内存的操作系统上，把虚拟地址输送到 MMU（Memory Management Unit），由 MMU 将虚拟地址映射为为物理地址。 分页虚拟地址空间 : 页面 物理内存地址 : 叶框 4k大小 虚拟地址 = 虚拟页号(高位) + 偏移量(低位) 页表 : 把虚拟地址的页面映射为页框，每个进程都有自己的页表 加速分页方法 : 转换检测缓冲区（TLB）主要是优先在 TLB 中查找页面号。 大内存页表 多级页表 倒排页表 : 每个页框一个表项 + TLB 快表 2.3 页面置换算法 最优页面置换算法不可实现，因为无法确定未来。 1.最近未使用页面置换算法(NRU) 设置访问（读、写）位 R，页面修改位 M。 2.先进先出页面置换算法(FIFO)3.第二次机会页面置换算法 设置一个检测最老页面位 R 4.时钟页面置换算法 链表实现页面选择 5.最近最少使用页面置换算法(LRU) 利用矩阵模拟 : 增加自身权重减少其他权重，行置 1，列置 0。 6.用软件模拟 LRU 老化算法 7.工作集页面置换算法8.工作集时钟页面置换算法 算法 注释 最优算法 不可实现，但可作为基准 NRU(最近未使用)算法 LRU 的很粗糙近似 FIFO(先进先出)算法 可能抛弃重要页面 第二次机会算法 比 FIFO 有大的改善 时钟算法 现实的 LRU(最近最少使用)算法 很优秀，但很难实现 NFU(最不经常使用)算法 LRU 的相对粗略的近似 老化算法 非常近似 LRU 的有效算法 工作集算法 实现起来开销很大 工作集时钟算法 好的有效算法 2.4 内存映射文件 进程发起系统调用，把文件映射到其虚拟地址空间的一部分。一般实现是开始不加载，在程序访问时在按页加载。 // Linux 待填 2.5 实现分页工作 进程创建时 : 操作系统要确定程序和数据在初始时有多大，并为它们创建一个页表，操作系统还要在内存中为页表分配空间并对其进行初始化。 进程运行时 : 页表必须在内存中(反之不需要)，并且在磁盘交换区中分配空间。 调度一个进程执行时 : 为新进程充值 MMU，刷新 TLB，更换页表。 缺页中断发生时 : 操作系统必须通过读硬件寄存器确定是哪个虚拟地址造成了缺页中断通过该信息计算需要哪个页面，定位磁盘位置并找到合适的页框来存放新页面，必要的话要置换老页面，然后把所需页面读入页框。最后，备份程序计数器，是程序计数器指向引起缺页中断的指令，并重新执行该指令。 进程退出时 : 释放页表，页面和页面在硬盘上占的空间。 缺页中断处理 硬件陷入内核，在堆栈中保存程序计数器。大多数机器将当前的指令的各种状态信息保存在特殊的 CPU 寄存器中。 启动一个汇编代码例程保存通用寄存器和其他易失信息，以免被操作系统破坏。这个例程将操作系统做为一个函数来调用。 当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看他在缺页中断时正在做什么。 一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致，如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。 如果选择的页框“脏”了，安排该页面写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。 一旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行用户进程，则选择另一个用户进程运行。 当磁盘中断发生时，表明该页已被装入，页表已经更新可以反映他的位置，页框也被标记为正常状态。 恢复发生缺页中断指令以前的状态，程序计数器重新定向这条指令。 调度引发缺页中断的进程，操作系统返回调用他的汇编语言例程。 该例程恢复寄存器和其他状态信息，放回到用户空间继续执行，就好像缺页中断没有发生过一样。 2.6 分段 段是逻辑实体，大小不固定。 2.7 分段和分页结合 : MULTICS 还有 Intel Pentuium 未介绍 34 位的 MULTICS 虚拟地址 段号 页号 页内偏移 18 6 10 根据段号找到段描述符 检查该段的页表是否存在内存中。如果在，则找到他；如果不再，则产生一个段错误。如果访问违反了段的保护要求就要求发出一个越界错误(陷阱)。 检查所请求虚拟页面的页表项，如果该页面不再内存中则产生一个缺页中断，如果在内存就从页表中取出这个页面在内存中的起始地址。 把偏移量加到页面的起始地址上，得到要访问的字在内存中的地址。 最后进行读或写操作。 3. 文件系统 文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。磁盘的 0 号盘扇区称为主引导记录(Master Boot Record, MBR)，用来引导计算机。在 MBR 的结尾是分区表，该表给出了每个分区的其实和结束地址。表中的一个分区被标记为活动分区。在计算机被引导时，BIOS 读入并执行 MBR。MBR 做的第一件事是确定活动分区，读入它的第一个块，称为引导块，并执行。 整个分区: MBR 分区表 磁盘分区 磁盘分区 磁盘分区… 磁盘分区: 引导块 超级块 空闲空间管理 i 节点 根目录 文件和目录 3.1 文件实现连续分配 把每个文件作为一连串连续数据块存储在磁盘上。 链表分配 一个文件由几个磁盘块组成。 在内存中采用表的链表分配 把每个磁盘块的指针字放在内存的一个表中 i 节点 每个文件赋予一个称为 i 节点(index-node)的数据结构，列出文件属性和文件快的磁盘地址。 4. 输入/输出4.1 I/O 硬件原理I/O 设备块设备 : 以块为单位传输，可寻址字符设备 : 以字符为单位收发字符流，不可寻址 设备控制器内存映射 I/O直接存储器存取DMA 工作原理: CPU 对 DMA 控制器进行编程 DMA 请求磁盘传送数据到内存 磁盘传送数据到内存 磁盘给 DMA 控制器应答 完成中断 5. 死锁5.1 资源 在进程对设备，文件等取得了排他性访问权限的时候，有可能会出现死锁。这类需要排他性使用的对象称为资源。 可抢占资源 可以从拥有它的进程中抢占而不会产生任何副作用。（存储器） 不可抢占资源 指在不引起相关的计算失败的情况下，无法把他从占有它的进程处抢占过来。（ CD 刻录） 资源使用步骤: 请求资源 使用资源 释放资源 5.2 死锁概述 如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。 资源死锁条件发生资源死锁的四个必要条件: 互斥条件 : 每个资源要么已经分配了一个进程，要么就是可用的。 占有和等待条件 : 已经得到了某个资源的进程可以再请求新的资源。 不可抢占条件 : 已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显示地释放。 环路等待条件 : 死锁发生时，系统中一定有两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。 5.3 死锁检测与死锁恢复 死锁检测主要是判断当前空闲资源在某种合理分配下是否能使所有进程都运行完并且最终资源都能够释放。 恢复方法 : 利用抢占式恢复 利用回滚恢复 利用杀死进程恢复 5.4 死锁避免资源轨迹图安全状态和不安全状态单个资源的银行家算法多个资源的银行家算法5.5 死锁预防 死锁避免从本质上来说是不可能的，因为他要获取未来的信息。 破坏互斥条件 如果资源不被一个进程独占死锁不会发生。（假脱机打印机） 破坏占有和等待条件 开始执行前请求所有资源就不会造成等待。另一种是请求资源时先释放自己所持有的资源，再尝试一次请求资源。 破坏不可抢占条件 针对某些资源进行虚拟化，实现可抢占。 破坏环路等待条件 保证每个进程在任何时刻只能占用一个资源如果要请求另外一个资源它必须先释放第一个资源。另一种是将所有资源统一编号，进程可以在任何时刻提出资源请求，但是请求必须按照资源编号顺序(升序)提出。 5.6 其他问题两阶段加锁通讯死锁活锁饥饿","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://fitzeng.org/tags/C-C/"},{"name":"OS","slug":"OS","permalink":"http://fitzeng.org/tags/OS/"}]},{"title":"Why Marvel ?","date":"2017-08-02T16:00:00.000Z","path":"2017/08/03/WhyMarvel/","text":"先给自己挖个坑, 记录一下从 12 - 17 这五年间的点点滴滴.很久之前就很想写写自己心中的 Marvel. 人总得有些爱好是与理想相关的, 不是吗?","tags":[{"name":"Life","slug":"Life","permalink":"http://fitzeng.org/tags/Life/"},{"name":"Marvel","slug":"Marvel","permalink":"http://fitzeng.org/tags/Marvel/"}]},{"title":"重拾数据结构","date":"2017-08-01T16:00:00.000Z","path":"2017/08/02/reDS/","text":"在大三到大四过渡期中, 从四月到七月, 经历过几场面试, 找实习. (如果八月份拿到[真.offer]的话我也想把这段经历记录下来) 结果很悲剧, 觉得方向不是什么障碍, 基础比较重, 所以要重拾数据结构不涉及算法具体实现, 因为是重拾, 所以先前有一定基础, 只要有一点提示便能唤醒无限回忆. 这里主要是记录各种数据结构的结构体, 这是经过重重思维过程得出的精华, 十分有价值. 至于具体实现和讲解日后回会以链接形式提供, 这里只提供一个思维树, 建立一个数据机构的思维体系, 后续更新欢迎关注 GitHub. 1 线性表1.1 动态分配空间12345typedef struct &#123; ElemType * elem; int length; int listsize;&#125; SqList; 1.2 线性链表1234typedef struct LNode &#123; ElemType data; struct LNode * next;&#125; LNode, * LinkList; 1.3 静态链表1234typedef struct &#123; ElemType data; int cur; // 游标指向下一个元素的数组下标&#125; component, SlinkList[MAXSIZE]; 1.4 循环链表 &amp; 双向链表12345typedef struct DuLNode&#123; ElemType data; struct DuLNode * prior; struct DuLNode * next;&#125; DuLNode, * DuLinkList; 2 栈和队列2.1 栈12345typedef struct &#123; SELemType * base; SElemType * top;##### int stacksize;&#125; SqStack; 应用: 主要是利用先进后出的特性 数制转换 括号匹配检测 行编辑程序 迷宫非递归求解 表达式求值 Hanoi塔问题 2.2 队列 链队列 12345678typedef struct QNode &#123; QElemType data; struct QNode * next;&#125; QNode, * QueuePtr;typedef struct &#123; QueuePtr front; QueuePtr rear;&#125; LinkQueue; 循环队列 12345typedef struct &#123; QElemType * base; int front; int rear;&#125; SqQueue; 3 串3.1 定长串12typedef unsigned char SString[MAXSTRLEN + 1];SString s; 3.2 变长 堆分配存储 1234typedef struct &#123; char * ch; int length;&#125;HString; 块链存储 123456789typedef struct Chunk&#123; char ch[CHUNKSIZE]; struct Chunk * next;&#125; Chunk;typedef struct &#123; Chunk * head; Chunk * tail; int curlen;&#125; LString; 应用 子串定位 (KMP) 4 数组和广义表4.1 数组顺序存储123456typedef struct &#123; ElemType * base; int dim; // 数组维数 int * bounds; // 维界基址 int * constants; // 印象函数常量基址&#125; Array; 4.2 矩阵 讨论稀疏矩阵的存储 三元顺序表 1234567891011typedef struct &#123; int i; int j; ElemType e;&#125; Triple;typedef struct &#123; Triple data[MAXSIZE + 1]; int mu; // 行 int nu; // 列 int tu; // 非零个数&#125;TSMatrix; 行逻辑链接 12345typedef struct &#123; Triple data[MAXSIZE + 1]; int rpos[MAXRC + 1]; // 各行第一个非零元素位置表 int mu, nu, tu;&#125; RLSMatrix; 十字链表 123456789101112typedef struct OLNode &#123; int i; int j; ElemType e; struct OLNode * right; // 该非零元素所在行的右链域 struct OLNode * down; // 该非零元素所在列的下链域&#125; OLNode, * OLink;typedef struct &#123; OLink * rhead; // 行链表头指针地址 OLink * chead; // 列链表头指针地址 int mu, nu, tu;&#125; CrossLink; 4.3 广义表 表中有表 头尾链表存储 1234567891011typedef enum &#123; ATOM, LIST &#125; ElemTag; // 0 : 原子, 1 : 子表typedef struct GLNode &#123; ElemTag tag; union &#123; AtomType atom; struct &#123; struct GLNode * hp; // 表头 struct GLNode * tp; // 表尾 &#125; ptr; // 表节点指针域 &#125;;&#125; * GList; 扩展线性链表存储 1234567891011typedef enum &#123; ATOM, LIST &#125; ElemTag; // 0 : 原子, 1 : 子表typedef struct GLNode &#123; ElemTag tag; union &#123; AtomType atom; struct &#123; struct GLNode * hp; // 表头 &#125; ptr; // 表节点指针域 &#125;; struct GLNode * tp; // 表尾, 相当于 next.&#125; * GList; 5 树和二叉树5.1 二叉树存储结构 顺序存储结构 数组, 利用下标寻址 1typedef TElemType SqBiTree[MAX_TREE_SIZE]; 链式存储结构 12345typedef struct BiTNode &#123; TElemType data; struct BiTNode * lchild; struct BiTNode * rchild;&#125; BiTNode, * BiTree; 5.2 遍历二叉树 先序遍历 根节点 -&gt; 左子树 -&gt; 右子树 中序遍历 左子树 -&gt; 根节点 -&gt; 右子树 后序遍历 左子树 -&gt; 右子树 -&gt; 根节点 算数表达式 a + b * (c - d) - e / f 前缀表达式-先序遍历(逆波兰 : - + a * b - cd / ef) 中缀表达式-中序遍历(原表达式 : a + b * (c - d) - e / f) 后缀表达式-后续遍历(逆波兰式 : abcd - * + ef / -) 5.3 线索二叉树 保存比遍历过程中的节点相关性结果 前驱后继节点和左右孩子指示 lchild LTag data RTag rchild LTag 0 : lchild 域指示左孩子 1 : lchild 域指示前驱节点 RTag 0 : rchild 域指示右孩子 1 : rchild 域指示后继节点 12345678typedef enum PointerTag &#123;Link, Thread&#125;; // 0 : 指针 1 : 线索typedef struct BiThrNode &#123; TElemType data; struct BiThrNode * lchild; struct BiThrNode * rchild; PointerTag LTag; PointerTag RTag;&#125; BiThrNode, * BiThrTree; 5.4 树和森林 双亲表示法 123456789typedef struct PTNode &#123; TElemType data; int parent;&#125; PTNode;typedef struct &#123; PTNode nodes[MAX_TREE_SIZE]; int r; // 根的位置 int n; // 节点数&#125; PTree; 孩子表示法 12345678910111213typedef struct CTNode &#123; // 孩子节点 struct CTNode * next; int child;&#125; * ChildPtr;typedef struct &#123; TElemType data; ChildPtr firstchild; // 孩子链表头指针&#125; CTBox;typedef struct &#123; CTBox nodes[MAX_TREE_SIZE]; int r; // 根的位置 int n; // 节点数&#125; CTree; 孩子兄弟表示法 12345typedef struct CSNode &#123; ElemType data; struct CSNode * firstchild; struct CSNode * nextsibling;&#125; CSNode, * CSTree; 5.5 二叉树和森林互换 森林转换成二叉树 左孩子右兄弟(左右是对二叉树而言, 孩子兄弟是对森林而言, 下面同理) 二叉树转换成森林 左孩子转换成孩子, 右孩子转换成兄弟 5.6 树和森林遍历 先序遍历森林 第一棵树的根 先序遍历第一棵树中根节点的子树森林 先序遍历除第一棵树剩余的树构成的森林 中序遍历森林 中序遍历第一棵树中根节点的子树森林 第一棵树的根 中序遍历除第一棵树剩余的树构成的森林 7 图7.1 图的存储结构 数组表示法 123456789101112typedef enum &#123;DG, DN, UDG, UDN&#125; GraphKind; // &#123;有向图, 有向网, 无向图, 无向网&#125;typedef struct ArcCell &#123; VRType adj; // 顶点相关类型. 无权图 : 1/0 表示相邻与否 带权图 : 权值信息 InfoType * info; // 该弧相关的指针&#125; ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct &#123; VertexType vexs[MAX_VERTEX_NUM]; // 顶点向量 AdjMatrix arcs; // 邻接矩阵 int vexnum; // 顶点数 int arcnum; // 弧数 GraphKind kind; // 图的种类标志&#125; MGraph; 邻接表 表节点 adjvex nextarc info 头结点 data firstarc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748typedef struct ArcNode &#123; int adjvex; // 该弧所指向顶点位置 struct ArcNode * nextarc; // 指向下一条弧的指针 InfoType * info; // 该弧相关信息的指针&#125; ArcNode;typedef struct VNode &#123; VertexType data; // 顶点信息 ArcNode * firstarc; // 指向第一条依附该顶点的弧的指针&#125; VNode, AdjList[MAX_VERTEX_NUM];typedef struct &#123; AdjList vertices; int vexnum; // 顶点数 int arcnum; // 弧数 int kind; // 种类标记&#125; ALGraph;``` - 十字链表 &gt; 弧节点&gt; &gt; | tailvex | headvex | hlink | tlink | info |&gt; |---------|---------|-------|-------|------|&gt; &gt; 顶点节点&gt; &gt; | data | firstin | firstout |&gt; |------|---------|----------|&gt; ```Ctypedef struct ArcBox &#123; int tailvex; // 该弧的尾顶点位置 int headvex; // 该弧的头顶点位置 struct ArcBox * hlink; // 弧头相同的弧的链域 struct ArcBox * tlink; // 弧尾相同的弧的链域 InfoType * info; // 该弧相关信息指针&#125; ArcBox;typedef struct VexNode &#123; VertexType data; ArcBox * firstin; // 指向该节点第一条入弧 ArcBox * firstout; // 指向该节点第一条出弧&#125; VexNode;typedef struct &#123; VexNode xlist[MAX_VERTEX_NUM]; // 表头向量 int vexnum; // 有向图的当前顶点数 int arcnum; // 有向图的当前弧数&#125; OLGraph; 邻接多重表 每一条边用一个节点表示 mark ivex ilink jvex jlink info 每个顶点用一个节点表示 data firstedge 123456789101112131415161718typedef enum &#123;unvisited, visited&#125; VisitIf;typedef struct EBox &#123; VisitIf mark; // 访问标记 int ivex; // 依附顶点位置 int jvex; // 依附顶点位置 struct EBox * ilink; // 依附顶点的下一边 struct EBox * jlink; // 依附顶点的下一边 InfoType * info; // 该边的信息指针&#125; EBox;typedef struct VexBox &#123; VertexType data; EBox * firstedge; // 指向第一条依附该顶点的边&#125; VexBox;typedef struct &#123; VexBox adjmulist[MAX_VERTEX_NUM]; int vexnum; // 无向图的顶点数 int edgenum; // 无向图的边数&#125; AMLGraph 7.2 图的遍历 深度优先搜索 以迷宫为例子(面试中被问到, 印象比较深刻). 深度优先就是一条路走到黑, 所以返回的第一条路径不保证是最优解. 123456789101112131415161718192021222324Boolean visited[MAX]; // 访问标志数组Status (* VisiteFunc) (int v); // 函数变量 void DFSTraverse(Graph G, Status (* Visit)(int v)) &#123; // 深度优先遍历 VisitFunc = Visit; // 使用全局变量 VisitFunc, 使 DFS 不必设置函数指针参数 for (v = 0; v &lt; G.vexnum; ++v) &#123; visited[v] = FALSE; // 访问数组标志初始化 &#125; for (v = 0; v &lt; G.vexnum; ++v) &#123; if (!visited[v]) &#123; DFS(G, v); // 对未访问的顶点调用 DFS &#125; &#125;&#125; void DFS(Graph G, int v) &#123; // 从第 v 个顶点出发递归的深度优先遍历图 G. visited[v] = TRUE; VisitFunc(v); // 访问第 v 个顶点 for (w = FirstAdjVex(G, v); w &gt;= 0; w = NextAdjVex(G, v, w)) &#123; if (!visited[w]) &#123; DFS(G, w); // 对 v 的尚未访问的邻接顶点 w 递归调用 DFS. &#125; &#125;&#125; 广度优先搜索 有点层序遍历的意思, 在遍历完所有情况下(可以进行算法优化, 对有些情况进行舍弃)可以得出最优解. 123456789101112131415161718192021222324void BFSTraverse(Graph G, Status (* Visit) (int v)) &#123; for (v= 0; v &lt; G.vexnum; ++v) &#123; visited[v] = FALSE; &#125; InitQueue(Q); for (v = 0; v &lt; G.vexnum; ++v) &#123; if (!visited[v]) &#123; visited[v] = TRUE; Visit(v); EnQueue(Q, v); while (!QueueEmpty(Q)) &#123; DeQueue(Q, u); for (w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)) &#123; // w 为 u 尚未访问的邻接顶点 if (!visited[w]) &#123; visited[w] = TRUE; Visit(w); EnQueue(Q, w); &#125; // if &#125; // for &#125; // while &#125; // if &#125; // for&#125; // BFSTraverse // 以下待填 7.3 图的连通性问题 无向图的连通分量和生成树 有向图的强连通分量 7.4 最小生成树 Prim 算法 O(n2) 以点为主: 主要是分为两个集合, 一个是已加入的节点, 另一个是未加入节点. 在未加入的节点集合中找到一个离已加入集合最近的节点加入. 直至所有节点被加入. Kruskal 算法 O(eloge) 以边为主: 初始条件是把图的所有边去除变成 V 个连通图. 然后每次找一条代价最小的边加入, 确保每加入一条边连通图个数都减少一个(也就是确保无环路)。直至成一个连通图时就是最小生成树. 7.5 最短路径 Dijkstra 算法 O(n3) 主要是维护一个表和一个已加入路径集合, 表记录从原点到每一个点的当前最小权值. 如果已加入路径集合中的点通过某条路径对未加入集合中的点的最小权值有影响则更新该节点权值. 最后在每次更新完成后判断目前未加入集合中的最小权值节点加入集合, 再对该节点的边所达的节点做如上判断. 最终可以求出起点到每一个点的所有最短路径. Floyd 算法 O(n3) 主要是判断经过该点到达的临时目点的权值和该点目前权值(可以不考虑是否已经经过, 但是循环只会扫一遍所以没有什么影响)的大小来判断是否更新权值. 关键路径和拓扑排序 (KeyWord : 松弛) 8 动态存储管理查找","tags":[{"name":"Algo","slug":"Algo","permalink":"http://fitzeng.org/tags/Algo/"},{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"C/C++","slug":"C-C","permalink":"http://fitzeng.org/tags/C-C/"},{"name":"DataStruct","slug":"DataStruct","permalink":"http://fitzeng.org/tags/DataStruct/"}]},{"title":"Android 单元测试工具 Robolectric 中文文档","date":"2017-07-30T16:00:00.000Z","path":"2017/07/31/robolectric/","text":"为什么要翻译文档? 由于在大三暑假时间算是比较充裕的, 然后加上自己英语比较渣, 又对 gitbook 有兴趣, 所以就想翻译一些文档. 平时也是一直看别人的干货, 所以也想自己做点贡献, 希望能帮助英语是短板的部分人. 为什么是 Robolectric? 其实原因很简单, 就是我之前写过一篇 Android 单元测试和 Robolectric 源码解析 的文章, 直接看的二手资料, 感觉这种学习方式太被动了, 要自己尝试去啃第一手资料. 而正好网上没有对应的中文文档加上内容少, 一个人可以完成, 再加上前面的第一点就直接开始行动了. 阅读建议 我自知自己水平很渣, 所以一些实在想不通的直接给出了原文对应的英文文档供大家参考, 如果你已经是有了 4/6 级的水平, 推荐你直接看英文文档, 这份可以作参考. 当然如果可以的话, 欢迎大家留言提出修改意见. 对于翻译难理解, 有歧义, 有错误的地方欢迎大家指出来. 我在此先表示感谢. 项目 Robolectric Robolectric-cn GitHub GitBook 关于我 目前是一个 Android 开发者, 即将毕业面临就业, 希望在毕业前做一些自己喜欢的事情. 同时也希望能贡献自己的一份力, 和大家探讨学习. Blog GitHub","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"Android Unit Test","slug":"Android-Unit-Test","permalink":"http://fitzeng.org/tags/Android-Unit-Test/"}]},{"title":"JavaTips","date":"2017-07-25T03:27:00.000Z","path":"2017/07/25/JavaTips/","text":"这篇文章主要是个人在二次学习 Java 过程中, 对 Java 的一些常见特性误解的分析. 主要是以测试代码加测试结果的形式来记录. 这里只做收集整理和简单分析, 详情请见参考链接, 支持原作者. 目录 基本类型 == 和 equals String, StringBuffer 和 StringBuilder Array ArrayList LinkedList Exception Collction 基本类型== 和 equals123456789101112TestCode:Integer a = 100;Integer b = 100;System.out.println(a == b);Integer c = 1000;Integer d = 1000;System.out.println(c == d);Output:truefalse 其中 == 结果不一致是因为 Integer 类对在 -128 到 127 之间的数值进行了缓存. 1234567TestCode:Integer e = new Integer(100);Integer f = new Integer(100);System.out.println(e == f);Output:false Integer a = 100;涉及到自动装箱问题, 反编译之后就是 Integer a = Integer.valueOf(100);.而Integer e = new Integer(100); 反编译不改变. 所以在 a 和 e 这两个对象引用的堆区域一个是通过valueOf()获得, 另一个是通过new获得. 毫无疑问 new 出来的肯定不会是同一块区域. 而 valueOf() 123456&gt; public static Integer valueOf(int i) &#123;&gt; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&gt; return IntegerCache.cache[i + (-IntegerCache.low)];&gt; return new Integer(i);&gt; &#125;&gt; 这里就解释了前面的Integer 类对在 -128 到 127 之间的数值进行了缓存. 详情见源码. 123456789101112TestCode:String s1 = \"1234\";String s2 = \"1234\";System.out.println(s1 == s2);String s3 = new String(\"1234\");String s4 = new String(\"1234\");System.out.println(s3 == s4);Output:truefalse 这个比较简单, 就是在 JVM 中存在常量池. 还有要注意的是两种初始化方式的不同才造成了这个差异. 下面分析 equals ,详情见参考.这里只提几点易混淆的地方. equals 是属于类方法, 而且是 Object 类的. 而 Object 类的实现就是判断引用是否相等. 而对于某个类来说判断相等一般是判断里面的某些成员变量是否相等. 所以就要重写父类方法.这里要区分重写和重载. 12345&gt; 重写:&gt; public boolean equals(Object obj) &#123;&#125;&gt; 重载:&gt; public boolean equals(MyObject myObj) &#123;&#125;&gt; 所以要想实现自己想要的 equals 方法应该是重写. 其实这里面的主要内容就是了解了自动拆装箱和 JVM 内分配就不难了. 第一类：整型 byte Byte | short Short | int Integer | long Long 第二类：浮点型 float Float | double Double 第三类：逻辑型 boolean Boolean 第四类：字符型 char Character 在支持 equals 特性的时候, 往往还要支持 hashCode 参考: 让人疑惑的Java代码 Java字符串那些事儿 说说Java里的equals（上） Java自动装箱/拆箱 说说Java里的equals（中） String, StringBuffer 和 StringBuilder String final 类. String s=”sss”; 会在静态常量池中查找 String s = new String(“sss”); 直接在堆中开辟内存 使用场合: 在字符串不经常变化的场景中可以使用 String 类, 如: 常量的声明, 少量的变量运算等 StringBuffer 线程安全, 可自身修改 必须通过构造函数初始化 使用场合: 在频繁进行字符串的运算(拼接, 替换, 删除等), 并且运行在多线程的环境中, 则可以考虑使用 StringBuffer, 例如 XML 解析, HTTP 参数解析和封装等 StringBuilder 线程不安全, 操作最快 使用场合: 和 StringBuffer 类似的不要求线程安全场景, 效率比 StringBuffer 高 Array 是一个在 JVM 中的特殊对象, 可以使用反射查看 拷贝时注意深拷贝还是浅拷贝 ArrayList 首先要知道的是这是一个 Array 所以在进行修改操作时十分不方便的. 特别是增加或者删除元素, 扩大存储等方式相比链表结构来说麻烦太多.知道这个为出发点, 对于源码实现的理解就理所当然了.应该了解的几个点 在 ArrayList 中从有元素开始就会分配 10 的对象大小容量. 接下来以 currentSize * 1.5 的大小扩容. 对于修改空间是以 System.arraycopy() 形式修改的. 为了提高效率采用的是 native 方法. 123&gt; public static native void arraycopy(Object src, &gt; int srcPos, Object dest, int destPos, int length);&gt; 详情源码分析见参考. 参考: ArrayList初探 再探ArrayList（ArrayList的扩容） 三顾ArrayList LinkedList 实现方式是双向链表 Exception 尽可能的减小try块 保证所有资源都被正确释放, 充分运用finally关键词 catch语句应当尽量指定具体的异常类型, 而不应该指定涵盖范围太广的 Exception 类. 不要一个Exception试图处理所有可能出现的异常 既然捕获了异常, 就要对它进行适当的处理 在异常处理模块中提供适量的错误原因信息, 组织错误信息使其易于理解和阅读 不要在 finally 块中处理返回值 不要在构造函数中抛出异常 参考: 树上月 Collction List 列表(可重复) ArrayList (数组) LinkedList (链表) Map 映射(key-value) HashMap extends AbstractMap implements Map table 数组 + Enter 节点 默认初始容量(16) 默认加载因子(0.75) 查找采用 static int indexFor(int h, int length) { return h &amp; (length-1); } 提高效率, 而不是取模. TreeMap extends AbstractMap implements NavigableMap interface NavigableMap extends SortedMap interface SortedMap extends Map 红黑树 + Enter 节点 Set 集合(不能重复) HashSet extends AbstractSet implements Set 内部基于 HashMap 实现 TreeSet extends AbstractSet implements NavigableSet interface NavigableSet extends SortedSet interface SortedSet extends Set 基于 TreeMap 实现","tags":[{"name":"Java","slug":"Java","permalink":"http://fitzeng.org/tags/Java/"},{"name":"Tips","slug":"Tips","permalink":"http://fitzeng.org/tags/Tips/"}]},{"title":"leetcode 算法集锦","date":"2017-07-17T03:27:00.000Z","path":"2017/07/17/AlgoAndMath/","text":"leetcode 算法集锦 主要是牛客网上 leetcode 的算法题实践. 在 Blog 包含自己的解法和对别人优秀解法的分析. 序号 考点 题目 C/C++ Java 01 树 Minimum Depth of Binary Tree NULL 题解 02 栈 evaluate-reverse-polish-notation NULL 题解 02 : evaluate-reverse-polish-notation Evaluate the value of an arithmetic expression in Reverse Polish Notation.Valid operators are+,-,*,/. Each operand may be an integer or another expression. Some examples: [“2”, “1”, “+”, “3”, ““] -&gt; ((2 + 1) 3) -&gt; 9 [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6 我的解法 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Stack;public class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;String&gt; s = new Stack&lt;&gt;(); int op1 = 0; int op2 = 0; for (int i = 0; i &lt; tokens.length; i++) &#123; switch (tokens[i]) &#123; case \"+\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 + op1)); break; &#125; case \"-\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 - op1)); break; &#125; case \"*\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 * op1)); break; &#125; case \"/\": &#123; op1 = Integer.parseInt(s.pop()); op2 = Integer.parseInt(s.pop()); s.push(String.valueOf(op2 / op1)); break; &#125; default: &#123; s.push(tokens[i]); break; &#125; &#125; &#125; return Integer.parseInt(s.pop()); &#125;&#125; 其他解法 12345678910111213141516171819202122232425262728293031import java.util.Stack;public class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i = 0;i&lt;tokens.length;i++)&#123; try&#123; int num = Integer.parseInt(tokens[i]); stack.add(num); &#125;catch (Exception e) &#123; int b = stack.pop(); int a = stack.pop(); stack.add(get(a, b, tokens[i])); &#125; &#125; return stack.pop(); &#125; private int get(int a,int b,String operator)&#123; switch (operator) &#123; case \"+\": return a+b; case \"-\": return a-b; case \"*\": return a*b; case \"/\": return a/b; default: return 0; &#125; &#125;&#125; 01 : Minimum Depth of Binary Tree Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 我的解法 123456789101112131415深度优先遍历所有节点, 直至叶子节点后返回长度. 每次取当前节点左右子节点的 [最小值+1] 为该节点的最小深度. public class Solution &#123; public int run(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int length1 = run(root.left); int length2 = run(root.right); if (length1 == 0 || length2 == 0) &#123; return length1 + length2 + 1; &#125; return Math.min(length1, length2) + 1; &#125;&#125; 其他思路 1234567891011121314151617181920212223242526class Solution &#123;public: typedef TreeNode* tree; int run(TreeNode *root) &#123; //采用广度优先搜索，或者层序遍历，找到的第一个叶节点的深度即是最浅。 if(! root) return 0; queue&lt;tree&gt; qu; tree last,now; int level,size; last = now = root; level = 1;qu.push(root); while(qu.size())&#123; now = qu.front(); qu.pop(); size = qu.size(); if(now-&gt;left)qu.push(now-&gt;left); if(now-&gt;right)qu.push(now-&gt;right); if(qu.size()-size == 0)break; if(last == now)&#123; level++; if(qu.size())last = qu.back(); &#125; &#125; return level; &#125;&#125;;","tags":[{"name":"Algo","slug":"Algo","permalink":"http://fitzeng.org/tags/Algo/"},{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"Java","slug":"Java","permalink":"http://fitzeng.org/tags/Java/"},{"name":"C/C++","slug":"C-C","permalink":"http://fitzeng.org/tags/C-C/"}]},{"title":"Android Blog Collection","date":"2017-07-08T03:27:00.000Z","path":"2017/07/08/AndroidBlogCollection/","text":"this repo aims to collect some high quality basic knowledge Android Blog. Just like source code analysis or something. 这个仓库致力于收集我在学习 Android 开发过程所遇到的高质量的基础知识文章. 类似于源码分析之类的, 可以帮大家加深对基础原理的理解. 0. Start&gt; 前言 现在网络上有太多的知识可供学习, 但是作为一个自学者, 是好事也是坏事, 好事指不用担心没资源, 坏事是指对学习效率,理解程度和知识体系搭建都不太好.网上的文章不全是高质量的, 而且很多都是重复的碎片化知识,大家写的都差不多.所以为了自己的系统学习, 建议买书, 碰到哪个模块不懂再找大牛的 Blog 加深理解. 所以可以看到我推荐的基本都是成一个小体系的系列文章, 可以帮助我们形成一个好的”学习思维树”. 而不是一大堆”散叶”. 而其他文章主要是作为自己加深理解, 对某个知识点深入学习的参考. 首先可以肯定像我这种刚刚入门的在写文章的高度和视野都不如大牛. 而对于基础的知识,特别是涉及源码解析, 只要以一份资料为主就可以了. 最多加一两份做参考. 所以, 基本这种类型的文章, 我会收藏整理在这篇文章里并且永久更新. 同时自己也会利用课余时间把自己的实践项目以一个入门的学习者的视角解析, 相信这样对初学的开发者是比较友好的.如果你和我也一样处在这个阶段, 欢迎关注这篇文章. 这里永久更新这类基础知识解读. GitHub 和 Blog 永久更新练习项目. 如果对你有帮助欢迎 Star ^_^; &gt; 更新 v3 : 敬请期待… v2 : 添加 JVM 设计模式 常用框架 计算机基础 四大模块优质 Blog 收集 v1 : 以 Android View 基础知识为主的 Blog 收集. 1. UI&gt; View 的绘制源码解析 这里推荐的是Carson_Ho的一系列源码分析教程, 主要是从 View 和 ViewGroup 的测量, 布局和绘制过程进行详细分析, 很多图示十分清晰易懂, 对于初学者和进阶者都是很不错的学习资料. 如果有找到其他的好的教程我还会继续加上. 自定义View基础 - 最易懂的自定义View原理系列(1) 自定义View Measure过程 - 最易懂的自定义View原理系列(2) 自定义View Layout过程 - 最易懂的自定义View原理系列(3) 自定义View Draw过程- 最易懂的自定义View原理系列(4) 前面给了 View 的绘制最主要的三个过程进行了详细分析的 Blog, 在前面的阅读基础上,下面给出郭霖大神的 View 的工作原理系列文章. 相信在读完以下四篇文章之后你会对 View 有一个重新认识的. Android LayoutInflater原理分析，带你一步步深入了解View(一) Android视图绘制流程完全解析，带你一步步深入了解View(二) Android视图状态及重绘流程分析，带你一步步深入了解View(三) Android自定义View的实现方法，带你一步步深入了解View(四) 下面介绍扔物线的HenCoder：给高级 Android 工程师的进阶手册, 包含了视频讲解. 目前持续更新, 在学习完前面的 Blog 并进行了部分实践 Demo 后把这当做复习提高挺不错的, 同时我也会一直关注并更新. HenCoder Android 开发进阶: 自定义 View 1-1 绘制基础 &gt; View 相关类解析 这个主要是介绍一些对自定义 View 过程中需要仔细了解的一些类的使用. Path类的最全面详解 - 自定义View应用系列 Canvas类的最全面详解 - 自定义View应用系列 &gt; XML 使用示例 这里推荐Keegan小钢的Android样式的开发相关教程, 通过十分简洁的小例子帮你快速实现对 XML 的了解和使用. Android样式的开发:shape篇 Android样式的开发:selector篇 Android样式的开发:layer-list篇 Android样式的开发:drawable汇总篇 Android样式的开发:View Animation篇 Android样式的开发:Property Animation篇 Android样式的开发:Style篇 &gt; 动画 Android 动画介绍, 感谢阿祥JOKER 分享. Android动画解析 重点!!!这里还是推荐郭霖大神的文章. 然后后面补充一篇偏知识点式的文章供复习. Android属性动画完全解析(上)，初识属性动画的基本用法 Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法 Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法 补充参考:Android动画，一篇就够, 感谢Shaun白一辰的分享. &gt; 事件分发 事件分发是一个重要的知识点, 在面试中也有很大几率被问到.在开发中经常会遇到, 只有彻底理解好了在写代码时候才能思路清晰.希望以下文章能帮助你我弄清事件分发机制. Android事件分发机制详解：史上最全面、最易懂 &gt; 自成体系的 View 教程 这里主要是推荐一些其他优秀文章作为参考阅读, 同样也是自成体系的. GcsSloop : 安卓自定义View教程目录 2. Java API 这里主要是对 Java API 中的一些重要的源码解析进行收集. 同时也是面试重点, 希望能加深对 Java 的认识. 做到真的理解底层实现而不是只会使用. 由于 Java 面太广, 所以在这里主要是以知识点的形式覆盖基本概念. 这里推荐 树上月 的教程. 从 Blog 介绍看接触 Java 有一段时间, 所以分析会比较深入且正确. 更主要的是, 他把 Java 类文章基本都串起来了, 共有 38 篇可供学习. 文章太多就不一一贴链接了… 想学Java, 值得一阅 3. 浅析JVM 当然这块知识会推荐一本书, 是《深入理解 Java 虚拟机》， 而网上的那些分析大多数都是基于这本书的。这里会收集一些较好的讲解共在线阅读。 4. 深入理解设计模式 这块也有一本书《Android 源码设计模式解析与实战》推荐. Java 的 23 种设计模式全解析 5. Android 常用框架分析6. Android - 从文件到项目的最后一米 主要是提供开发过程中的非代码技术性问题的知识介绍和解决方案。 Android 项目编译过程 Android 使用android-support-multidex解决Dex超出方法数的限制问题,让你的应用不再爆棚 7. 计算机基础&gt; 数据库如果有人问你数据库的原理，叫他看这篇文章 &gt; 网络&gt; 操作系统","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"Collection","slug":"Collection","permalink":"http://fitzeng.org/tags/Collection/"}]},{"title":"Common Sense","date":"2017-07-05T02:00:00.000Z","path":"2017/07/05/tips/","text":"this aticle aims to collect some common sense when you meet during dev.这篇文章主要是记录我在 Android 开发过程中遇到的一些概念问题, 在这里提供简单快速的使用规范. 开源项目许可证 看懂UML类图 开源项目许可证MIT、GPLv2和Apache占据了前三位。choosealicense.com为许可证的选择给出了建议. MIT是一个几乎可以“为所欲为”的许可证，如果你希望简单、宽松，它是你的不二选择. 如果你关心软件的专利问题，但同样希望宽松，可以选择Apache. 如果你希望代码使用者同样能把他们的贡献分享出来，那就选择GPL. 参考: 曹知渊 : GitHub发布开源许可证使用情况 看懂UML类图 泛化关系 (A继承自B) eg: 实现关系 (继承抽象类) 聚合关系( A 聚合到 B 上或者 B 由 A 组成) 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合关系( A 组成 B 或者 B 由 A 组成) 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系 它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系 ( A 依赖于 B ) 他描述一个对象在运行期间会用到另一个对象的关系； 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 实例 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 注: “看懂UML类图” 内容全部取材自该网页. 在此做出感谢, 出于学习总结目的特意把内容搬至此处, 如有侵权立即删除. 参考: congestion : UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）","tags":[{"name":"Tips","slug":"Tips","permalink":"http://fitzeng.org/tags/Tips/"}]},{"title":"BMP压缩成JPEG过程实现与分析","date":"2017-06-12T16:00:00.000Z","path":"2017/06/13/BMP2JPEG/","text":"GitHub 前言由于最近做了图像相关的学习，所以想再深入点，但是自己的知识有限，目前只能把自己所学的通过这个小小的实验来加深理解。参考大牛的 Blog 加上自己亲手实践，写了这篇文章。以后还会继续添加图像处理的相关知识。 BMP介绍 BMP文件头文件头主要是包含一个文件的ID信息，所以BMP的文件头自然也是说明自己的文件格式，文件大小等信息，一般是14位表示。意义如下图所示： 位图信息头信息头主要是对图片特征的描述，比如说宽高，像素，压缩方式等，一般是40位。主要介绍如下表： 调色板调色板是可选的，使用索引来表示图像，调色板就是索引与其对应的颜色的映射表，这次实验选用的是24bit的图片。 位图数据这里就是存储图片的内容了。 JPEG介绍JPEG是有损压缩编码下的一种图片格式，目前压缩效果好，应用广泛。其原理主要是将传统的RGB模式下的图片转化成YCbCr格式。因为人眼的结构问题对亮度更加敏感，所以可以将亮度和色度分离开来，对色度可进行较大的舍弃从而进行较大程度的压缩而对视觉不造成太大影响。既然是压缩而成的格式，那必然有解压缩过程，而解压缩所以依赖的量化表和哈夫曼表自然要记录下来。所以和BMP对比自然而然头结构出来了，而且要比BMP复杂。下面只给出部分信息： BMP 读取 构建BMP的文件头和头信息结构体 12345678910111213141516171819202122//BMP 文件格式【文件头和头部信息】typedef struct &#123; unsigned short bfType; unsigned int bfSize; unsigned short bfReserved1; unsigned short bfReserved2; unsigned int bfOffBits;&#125; BITMAPFILEHEADER;typedef struct &#123; unsigned int biSize; int biWidth; int biHeight; unsigned short biPlanes; unsigned short biBitCount; unsigned int biCompression; unsigned int biSizeImage; int biXPelsPerMeter; int biYPelsPerMeter; unsigned int biClrUsed; unsigned int biClrImportant;&#125; BITMAPINFOHEADER; 图片校验 1234567891011121314151617181920212223242526272829303132//打开文件FILE* fp = fopen(fileName, \"rb\");if(fp==0) &#123; return false;&#125;BITMAPFILEHEADER fileHeader;BITMAPINFOHEADER infoHeader;// 读取头部 14字节if(1 != fread(&amp;fileHeader, sizeof(fileHeader), 1, fp)) &#123; return false;&#125;// 判断是不是BM类型if(fileHeader.bfType!=0x4D42) &#123; return false;&#125;// 读取头部信息 40字节if(1 != fread(&amp;infoHeader, sizeof(infoHeader), 1, fp)) &#123; return false;&#125;// 判断是不是24位类型。也就是RGB的存储格式if(infoHeader.biBitCount != 24 || infoHeader.biCompression != 0) &#123; return false;&#125;int width = infoHeader.biWidth;int height = infoHeader.biHeight &lt; 0 ? (-infoHeader.biHeight) : infoHeader.biHeight;// 判断二进制的最后三位是不是000，也就是判断是不是8的倍数if((width&amp;7) != 0 || (height&amp;7) != 0) &#123; return false;&#125; 图片内容读取 123456789101112131415161718192021222324252627// RGB三个分量int bmpSize = width*height*3;unsigned char* buffer = new unsigned char[bmpSize];if(buffer == 0) &#123; return false;&#125;// 将文件指针移到数据区域fseek(fp, fileHeader.bfOffBits, SEEK_SET);if(infoHeader.biHeight &gt; 0) &#123; for(int i = 0; i &lt; height; i++) &#123; // 读取第i行,每此读 3（size） * width （count）大小 if(width != fread(buffer + (height - 1 - i) * width * 3, 3, width, fp)) &#123; delete[] buffer; buffer = 0; return false; &#125; &#125;&#125; else &#123; if(width*height != fread(buffer, 3, width*height, fp)) &#123; delete[] buffer; buffer = 0; return false; &#125;&#125; 存储信息 1234567// 获取宽高和大小m_rgbBuffer = buffer;m_width = width;m_height = height;fclose(fp);fp=0; JPEG 写入在前期JPEG写入是，要进行一系列准备工作，根据JPEG官方提供的标准量化表和哈夫曼表进行自己的操作得到自己满意的压缩编码。 数值表： 直流分量表： 交流分量表： 下面给出具体代码： 亮度量化表 1234567891011// 亮度量化表const unsigned char Luminance_Quantization_Table[64] = &#123; 16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99&#125;; 色度量化表 1234567891011// 色度量化表const unsigned char Chrominance_Quantization_Table[64] = &#123; 17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99&#125;; 标准直流分量色度亮度哈夫曼表 12345const char Standard_DC_Luminance_NRCodes[] = &#123; 0, 0, 7, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 &#125;;const unsigned char Standard_DC_Luminance_Values[] = &#123; 4, 5, 3, 2, 6, 1, 0, 7, 8, 9, 10, 11 &#125;;const char Standard_DC_Chrominance_NRCodes[] = &#123; 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 &#125;;const unsigned char Standard_DC_Chrominance_Values[] = &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 &#125;; 标准交流分量色度亮度哈夫曼表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const char Standard_AC_Luminance_NRCodes[] = &#123; 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d &#125;;const unsigned char Standard_AC_Luminance_Values[] = &#123; 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa&#125;;const char Standard_AC_Chrominance_NRCodes[] = &#123; 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 &#125;;const unsigned char Standard_AC_Chrominance_Values[] = &#123; 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa&#125;; 计算哈夫曼编码 123456789101112131415void JpegEncoder::_computeHuffmanTable(const char* nr_codes, const unsigned char* std_table, BitString* huffman_table) &#123; unsigned char pos_in_table = 0; unsigned short code_value = 0; for(int k = 1; k &lt;= 16; k++) &#123; for(int j = 1; j &lt;= nr_codes[k-1]; j++) &#123; huffman_table[std_table[pos_in_table]].value = code_value; huffman_table[std_table[pos_in_table]].length = k; pos_in_table++; code_value++; &#125; code_value &lt;&lt;= 1; &#125;&#125; 初始化量化表根据传入的参数调整量化程度，因为这个量化过程是有损的。所以其结果对图像质量有较大影响。 123456789101112131415161718192021222324252627282930// 初始化量化表void JpegEncoder::_initQualityTables(int quality_scale) &#123; if(quality_scale &lt;= 0) &#123; quality_scale = 1; &#125; if(quality_scale &gt;= 100) &#123; quality_scale = 99; &#125; for(int i = 0; i &lt; 64; i++) &#123; int temp = ((int)(Luminance_Quantization_Table[i] * quality_scale + 50) / 100); if (temp &lt;= 0) &#123; temp = 1; &#125; if (temp &gt; 0xFF) &#123; temp = 0xFF; &#125; m_YTable[ZigZag[i]] = (unsigned char)temp; temp = ((int)(Chrominance_Quantization_Table[i] * quality_scale + 50) / 100); if (temp&lt;=0) &#123; temp = 1; &#125; if (temp&gt;0xFF) &#123; temp = 0xFF; &#125; m_CbCrTable[ZigZag[i]] = (unsigned char)temp; &#125;&#125; 写文件头到这里文件头基本已经确定，可以写入JPEG文件了。 RGB 转化成 YCbCr每读取一个 8*8 的方块区域，就进行颜色空间转化。转换式和代码如下： 1234567891011121314151617181920212223Y= 0.299*R + 0.587*G + 0.114*BC_b= -0.168*R – 0.331*G + 0.449*BC_r= 0.5*R – 0.419*G – 0.018*B void JpegEncoder::_convertColorSpace(int xPos, int yPos, char* yData, char* cbData, char* crData) &#123; for (int y = 0; y &lt; 8; y++) &#123; // 跳行 unsigned char* p = m_rgbBuffer + (y + yPos) * m_width * 3 + xPos * 3; for (int x = 0; x &lt; 8; x++) &#123; unsigned char B = *p++; unsigned char G = *p++; unsigned char R = *p++; yData[y * 8 + x] = (char)(0.299f * R + 0.587f * G + 0.114f * B - 128); // yData[y * 8 + x] = 0; cbData[y * 8 + x] = (char)(-0.1687f * R - 0.3313f * G + 0.5f * B ); // cbData[y * 8 + x] = 0; crData[y * 8 + x] = (char)(0.5f * R - 0.4187f * G - 0.0813f * B); // crData[y * 8 + x] = 0; &#125; &#125;&#125; DCT变换和量化DCT变换式和量化代码： 12345678910111213141516171819202122232425// DCT变化 + 量化（未优化）void JpegEncoder::_forward_DCT(const char* channel_data, short* fdc_data) &#123; const float PI = 3.1415926f; for(int v = 0; v &lt; 8; v++) &#123; for(int u = 0; u &lt; 8; u++) &#123; float alpha_u = (u==0) ? 1 / sqrt(8.0f) : 0.5f; float alpha_v = (v==0) ? 1 / sqrt(8.0f) : 0.5f; float temp = 0.f; for(int x = 0; x &lt; 8; x++) &#123; for(int y = 0; y &lt; 8; y++) &#123; float data = channel_data[y * 8 + x]; data *= cos((2 * x + 1) * u * PI / 16.0f); data *= cos((2 * y + 1) * v * PI / 16.0f); temp += data; &#125; &#125; temp *= alpha_u * alpha_v / m_YTable[ZigZag[v * 8 + u]]; fdc_data[ZigZag[v*8+u]] = (short) ((short)(temp + 16384.5) - 16384); &#125; &#125;&#125; 哈夫曼编码 直流分量差分编码 123456789101112 // encode DCint dcDiff = (int)(DU[0] - prevDC);prevDC = DU[0];if (dcDiff == 0) &#123; outputBitString[index++] = HTDC[0];&#125; else &#123; BitString bs = _getBitCode(dcDiff); outputBitString[index++] = HTDC[bs.length]; outputBitString[index++] = bs;&#125; 交流分量游长编码 123456789101112131415161718192021222324252627 // encode ACsint endPos=63; //end0pos = first element in reverse order != 0while((endPos &gt; 0) &amp;&amp; (DU[endPos] == 0)) &#123; endPos--;&#125;for(int i = 1; i &lt;= endPos; ) &#123; int startPos = i; while((DU[i] == 0) &amp;&amp; (i &lt;= endPos)) &#123; i++; &#125; int zeroCounts = i - startPos; if (zeroCounts &gt;= 16) &#123; for (int j = 1; j &lt;= zeroCounts / 16; j++) &#123; outputBitString[index++] = SIXTEEN_ZEROS; &#125; zeroCounts = zeroCounts % 16; &#125; BitString bs = _getBitCode(DU[i]); outputBitString[index++] = HTAC[(zeroCounts &lt;&lt; 4) | bs.length]; outputBitString[index++] = bs; i++;&#125; 对三个通道进行以上同样的操作。（DCT变化-哈夫曼编码-写入） 1234567891011121314151617181920BitString outputBitString[128];int bitStringCounts;// Y通道压缩_forward_DCT(yData, yQuant);_doHuffmanEncoding(yQuant, prev_DC_Y, m_Y_DC_Huffman_Table, m_Y_AC_Huffman_Table, outputBitString, bitStringCounts);_write_bitstring_(outputBitString, bitStringCounts, newByte, newBytePos, fp);// Cb通道压缩_forward_DCT(cbData, cbQuant);_doHuffmanEncoding(cbQuant, prev_DC_Cb, m_CbCr_DC_Huffman_Table, m_CbCr_AC_Huffman_Table, outputBitString, bitStringCounts);_write_bitstring_(outputBitString, bitStringCounts, newByte, newBytePos, fp);// Cr通道压缩_forward_DCT(crData, crQuant);_doHuffmanEncoding(crQuant, prev_DC_Cr, m_CbCr_DC_Huffman_Table, m_CbCr_AC_Huffman_Table, outputBitString, bitStringCounts);_write_bitstring_(outputBitString, bitStringCounts, newByte, newBytePos, fp); 整个流程就是如下图所示： 实验结果测试图片 pic1.bmp 16进制 测试代码 12345678910111213const char* inputFileName = \"pic1.bmp\";JpegEncoder encoder;// 读取BMP格式的文件if(!encoder.readFromBMP(inputFileName)) &#123; return 1;&#125;// 将BMP格式的文件按照JPEG标准压缩成JPEG文件if(!encoder.encodeToJPG(\"out.jpeg\", 50)) &#123; printf(\"jpg\\n\"); return 1;&#125; 读取的BMP文件信息，大小和尺寸都符合原图 测试结果 out.jpeg 十六进制，可以和标准格式比较确实是通过BMP转成了JPEG格式 可以看到，压缩效果还是比较比较明显的，但是编码性能不是最好的，没有对数据前期进行优化，效率只是中规中矩。下面介绍对流程和结果的测试分析过程流程： 分析为什么转换成YCbCr域对色域的压缩会让人接受：从RGB到YCbCr的转换公式我们可以分析出Y所占比重较高，说明应该存储的细节相对较多，和人眼对亮度更加敏感符合。那么事实是否如此？ 从左到右依次是 Y（72.8k），Cb（37.4k），Cr（33.9k）分量，从光感上说，明显是Y的灰度图像给出了细节，其它两个分量只是给出色彩，没有细节。接着从大小分析也和我们的预测符合，大概比例是 2：1：1，说明存储的细节越多所需的空间自然越大。接下来对BMP原始通道RGB加扰动和YCbCr加相同的扰动，对图像的影响又会怎样？ 从左到右一次是在RGB通道和YCbCr通道加干扰。可以看到RGB收干扰的程度更大，原因不大好用数学分析，我觉得很可能是RGB通道对干扰是没有减弱直接进入通道转换，而YCrCb则是在色度通道进行压缩了，同时也是对干扰的舍弃，所以效果比较好。 下面分析为什么量化矩阵对结果会有很大影响，可以做一个实验，改变生成量化矩阵的算法，看看结果如何。 这两张的量化程度不同，但是可以看到的是他们都有或多或少的呈色块显示迹象，所以应该存储的空间应该是很小的。结果也确实如此，回到问题，我们的量化矩阵没有优化，造成数值过大，在量化过程中，导致过多数为0，也就是那些高频分量，而高频正是细节的体现，失去高频自然就失去了细节。所以量化矩阵的取值直接关系到了生成图像的品质。 以上是我对BMP转换成JPEG的过程分析，同时也辅以代码加以实现和测试。对于JPEG的解码过程那就是过程的逆过程了，但是由于编码是有损的，而且编码表量化表都是有转型损失的，所以解码之后的图像也会有部分损失。着呢个过程和读取解码BMP一样。先读取文件头，接下来初始化表，再就是直接读取数据根据表解码出YCbCr的值，反量化之后通过DCT逆变换还原。 其中的源码是thecodeway提供的，欢迎大家去他的 Blog 看看他的图像分析文章，我只是对他的代码加以自己的理解。 最后：如有不足，欢迎指正，共同进步。 多谢阅读 参考资料[1] 足迹 : https://www.cnblogs.com/Matrix_Yao/archive/2009/12/02/1615295.html [2] lakeone : https://www.cnblogs.com/lakeone/p/3596996.html [3] thecodeway : https://thecodeway.com/blog/?p=522 [4] SoC Design Lab http://twins.ee.nctu.edu.tw/courses/soclab_04/lab_hw_pdf/proj1_jpeg_introduction.pdf","tags":[{"name":"Algo","slug":"Algo","permalink":"http://fitzeng.org/tags/Algo/"},{"name":"Math","slug":"Math","permalink":"http://fitzeng.org/tags/Math/"},{"name":"C/C++","slug":"C-C","permalink":"http://fitzeng.org/tags/C-C/"},{"name":"图像处理","slug":"图像处理","permalink":"http://fitzeng.org/tags/图像处理/"}]},{"title":"Android 单元测试和 Robolectric 源码解析","date":"2017-05-13T16:00:00.000Z","path":"2017/05/14/Android 单元测试和 Robolectric 源码解析/","text":"前言作为一个 Android 开发的程序员，最痛苦的事情其实莫过于测试了，龟速的模拟器和麻烦的手机，基本上每测试一次都要浪费 1-2 min 去加载程序。而有了 Robolectric 这些就可以避免了。至于 Robolectric 的介绍推荐大家看看官网 （其中的用户指导是很好的学习资料）。我们用他的很大一个原因是他不需要再去把程序加载到 Android 手机或者模拟器中运行，他有自己的实现，能够调用 Android 中的很多库，下面的源码分析会提及。可是 Android Studio 对 Robolectric 不是很友好，而且在 Google 的官方教程中的测试工具也不是这个。。。同时 Robolectric 对于 Android Studio 的教程介绍似乎还是停留在 1.x 阶段，但是在 2.x 中的使用略有不同。 讲了这么多，所以 Robolectric 和 Junit 4 有什么不同？不都是测试吗？我的理解是 Junit 4 与 Robolectric 的关系和 Java 与 Android 的关系差不多。毕竟 Robolectric 是个第三方的测试库，其中很多还是要用到 Junit 的。 好了，基本的介绍完成了，下面开始使用，但是使用不是我们这次的重点，重点是源码分析。但是源码分析也是建立在知道使用的基础上，如果你之前没有使用过，推荐你看官方的 user guide。或者这两篇 Blog。 Android单元测试框架Robolectric3.0介绍(一) Android单元测试框架Robolectric3.0介绍(二) 准备其实前面 Blog 的介绍可能会有点偏差，现在的 Android Studio 2.3.1 在建立工程时除了自己的源码包，还有两个，分别是 test 和 androidTest。经过我的尝试， test 包下的测试文件可以直接测试，而 androidTest下面的还是要 android 运行环境的。个人更倾向于一个用做单元测试一个用于集成测试这种理解。所以在导入依赖包时要注意了。 121. testCompile \"org.robolectric:robolectric:3.3.2\"2. androidTestCompile \"org.robolectric:robolectric:3.3.2\" 第一种对应的测试文件要放在 test 包下，而第二种就是放在 androidTest 包下，如果搞错，你的 Robolectric 中的测试方法是无法使用的。 123456789101112dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support.constraint:constraint-layout:1.0.2' testCompile 'junit:junit:4.12' testCompile 'org.robolectric:robolectric:3.3.2' sourceCompatibility = 1.8 targetCompatibility = 1.8&#125; 至于运行的话，大家可以直接右键文件，title bar 点击运行或者在 cmd 运行都行。但是有一点要注意，一定要配置文件的 working directory，不然找不到 manifest.xml 等文件。 测试写一个如下布局 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"org.fitzeng.robolectrictest.MainActivity\"&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:id=\"@+id/et\" android:text=\"@string/app_name\" android:maxLines=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;Button android:id=\"@+id/btn_et\" android:text=\"EditText Test\" android:textAllCaps=\"false\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 1234567891011121314151617181920212223242526272829303132public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private EditText editText; private Button btnEt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); &#125; private void initViews() &#123; editText = (EditText) findViewById(R.id.et); btnEt = (Button) findViewById(R.id.btn_et); btnEt.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_et: &#123; btnEt.setText(editText.getText().toString()); break; &#125; default: break; &#125; &#125;&#125; 可以看到，这里就是测试一下点击事件，看看点击之后是否能获取 EditText 中的文本内容。 下面开始写测试代码，注意之前如果配置的是 testCompile 的话一定要把测试文件建在 test 包下，不然无法导入 Robolectric 。 1234567891011121314151617181920212223242526272829@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class, sdk = 24)public class MainActivityTest &#123; private Button btnEt; private EditText editText; @Before public void setUp() &#123; // get mainActivity obj MainActivity mainActivity = Robolectric.setupActivity(MainActivity.class); // get button btnEt = (Button) mainActivity.findViewById(R.id.btn_et); // get edittext editText = (EditText) mainActivity.findViewById(R.id.et); &#125; @Test public void testMainActivity() &#123; // simulate click event btnEt.performClick(); // get button content String expectedContent = btnEt.getText().toString(); // get edittext content String actualContent = editText.getText().toString(); // compare expectedContent and actualContent Assert.assertEquals(expectedContent, actualContent); &#125;&#125; 上面的代码我都加了注释，基本过程很清楚了，这里点击事件是只要点击，我们就把 EditText 中的文本替换 Button 的文本。测试结果如下：可以看到花的 27s 完成了点击测试，很方便。大家可以试试测试失败会是什么情况。 这里并没有开启模拟器，但是却完成了整个点击事件并进行了检测。事件虽小，但是意义很大。意味着我们不需要开启模拟器也可以对 Android 程序进行测试了。 源码分析在开始这个流程的分析之前，如果你之前对 Junit 没有任何了解，可以看看 Junit 的分析，这里仿照 Junit 对 Robolectric 进行类比分析。可以找到 Junit 的 main 入口下面一步一步分析就好了。 但是 Robolectric 代码量实在太大，去里面找东西实在太难，但是凭借程序员的直觉，相信大家最先找到的有价值的文件可能是下面几个：其中看到测试生命周期是不是眼前一亮？还有 Robolectric 类里面的函数，包含了 Fragment， AttributeSet， Activity， Service， IntentService， ContentProvider 等等熟悉的内容。可以肯定，这里就是“宇宙中心”。上面的测试代码其实也验证了这个观点。再看看 RobolectricTestRunner 这个类，还是和 Junit 4 有一腿的。里面的方法无非就是做一些初始化的工作，注释说的很明确了，就是提供一个模拟的 Android 运行时环境（和前面说的加载 manifest文件有关），这也是为什么可以直接在没有模拟器的情况下进行一些模拟点击测试的原因。 123456789/** * Installs a &#123;@link SandboxClassLoader&#125; and &#123;@link ResourceTable&#125; in order to * provide a simulation of the Android runtime environment. */// public class RobolectricTestRunner extends SandboxTestRunner// public class SandboxTestRunner extends BlockJUnit4ClassRunner// public class BlockJUnit4ClassRunner extends ParentRunner&lt;FrameworkMethod&gt;// public abstract class ParentRunner&lt;T&gt; extends Runner implements Filterable,Sortable// public abstract class Runner implements Describable 这样没有实例只看源码有点不知道往哪个方向解析，所以我们开始从源码角度看看前面测试过程怎么执行的来加深理解。 最开始是调用了 Robolectric.setupActivity(Class) 那么我们就从这里入手。 step 1 : Robolectric.setupActivity(Class)123public static &lt;T extends Activity&gt; T setupActivity(Class&lt;T&gt; activityClass) &#123; return buildActivity(activityClass).setup().get();&#125; 首先是获取 Activity 对象，正好 setUpActivity(Class) 是返回一个 Activity 对象的。那么是如何获取到的呢？那就要看源码具体实现了。大概过程是建立一个 Activity 然后 setup 一下再获取对象。 step 2.1 : Robolectric.buildActivity(Class)123public static &lt;T extends Activity&gt; ActivityController&lt;T&gt; buildActivity(Class&lt;T&gt; activityClass) &#123; return buildActivity(activityClass, null);&#125; step 2.2 : Robolectric.buildActivity(Class, Intent)123public static &lt;T extends Activity&gt; ActivityController&lt;T&gt; buildActivity(Class&lt;T&gt; activityClass, Intent intent) &#123; return ActivityController.of(getShadowsAdapter(), ReflectionHelpers.callConstructor(activityClass), intent);&#125; 到这里就可以看到利用这个类名和 Intent （null），采用反射机制可以获取这个类的对象。有兴趣的还可以深究下去。 step 3.1 : Robolectric.buildActivity(activityClass).setup()12345678910111213141516171819202122/*** Calls the same lifecycle methods on the Activity called by Android the first time the Activity is created.** @return Activity controller instance.*/public ActivityController&lt;T&gt; setup() &#123; return create().start().postCreate(null).resume().visible();&#125;/** * Calls the same lifecycle methods on the Activity called by Android when an Activity is restored from previously saved state. * * @param savedInstanceState Saved instance state. * @return Activity controller instance. */public ActivityController&lt;T&gt; setup(Bundle savedInstanceState) &#123; return create(savedInstanceState) .start() .restoreInstanceState(savedInstanceState) .postCreate(savedInstanceState) .resume() .visible();&#125; 前面的两个函数的注释很清楚，第一个是 Activity 第一次调用时调用，第二个是 Activity 之前被调用过并且在 Bundle 对象中保存了实例状态，可以将 Bundle 中的数据作为参数直接调用函数加载。返回的是一个 Activity 控制器实例。 step 3.2 : setup() -&gt; create().start().postCreate(null).resume().visible()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ActivityController.create()public ActivityController&lt;T&gt; create() &#123; return create(null);&#125;public ActivityController&lt;T&gt; create(final Bundle bundle) &#123; shadowMainLooper.runPaused(new Runnable() &#123; @Override public void run() &#123; ReflectionHelpers.callInstanceMethod(Activity.class, component, \"performCreate\", from(Bundle.class, bundle)); &#125; &#125;); return this;&#125;ActivityController.start()public ActivityController&lt;T&gt; start() &#123; invokeWhilePaused(\"performStart\"); return this;&#125;ActivityController.postCreate(Bundle)public ActivityController&lt;T&gt; postCreate(Bundle bundle) &#123; invokeWhilePaused(\"onPostCreate\", from(Bundle.class, bundle)); return this;&#125;ActivityController.resume()public ActivityController&lt;T&gt; resume() &#123; invokeWhilePaused(\"performResume\"); return this;&#125;ActivityController.visible()public ActivityController&lt;T&gt; visible() &#123; shadowMainLooper.runPaused(new Runnable() &#123; @Override public void run() &#123; ReflectionHelpers.setField(component, \"mDecor\", component.getWindow().getDecorView()); ReflectionHelpers.callInstanceMethod(component, \"makeVisible\"); &#125; &#125;); ViewRootImpl root = component.getWindow().getDecorView().getViewRootImpl(); if (root != null) &#123; // If a test pause thread before creating an activity, root will be null as runPaused is waiting // Related to issue #1582 Display display = Shadow.newInstanceOf(Display.class); Rect frame = new Rect(); display.getRectSize(frame); Rect insets = new Rect(0, 0, 0, 0); final RuntimeAdapter runtimeAdapter = RuntimeAdapterFactory.getInstance(); runtimeAdapter.callViewRootImplDispatchResized( root, frame, insets, insets, insets, insets, insets, true, null); &#125; return this;&#125; 这里看起来代码量有点多，但是大概意思应该就是为 Activity 提供一个 Android 运行环境的保障。从 Window ， DecorView 之类的就可以确认我们的想法。如果不熟悉的话可以再去了解 Android 的界面绘制过程，这里目前知道这层意思就可以了。 step 4 : Robolectric.buildActivity(activityClass).setup().get()123public T get() &#123; return component;&#125; 。。。我看到这里首先的感觉是一脸懵逼，怎么这么简单，我们的预期是返回一个 Activity 对象，也就是一个组件，从意思来看可以理解，但是这个 component 是怎么来的？下面就来慢慢分析。 1234567891011121314151617181920212223242526public abstract class ComponentController&lt;C extends ComponentController&lt;C, T&gt;, T&gt; &#123; protected final C myself; protected T component; protected final ShadowLooperAdapter shadowMainLooper; protected Intent intent; protected boolean attached; @SuppressWarnings(\"unchecked\") public ComponentController(ShadowsAdapter shadowsAdapter, T component, Intent intent) &#123; this(shadowsAdapter, component); this.intent = intent; &#125; @SuppressWarnings(\"unchecked\") public ComponentController(ShadowsAdapter shadowsAdapter, T component) &#123; myself = (C) this; this.component = component; shadowMainLooper = shadowsAdapter.getMainLooper(); &#125; public T get() &#123; return component; &#125;&#125; 看到这里我们可以确认的是 component 是来自 ComponentController() 构造函数来进行初始化的，这是你会发祥一个很熟悉的参数 ShadowsAdapter ，看看这个类。看完之后你会发现这其实是一个接口。这时你要思考的是，这些参数怎么来的，不可能凭空产生，肯定是在你的类生成 Activity 组件过程中构造的。看看 step 2.2 中的函数你会发现，第一个就是 getShadowsAdapter()，第二个是 ReflectionHelpers.callConstructor(activityClass)， 是不是发现了点什么，就是从这里开始，埋下了种子。同时 step 3.2 中有component ，发现他就是抽象类 ComponentController 中的变量，而且是 protected 的。那么现在唯一的猜想就是 ActivityController 继承自 ComponentController ，从类的命名来说是很合理的。那么源码是这样的吗？ 12// public class ActivityController&lt;T extends Activity&gt; extends org.robolectric.util.ActivityController&lt;T&gt; // abstract public class ActivityController&lt;T extends Activity&gt; extends ComponentController&lt;org.robolectric.android.controller.ActivityController&lt;T&gt;, T&gt; 看到这说明我们的想法完全正确！总算弄清楚 component 的身份，但是还是不知道他是怎么生成的？我们的预测是和 Activity 要有关联，目前的分析还看不出来，而且这里的 step 3.2 中的 component 直接作为参数传递了，说明在之前就已经被初始化了，也就是构造函数 ComponentController(ShadowsAdapter shadowsAdapter, T component) 已经被调用了。那么我们还是要回到 step 2.2 中的 ActivityController.of(getShadowsAdapter(), ReflectionHelpers.callConstructor(activityClass), intent) 因为那是 Activity 的消失和 component 出现的临界点。开始看看 of 函数。 123456789public static &lt;T extends Activity&gt; ActivityController&lt;T&gt; of(ShadowsAdapter shadowsAdapter, T activity, Intent intent) &#123; return new ActivityController&lt;&gt;(shadowsAdapter, activity, intent).attach();&#125;private ActivityController(ShadowsAdapter shadowsAdapter, T activity, Intent intent) &#123; super(shadowsAdapter, activity, intent); this.shadowsAdapter = shadowsAdapter; shadowReference = shadowsAdapter.getShadowActivityAdapter(this.component);&#125; 这时看到 activity 传给了super，应该有点警觉，前面不是验证了 ActivityController 继承自 ComponentController 吗？而 component 又是在 ComponentController 中的，难道。。。 接着 super 123456789101112protected ActivityController(ShadowsAdapter shadowsAdapter, T activity, Intent intent) &#123; super(shadowsAdapter, activity, intent);&#125;public ComponentController(ShadowsAdapter shadowsAdapter, T component, Intent intent) &#123; this(shadowsAdapter, component); this.intent = intent;&#125;public ComponentController(ShadowsAdapter shadowsAdapter, T component) &#123; myself = (C) this; this.component = component; shadowMainLooper = shadowsAdapter.getMainLooper();&#125; 费了这么一大圈最终还是找到了，就是和之前的猜想一致。就是 Activity 经过一系列的操作 (这里操作是指 ReflectionHelpers.callConstructor(activityClass), intent) ) 最终直接传递给 component 。 所以获取 Activity 对象的分析就告一段落了。至于构建细节，怎么在 JVM 中绘制 View 的我也不怎么清楚，要想了解可以对 step 3.1 中的函数进一步深究。我大概可以确定应该是在那个过程中完成的。 过程总结看图 模拟点击 -&gt; performClick()接下来就是根据获取的 Activity 来获取布局中的控件进行测试。 这里分析的是一个点击事件： 12345678910111213141516171819202122/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 你会发现这里的 performClick() 中其实是调用了 onClick() 的。下面就是要验证确定会执行这个点击事件。首先 li != null 这个条件是怎么成立的？ 12345678static class ListenerInfo &#123; /** * Listener used to dispatch focus change events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ ......&#125; 通过上述代码你会发现这是一个 View 的静态内部类。所以其实 mListenerInfo 应该是类中的一个变量。那么这个变量是在何时被初始化的呢？ 123456789ListenerInfo mListenerInfo;ListenerInfo getListenerInfo() &#123; if (mListenerInfo != null) &#123; return mListenerInfo; &#125; mListenerInfo = new ListenerInfo(); return mListenerInfo;&#125; 经过一番查找可以肯定的是，前面应该是调用了 getListenerInfo() 函数。而对于一个 Button 的 listenerInfo 凭直觉可以猜测下很大可能是 setOnClickListener() 中调用的。因为设置点击监听应该是要获取监听信息的吧。。。再就是前面除了对 Button 设置了点击事件就没做其他操作了，而且如果事件得到触发的话意味着 mListenerInfo 一定是被初始化了的。种种猜测都指向 setOnClickListener() ，那就看看源码吧。 1234567891011121314/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125; 确实是如此，如果你没有进行前面的猜测的话，可以直接搜这个函数看看在哪些地方调用了，这时你会发现一个共同点：所有和视图监听有关的函数都有调用 getListenerInfo() 。至于为什么这样？很简单，因为他们都是 Listener ，自然需要 ListenerInfo 来确定自己是什么监听，并且通过 ListenerInfo 进行管理，只要 ListenerInfo 中的某个变量是 null 就意味着这个 Listener 是未注册的。这点可以从 li.mOnClickListener != null 这个条件验证，也就是前面点击事件的触发条件。 1234567891011121314151617public void setOnScrollChangeListener(OnScrollChangeListener l) &#123; getListenerInfo().mOnScrollChangeListener = l;&#125;public void setOnFocusChangeListener(OnFocusChangeListener l) &#123; getListenerInfo().mOnFocusChangeListener = l;&#125;public void addOnLayoutChangeListener(OnLayoutChangeListener listener) &#123; ListenerInfo li = getListenerInfo(); if (li.mOnLayoutChangeListeners == null) &#123; li.mOnLayoutChangeListeners = new ArrayList&lt;OnLayoutChangeListener&gt;(); &#125; if (!li.mOnLayoutChangeListeners.contains(listener)) &#123; li.mOnLayoutChangeListeners.add(listener); &#125;&#125; 好了，点击事件就分析到这，总结一下：最开始就是设置监听，设置监听过程中会在 View 中将点击事件用 ListenerInfo 记录。在模拟点击事件中调用 performClick() ，下面就是对事件是否注册来确定是否触发点击事件。 之后就是自己写逻辑了，对你的预期和模拟跑出来的结果是否一致进行测试。这里就是 Junit 内容了。 总结通过这次源码分析，发现只要细心，很多大牛的代码慢慢读也是可以读懂的。虽然代码量太大不可能一行不落地阅读，但是从一个小例子出发，慢慢分析就可以得出你自己理解，其实代码的逻辑就是常人的逻辑，其中值得学习的恰恰是这种常人逻辑之间的协调和对代码整个的宏观把控。 这是我第一次写关于源码分析的文章，其中肯定有很多不足，欢迎大家指正。还有推荐下我的个人 Blog 最后感谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"Android Unit Test","slug":"Android-Unit-Test","permalink":"http://fitzeng.org/tags/Android-Unit-Test/"}]},{"title":"实现一个类似QQ的社交聊天工具-4","date":"2017-04-14T06:00:00.000Z","path":"2017/04/14/ZZChatApp4/","text":"GitHub 实现一个类似QQ的社交聊天工具-4准备做好【ZZChatApp3】中的内容并且下载了实现一个类似QQ的社交聊天工具-1中的资料就可以开始下面的了环境自己尝试是否能配好，下面只是给出一些提示和建议。Xampp + Java EE 实现目标这里已经实现基本的通讯了。由于最近特别忙，所以打算写两篇的网络编程总结成一篇，细节应该都会提到，只是不会太详细。希望大家多利用身边的网络资源。基本在网上都有现成的答案。 实现过程 这就是大体的方向，所以目前目标很简单，为了不打断以后的编码思路，前期工作要做好。 环境配置 下载Xampp 开启 Apache 和 mySql, 在浏览器中输入 127.0.0.1: 看看有 Xampp 界面就成功，点击 admin 出现数据库就说明数据库可以访问了。 至于 Java EE 自身是不携带 WindowBuilder 也就是你无法使用 JFrame 的图形界面进行设计。怎么安装动手搜搜就知道了。之后就只要添加访问数据库的一个库到工程里面。在资料4已经给出，导入 buildpath 就可以了。 数据库创建 这里只是效果图，数据库的内容我们通过代码来创建，可以保证每一次的测试环境一样。 通讯协议这一部分的目的是数据解析要用到的。可以这样想，我发送一个登录消息和聊天消息服务器能区分吗？如果能够区分，那是怎么区分的？这就是设计通讯协议的最原始原因。其实如果学过网络通讯就知道，TCP/IP协议有个头，这个头就存在这某些信息，代表着自己身份，之后的信息就按这身份的协议去解析。这里就用一个很简单的 [Action]:[info, info, … , info] 来作为对象传输。[Action]就是一个头，后面连着消息，至于消息如何解析，就要看你自己协议的具体约定了。这里我提供一个很简陋的在资源4中，也就是 Version lab版 所遵守的协议。 服务端这里我们使用 socket 来编写。如果之前你没有接触过这方面，可能现在想知道手机怎么和电脑通讯？别急，先看看这个例子在电脑上怎么访问自己写的服务器。 演示很简单，就是一个简单的界面来开启服务，如果你是测试,可以先不编写界面，直接运行就开启服务 serverListener.start(); 之后在cmd telnet 中通过 127.0.0.1 这个 IP 访问端口 27777 。可以看到控制台输出 “haha”， 如果你的电脑没有 telnet 可以开启或者直接在浏览器中访问 127.0.0.1:27777. 效果一样。这是就代表有一个和服务器建立的连接。 从这里可以猜想，手机如果连接的是电脑的无线，也就是处于同一个局域网内的话，是不是也可以访问到浏览器。可以试试，手机连接电脑无线，那么通过什么访问端口呢？ 127.0.0.1？仔细思考就知道应该是行不通的，手机和电脑建立的连接走的是哪条线路呢？我们连的是无线，所以通过无线适配器和电脑建立连接，所以我们要访问电脑上的端口肯定是要经过这个适配器的。所以找到无线网络适配器的 IPv4, 就可以 通过 IPv4:27777 访问了。 下面解释一下代码。 1234567891011121314151617public class ServerListener extends Thread&#123; private ServerSocket serverSocket; @Override public void run() &#123; try &#123; serverSocket = new ServerSocket(27777, 27); while (true) &#123; Socket socket = serverSocket.accept(); System.out.println(\"haha\"); ChatSocket chatSocket = new ChatSocket(socket); chatSocket.start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以看到，这是一个死循环。只要不发生异常和手动关闭，这段代码是会一直运行下去的。其中 1Socket socket = serverSocket.accept(); 这一行是关键，代表的是没有 socket 接入的话，程序会一直阻塞在这句代码处，一旦有 socket 接入，则返回一个 socket ，由于一个服务器必然是有多个客户端连接的。所以我们给每个 socket 连接都分配一个线程并且开启线程，接着循环进入阻塞，直到有下一个连接建立，重复上述步骤。这就是这段代码的运行状态。 现在假设有线程已经开启了。怎么接收数据？ socket 是以流的形式传输数据。所以只要获取流，再将这个流进行相关操作就行了。下面解释一下我们的主要代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ChatSocket extends Thread&#123; private Socket socket; private String message = null; private BufferedReader bufferedReader; private BufferedWriter bufferedWriter; public ChatSocket(Socket s) &#123; this.socket = s; try &#123; this.bufferedReader = new BufferedReader(new InputStreamReader(s.getInputStream(), \"UTF-8\")); this.bufferedWriter = new BufferedWriter(new OutputStreamWriter(s.getOutputStream(), \"UTF-8\")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; try &#123; String line = null; while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; message += line; &#125; else &#123; delMessage(message); line = null; message = null; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; MainWindow.getMainWindow().setShowMsg(this.username + \" login out !\"); MainWindow.getMainWindow().removeOfflineUsers(this.username); ChatManager.getChatManager().remove(socketMsg); bufferedWriter.close(); bufferedReader.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 首先定义一个 BufferedReader 和 BufferedWriter ，作用是接受客户端的数据和向客户端发送数据。很好记，Reader 对于自己来说就是读取别处的数据，Writer 是向目标对象写数据。所以 BufferedReader 是接受客户端的数据，BufferedWriter 是向客户端发送数据。 那么如何获取呢？ 在构造函数中可以看到这两句 12this.bufferedReader = new BufferedReader(new InputStreamReader(s.getInputStream(), \"UTF-8\"));this.bufferedWriter = new BufferedWriter(new OutputStreamWriter(s.getOutputStream(), \"UTF-8\")); 可以一起写也可以分开。如下： 123456// 从 socket 获取输入流InputStream inputStream = s.getInputStream();// 将位流通过 “UTF-8” 的格式读取为字符流InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");// 将字符流放入 Buffer。方便使用BufferedReader bufferedReader = new BufferedReader(inputStreamReader); 多想想整个数据的传输过程就很明朗了。有点像 OSI 的那个七层模型，一层一层封装与解封装。 上面只是获取到了流，并没有进行数据读写操作。开始下面介绍读取流中的数据。 12345678910String line = null;while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; message += line; &#125; else &#123; delMessage(message); line = null; message = null; &#125;&#125; 看着有点乱。。再看一下下面的吧。 1234567891011121314public void sendMsg(String msg) &#123; try &#123; while (socket == null) ; if (bufferedWriter != null) &#123; System.out.println(\"send :\" + msg); bufferedWriter.write(msg + \"\\n\"); bufferedWriter.flush(); bufferedWriter.write(\"-1\\n\"); bufferedWriter.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 可以清楚的看到，发送消息之后后面会加一个 “-1” 作为消息的终止符，也就是接接收方在接收到 -1 时，说明前面的数据是作为一整个信息的，将数据传出进行处理。接着清空继续接收接下来的消息，循环往复。可以看到 bufferedReader 这个流只要不关闭，这个会永远循环下去。 好了消息的发送和接收都基本算是处理好了，接下来就是数据处理，数据处理必然是要依赖协议的。所以依赖协议自己实现如下的函数。 123456789101112131415161718192021222324public void delMessage(String msg) &#123; if (msg != null) &#123; String action = getAction(msg); switch(action) &#123; case \"LOGIN\": &#123; dealLogin(msg); break; &#125; case \"REGISTER\": &#123; dealRegister(msg); break; &#125; case \"DRESSUP\": &#123; dealDressUp(msg); break; &#125; case \"GETDRESSUP\": &#123; dealGetDressUp(msg); break; &#125; case \"PROFILE\": &#123; dealProfile(msg); break; &#125; case \"GETPROFILE\": &#123; dealGetProfile(msg); break; &#125; case \"GETFRIENDLIST\": &#123; dealGetFriendList(msg); break; &#125; case \"GETGROUPLIST\": &#123; dealGetGroupList(msg); break; &#125; case \"GETFRIENDPROFILE\": &#123; dealGetFriendProfile(msg); break; &#125; case \"STATE\": &#123; dealState(msg); break; &#125; case \"CHATMSG\": &#123; dealChatMsg(msg); break; &#125; case \"USERLIST\": &#123; dealUserList(msg); break; &#125; case \"ADDFRIEND\": &#123; dealAddFriend(msg); break; &#125; case \"GROUPMEMBERLIST\": &#123; dealGroupMemberList(msg); break; &#125; case \"ADDGROUP\": &#123; dealAddGroup(msg); break; &#125; case \"GETALLGROUPLIST\": &#123; dealGetAllGroupList(msg); break;&#125; default : dealError(); break; &#125; &#125;&#125; 服务端的线程是随连接数的增加而增加，所以创建一个线程管理的类（ChatManager）就有必要了，这样我们可以轻松的对消息进行跨进程转发（聊天）。 1234567891011121314151617181920212223242526272829303132333435public class ChatManager &#123; private ChatManager()&#123;&#125;; List&lt;SocketMsg&gt; socketList = new ArrayList&lt;&gt;(); private static final ChatManager chatManager = new ChatManager(); public static ChatManager getChatManager() &#123; return chatManager; &#125; public void add(SocketMsg cs) &#123; socketList.add(cs); &#125; public void remove(SocketMsg cs) &#123; socketList.remove(cs); &#125; &#125;public class SocketMsg &#123; private ChatSocket chatSocket; private String username; public SocketMsg(ChatSocket chatSocket, String username) &#123; this.chatSocket = chatSocket; this.username = username; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public ChatSocket getChatSocket() &#123; return chatSocket; &#125; public void setChatSocket(ChatSocket chatSocket) &#123; this.chatSocket = chatSocket; &#125;&#125; 就是这么简单。 服务端基本就讲到这里。细心的人会发现我们的接收消息和发送消息是不在同一个线程中的，稍微思考思考对客户端的代码编写有好处。 客户端在不考虑信息处理的情况下客户端仿照服务端很容易写出接受发送流的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758server/ServerManager.javapublic class ServerManager extends Thread &#123; private static final String IP = \"192.168.191.1\"; private Socket socket; private String message = null; private BufferedReader bufferedReader; private BufferedWriter bufferedWriter; public static ServerManager getServerManager() &#123; return serverManager; &#125; private ServerManager() &#123; &#125; public void run() &#123; try &#123; socket = new Socket(IP, 27777); bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\")); bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), \"UTF-8\")); String m = null; String line; while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; m += line; &#125; else &#123; Log.d(\"TAG\", \"receive : \" + m); if (ParaseData.getAction(m).equals(\"GETCHATMSG\")) &#123; receiveChatMsg.delChatMsg(m); &#125; else &#123; message = m; &#125; m = null; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bufferedWriter.close(); bufferedReader.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void sendMessage(Context context, String msg) &#123; try &#123; while (socket == null) ; if (bufferedWriter != null) &#123; bufferedWriter.write(msg + \"\\n\"); bufferedWriter.flush(); bufferedWriter.write(\"-1\\n\"); bufferedWriter.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码是不是很熟悉？基本和服务端没什么变化，因为毕竟这是要和服务端建立连接的。 可以看到这是一个线程，所以从哪里开启这个线程呢？我是在这里： 12345678AtyLoginOrRegister.javapublic class AtyLoginOrRegister extends AppCompatActivity implements View.OnClickListener &#123; private ServerManager serverManager = ServerManager.getServerManager(); private void initViews() &#123; serverManager.start(); &#125;&#125; 下面就是进行数据传输处理了，我举两个例子。 数据传输 登录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AtyLoginOrRegister extends AppCompatActivity implements View.OnClickListener &#123; private void initViews() &#123; btnLogin.setOnClickListener(this); btnRegister.setOnClickListener(this); serverManager.start(); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_login: &#123; String username = etLoginUsername.getText().toString(); String password = etLoginPassword.getText().toString(); if (login(username, password)) &#123; serverManager.setUsername(username); Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); &#125; else &#123; etLoginUsername.setText(\"\"); etLoginPassword.setText(\"\"); &#125; break; &#125; case R.id.btn_register: &#123; Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); break; &#125; default: break; &#125; &#125; private boolean login(String username, String password) &#123; // check username and password whether legal if (username == null || username.length() &gt; 10 || password.length() &gt; 20) &#123; return false; &#125; // send msg to servers String msg = \"[LOGIN]:[\" + username + \", \" + password + \"]\"; serverManager.sendMessage(this, msg); // get msg from servers return String ack = serverManager.getMessage(); // deal msg if (ack == null) &#123; return false; &#125; serverManager.setMessage(null); String p = \"\\\\[ACKLOGIN\\\\]:\\\\[(.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(ack); return matcher.find() &amp;&amp; matcher.group(1).equals(\"1\"); &#125;&#125; 既然是登录，那么事件是发生在按钮的点击之后。下面我们来理一下登录过程： 点击登录按钮-&gt;获取登录信息-&gt;封装信息传输-&gt;服务端接收-&gt;解析信息-&gt;从服务器获取信息进行登录验证-&gt;返回验证结果-&gt;客户端获取数据-&gt;解析信息-&gt;进行登录状态调整 这就是一整个流程。下面就具体介绍。 点击登录按钮 1234case R.id.btn_login: &#123; String username = etLoginUsername.getText().toString(); String password = etLoginPassword.getText().toString();&#125; 获取登录信息 12String username = etLoginUsername.getText().toString();String password = etLoginPassword.getText().toString(); 封装信息传输 12345if (username == null || username.length() &gt; 10 || password.length() &gt; 20) &#123; return false;&#125;String msg = \"[LOGIN]:[\" + username + \", \" + password + \"]\";serverManager.sendMessage(this, msg); 服务端接收 1234567891011String line = null;while ((line = bufferedReader.readLine()) != null) &#123; if (!line.equals(\"-1\")) &#123; message += line; &#125; else &#123; delMessage(message); System.out.println(\"receive : \" + message); line = null; message = null; &#125;&#125; 解析信息 123456789String iusername = null;String iPassword = null;String p = \"\\\\[LOGIN\\\\]:\\\\[(.*), (.*)\\\\]\";Pattern pattern = Pattern.compile(p);Matcher matcher = pattern.matcher(msg);if (matcher.find()) &#123; iusername = matcher.group(1); iPassword = matcher.group(2);&#125; 从服务器获取信息进行登录验证 &amp;&amp; 返回验证结果 1234567891011121314151617String sql = \"SELECT password FROM USERS WHERE username = '\" + iusername + \"';\";try &#123; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql); if (resultSet.next() &amp;&amp; iPassword.equals(resultSet.getString(1)) ) &#123; sendMsg(\"[ACKLOGIN]:[1]\"); this.username = iusername; MainWindow.getMainWindow().setShowMsg(this.username + \" login in!\"); MainWindow.getMainWindow().addOnlineUsers(this.username); socketMsg = new SocketMsg(this, this.username); ChatManager.getChatManager().add(socketMsg); return ; &#125;&#125; catch (SQLException e) &#123; e.printStackTrace();&#125;sendMsg(\"[ACKLOGIN]:[0]\"); 客户端获取数据 1String ack = serverManager.getMessage(); 解析信息 12345678if (ack == null) &#123; return false;&#125;serverManager.setMessage(null);String p = \"\\\\[ACKLOGIN\\\\]:\\\\[(.*)\\\\]\";Pattern pattern = Pattern.compile(p);Matcher matcher = pattern.matcher(ack);return matcher.find() &amp;&amp; matcher.group(1).equals(\"1\"); 进行登录状态调整 123456789if (login(username, password)) &#123; serverManager.setUsername(username); Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish();&#125; else &#123; etLoginUsername.setText(\"\"); etLoginPassword.setText(\"\");&#125; 发送信息 流程一样只是处理消息的时候复杂一点，因为我们只为聊天设置一个协议。所以要提高信息的区分度而对数据进行的繁复操作是必须的。 发送： 1234567891011121314151617181920212223242526272829303132333435363738394041btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String content = myMsg.getText().toString(); if (!content.isEmpty()) &#123; ChatMsg msg = new ChatMsg(); msg.setContent(content); msg.setUsername(ServerManager.getServerManager().getUsername()); msg.setIconID(ServerManager.getServerManager().getIconID()); msg.setMyInfo(true); msg.setChatObj(chatObj); msg.setGroup(group.equals(\"0\") ? chatObj : \" \"); if (sendToChatObj(msg.getContent())) &#123; ChatMsg.chatMsgList.add(msg); chatMsgList.add(msg); myMsg.setText(\"\"); &#125; else &#123; Toast.makeText(AtyChatRoom.this, \"send failed\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125;);private boolean sendToChatObj(String content) &#123; String msg = \"[CHATMSG]:[\" + chatObj + \", \" + content + \", \" + ServerManager.getServerManager().getIconID() +\", Text]\"; ServerManager serverManager = ServerManager.getServerManager(); serverManager.sendMessage(this, msg); try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String ack = serverManager.getMessage(); if (ack == null) &#123; return false; &#125; String p = \"\\\\[ACKCHATMSG\\\\]:\\\\[(.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(ack); return matcher.find() &amp;&amp; matcher.group(1).equals(\"1\");&#125; 接收： 由于日后扩展可能不只是文本信息，所以在对聊天信息的处理上我们直接再建一个类。 1234567891011121314151617181920212223242526272829303132class ReceiveChatMsg &#123; void delChatMsg(String msg) &#123; String sendName = null; String content = null; String avatarID = null; String fileType = null; String group = null; ServerManager.getServerManager().setMessage(null); String p = \"\\\\[GETCHATMSG\\\\]:\\\\[(.*), (.*), (.*), (.*), (.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(msg); if (matcher.find()) &#123; sendName = matcher.group(1); content = matcher.group(2); avatarID = matcher.group(3); fileType = matcher.group(4); group = matcher.group(5); ChatMsg chatMsg = new ChatMsg(); chatMsg.setMyInfo(false); chatMsg.setContent(content); chatMsg.setChatObj(sendName); chatMsg.setUsername(ServerManager.getServerManager().getUsername()); chatMsg.setGroup(group); chatMsg.setIconID(Integer.parseInt(avatarID)); AtyChatRoom.chatMsgList.add(chatMsg); ChatMsg.chatMsgList.add(chatMsg); &#125; &#125;&#125; 细节就不多说了，注意区分同一个对象发信息给你是通过群还是私人。 还有就是当聊天窗口关闭后在再次打开聊天信息怎么加载？大家自己想想。不同可以看代码或者留言。 下面看下服务器的数据转发代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void dealChatMsg(String msg) &#123; String chatObj = null; String content = null; String avatarID = null; String msgType = null; String p = \"\\\\[CHATMSG\\\\]:\\\\[(.*), (.*), (.*), (.*)\\\\]\"; Pattern pattern = Pattern.compile(p); Matcher matcher = pattern.matcher(msg); if (matcher.find()) &#123; chatObj = matcher.group(1); content = matcher.group(2); avatarID = matcher.group(3); msgType = matcher.group(4); &#125; else &#123; return; &#125; String out = null; String sqlGroup = \"SELECT * FROM GROUPS WHERE groupName = '\" + chatObj+ \"';\"; try &#123; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sqlGroup); // gruop chat if (resultSet.next()) &#123; // find all group members to send msg String sql = \"SELECT groupMemberName FROM GROUPINFO WHERE groupName = '\" + chatObj + \"';\"; resultSet = statement.executeQuery(sql); while (resultSet.next()) &#123; // if user is online , then send. for (SocketMsg SocketMsg : ChatManager.getChatManager().socketList) &#123; if (SocketMsg.getUsername().equals(resultSet.getString(1)) &amp;&amp; !SocketMsg.getUsername().equals(username)) &#123; out = \"[GETCHATMSG]:[\" + username + \", \" + content + \", \" + avatarID + \", Text, \" + chatObj + \"]\"; SocketMsg.getChatSocket().sendMsg(out); &#125; &#125; &#125; // private chat &#125; else &#123; for (SocketMsg socketManager : ChatManager.getChatManager().socketList) &#123; if (socketManager.getUsername().equals(chatObj)) &#123; out = \"[GETCHATMSG]:[\" + username + \", \" + content + \", \" + avatarID + \", Text, ]\"; socketManager.getChatSocket().sendMsg(out); &#125; &#125; &#125; out = \"[ACKCHATMSG]:[1]\"; sendMsg(out); &#125; catch (SQLException e) &#123; out = \"[ACKCHATMSG]:[0]\"; sendMsg(out); e.printStackTrace(); &#125;&#125; 其实逻辑不是很复杂，慢慢看很容易懂的。其他的实现自己慢慢摸索可以实现。不想再拖长篇幅了，看代码可能比我讲的效率更高，理解更加深刻。在这个过程中可能你会遇到一个小 Bug 卡了一天，但是每个人都是这么成长过来的，一起加油! 到这里目前的就算完了，这个系列 Blog 可能不会更新了。但是 GitHub 上会对代码继续更新的。此外这个 Lab 版还有很多 Bug 欢迎大家提建议，很希望和大家一起交流学习。 多谢阅读。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-3","date":"2017-04-14T05:00:00.000Z","path":"2017/04/14/ZZChatApp3/","text":"GitHub 实现一个类似QQ的社交聊天工具-3准备做好【ZZChatApp2】中的内容并且下载了实现一个类似QQ的社交聊天工具-1中的资料就可以开始下面的了 实现目标看演示效果就知道，这次主要的任务是实现两个界面，一个是 Dressup 选图片的，另一个是聊天界面。如果你对 RecyclerView 有一定认识了，可以自己自行编写 Dressup 界面。我们的聊天信息使用的是 listview ，尝试尽可能多的控件。好消息是这次 lab 之后基本的界面工作就完成了，下次 lab 我们开始进行网络编程。 实现过程 Profile 界面就不讲了，自己参照源码或者自己写，这里为了方便就直接把 username 作为 id 和 nickname 主要是为了后期数据库的建立不太麻烦，毕竟是个小练习。数据处理不是我们关注的重点，重点是整个开发流程。 Dressup实现 我的习惯是先写界面 123456789101112131415161718192021aty_dress_up.xml&lt;LinearLayout &gt; &lt;org.fitzeng.zzchat.view.TitleBar android:id=\"@+id/tb_dress_up\" &gt; &lt;/org.fitzeng.zzchat.view.TitleBar&gt; &lt;TextView android:text=\"Choose an avatar\" /&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_avatar\" &gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;TextView android:text=\"Choose a background\" /&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_background\" &gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;Button android:id=\"@+id/btn_save\" /&gt;&lt;/LinearLayout&gt; 布局很简单，接下来就是建一个Aty去加载布局。布局好了，这是应该是加载资源，而加载资源又不得不用到我们的适配器。所以先写适配器。 下面以加载 Avatar 为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859adapter/AdapterAvatar.javapublic class AdapterAvatar extends RecyclerView.Adapter&lt;AdapterAvatar.BaseViewHoder&gt;&#123; private List&lt;ImageMsg&gt; imageViews; private Context context; private LayoutInflater inflater; private static int selectedImageAvatar = 0; private List&lt;RelativeLayout&gt; imageContainer = new ArrayList&lt;&gt;(); private Drawable bgImageDrawable; @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public AdapterAvatar(Context context, List&lt;ImageMsg&gt; imageViews) &#123; this.context = context; this.imageViews = imageViews; this.inflater = LayoutInflater.from(context); selectedImageAvatar = 0; bgImageDrawable = context.getResources().getDrawable(R.drawable.bgimage, null); &#125; @Override public BaseViewHoder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = inflater.inflate(R.layout.choose_image, parent, false); return new BaseViewHoder(view); &#125; @Override public void onBindViewHolder(final BaseViewHoder holder, final int position) &#123; holder.imageView.setImageResource(imageViews.get(position).getImageID()); imageContainer.get(selectedImageAvatar).setBackground(bgImageDrawable); holder.imageView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (position != selectedImageAvatar) &#123; imageContainer.get(position).setBackground(bgImageDrawable); imageContainer.get(selectedImageAvatar).setBackgroundColor(0); selectedImageAvatar = position; &#125; &#125; &#125;); &#125; @Override public int getItemCount() &#123; return imageViews == null ? 0 : imageViews.size(); &#125; class BaseViewHoder extends RecyclerView.ViewHolder &#123; ImageView imageView; BaseViewHoder(View itemView) &#123; super(itemView); imageView = (ImageView) itemView.findViewById(R.id.image); RelativeLayout layout = (RelativeLayout) itemView.findViewById(R.id.imageContainer); imageContainer.add(layout); &#125; &#125;&#125; 代码很简洁，都是套路。唯一注意的一点是点击的逻辑处理。还有就是把图片资源（util/ImageManager）用一个类封装一下，和创建一个对象（util/ImageMsg）用来存储加载数据的信息。用起来就比较方便了。适配器好了，下面利用适配器把数据加载进 RecyclerView 。思路还是比较清晰的。 具体实现看代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)private void initViews() &#123; titleBar = (TitleBar) findViewById(R.id.tb_dress_up); rvAvatar = (RecyclerView) findViewById(R.id.rv_avatar); rvBackground = (RecyclerView) findViewById(R.id.rv_background); btnSave = (Button) findViewById(R.id.btn_save); addAvatarView(); titleBar.setTitleBarClickListetner(new TitleBar.titleBarClickListener() &#123; @Override public void leftButtonClick() &#123; finish(); &#125; @Override public void rightButtonClick() &#123; &#125; &#125;); btnSave.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(AtyDressUp.this, \"saved\", Toast.LENGTH_SHORT).show(); finish(); &#125; &#125;);&#125;private void addAvatarView() &#123; List&lt;ImageMsg&gt; imageMsgs = new ArrayList&lt;&gt;(); for (int anImagesAvatar : ImageManager.imagesAvatar) &#123; ImageMsg imagemsg = new ImageMsg(); imagemsg.setImageID(anImagesAvatar); imageMsgs.add(imagemsg); &#125; AdapterAvatar avatarAdapter = new AdapterAvatar(this, imageMsgs); LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false); rvAvatar.setLayoutManager(layoutManager); rvAvatar.setAdapter(avatarAdapter);&#125; 之后加载 Background 的代码自己写吧,这一部分就算完成了，不懂的可以参照源码。 聊天界面看过第一行代码的应该有点了解，大家可以先上网搜搜其他资源。 主要问题是怎么让消息自适应气泡。有一种图片时.9.png格式，至于如何制作，很简单。选中图片右键，在最下面的选项中有一个Create 9-Patch file…点击之后就会弹出界面，自己把要缩放的区域集中在黑线的交汇区域。 聊天界面布局如下，这里有一个Bug，下面会陈述。 1234567891011121314151617181920&lt;LinearLayout &gt; &lt;org.fitzeng.zzchat.view.TitleBar android:id=\"@+id/tb_chat_room\" &gt; &lt;/org.fitzeng.zzchat.view.TitleBar&gt; &lt;ScrollView &gt; &lt;LinearLayout &gt; &lt;ListView android:id=\"@+id/lv_chat_room\" &gt; &lt;/ListView&gt; &lt;LinearLayout &gt; &lt;Button android:text=\"emoji\" /&gt; &lt;Button android:text=\"draw\" /&gt; &lt;Button android:text=\"file\" /&gt; &lt;Button android:text=\"call\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout&gt; &lt;EditText android:id=\"@+id/myMsg\"/&gt; &lt;Button android:id=\"@+id/btnSend\"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 接下来就是消息界面的设计，也就是适配器加载的布局。一个头像，一个 username 一个内容。OK。但是要区分是自己发送的消息还是别人发送的消息。所以有两个布局。 这时我们要建立一个聊天信息的Msg 12345private boolean myInfo;private int iconID;private String username;private String content;private String chatObj; 数据什么的都贮备好了，下面进行是适配器的编写。由于 ListView 没有实现 ViewHolder 所以要自己实现。主要是为了视图缓存，减小视图加载时的资源消耗。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859adaptar/AdapterChatMsg.javapublic class AdapterChatMsg extends ArrayAdapter&lt;ChatMsg&gt; &#123; private LayoutInflater inflater; private List&lt;ChatMsg&gt; chatMsgs; public AdapterChatMsg(@NonNull Context context, @LayoutRes int resource, List&lt;ChatMsg&gt; chatMsgs) &#123; super(context, resource); this.inflater = LayoutInflater.from(context); this.chatMsgs = chatMsgs; &#125; @Override public int getCount() &#123; return chatMsgs.size(); &#125; @Nullable @Override public ChatMsg getItem(int position) &#123; return chatMsgs.get(position); &#125; @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; ChatMsg msg = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; assert msg != null; if (msg.isMyInfo()) &#123; view = inflater.inflate(R.layout.chat_me, parent, false); &#125; else &#123; view = inflater.inflate(R.layout.chat_other, parent, false); &#125; viewHolder = new ViewHolder(); viewHolder.icon = (ImageView) view.findViewById(R.id.icon); viewHolder.username = (TextView) view.findViewById(R.id.username); viewHolder.content = (TextView) view.findViewById(R.id.content); view.setTag(viewHolder); &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; viewHolder.icon.setImageResource(chatMsgs.get(position).getIconID()); viewHolder.username.setText(chatMsgs.get(position).getUsername()); viewHolder.content.setText(chatMsgs.get(position).getContent()); return view; &#125; private class ViewHolder &#123; ImageView icon; TextView username; TextView content; &#125;&#125; 其中通过 12345if (msg.isMyInfo()) &#123; view = inflater.inflate(R.layout.chat_me, parent, false);&#125; else &#123; view = inflater.inflate(R.layout.chat_other, parent, false);&#125; 来加载聊天左右视图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667AtyChatRoom.javapublic class AtyChatRoom extends AppCompatActivity&#123; private TitleBar titleBar; private ListView listView; private EditText myMsg; private Button btnSend; private List&lt;ChatMsg&gt; chatMsgList; private AdapterChatMsg adapterChatMsgList; private String chatObj; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getSupportActionBar().hide();// getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.aty_chat_room); getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE | WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);// AndroidBug5497Workaround.assistActivity(this); initViews(); &#125; private void initViews() &#123; titleBar = (TitleBar) findViewById(R.id.tb_chat_room); listView = (ListView) findViewById(R.id.lv_chat_room); myMsg = (EditText) findViewById(R.id.myMsg); btnSend = (Button) findViewById(R.id.btnSend); chatMsgList = new ArrayList&lt;&gt;(); chatObj = getIntent().getStringExtra(\"username\"); titleBar.setTitleText(chatObj); adapterChatMsgList = new AdapterChatMsg(AtyChatRoom.this, R.layout.chat_other, chatMsgList); listView.setAdapter(adapterChatMsgList); btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String content = myMsg.getText().toString(); if (!content.isEmpty()) &#123; ChatMsg msg = new ChatMsg(); msg.setContent(content); msg.setUsername(\"hello\"); msg.setIconID(R.drawable.avasterwe); msg.setMyInfo(true); msg.setChatObj(chatObj); chatMsgList.add(msg); myMsg.setText(\"\"); &#125; &#125; &#125;); titleBar.setTitleBarClickListetner(new TitleBar.titleBarClickListener() &#123; @Override public void leftButtonClick() &#123; finish(); &#125; @Override public void rightButtonClick() &#123; &#125; &#125;); &#125;&#125; 这次我把整个Aty都贴出来了，主要是为了说明一个Bug。点击输入框软键盘弹出时 TitleBar 会被顶上去。为了解决这个问题，在onCreate函数中，加 SOFT_INPUT_ADJUST_RESIZE ，但是在全屏下同时设置 SOFT_INPUT_ADJUST_RESIZE 这个属性，TitleBar 又会被顶上去。所以，在 Stack Overflow 有大神给出了解决方案。就是 util 多出的那个 AndroidBug5497Workaround.java 文件。讲道理在 setContentView() 之后添加一句 AndroidBug5497Workaround.assistActivity(this); 就可以解决。。。。。。但是。。。可能是我的手机太渣，还是没能实现效果。据说这个是适合市面上大部分手机的。。。希望在你的手机上能行，所以我就保留了这些文件。为了取舍，我只能不实现全屏了。。。日后找到好的解决方案会在github更新。 目前好像。。完了。。。。看着少，其实里面的有些东西是值得深究的。至于如何实现 Moments 和 Contacts 滑动的留给大家自己探索了。 感谢大家的耐心阅读和支持，再下次开始之前，希望你已经搭建好了本地服务器。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-2","date":"2017-04-14T04:00:00.000Z","path":"2017/04/14/ZZChatApp2/","text":"GitHub 实现一个类似QQ的社交聊天工具-2准备做好【ZZChatApp1】中的内容并且下载了实现一个类似QQ的社交聊天工具-1中的资料就可以开始下面的了 实现目标前面只是实现一个基本的框架，这次我们要往主界面里面添加内容，代码较多，最好自己看这篇文章时也参考我提供的第二阶段源码。主要练习的是自定义控件 实现过程 这次的文件比上次多了，所以文件管理和控件ID的命名不能太随意，这是要注意的一点。代码难度不高，只要命名好了，不写注释其实也能看懂的。 TitleBar在开始写三个页面和一个侧滑视图之前，我们先做个自定义控件。其实这此实验总共用到了两个，我在这只叙述复杂的那个，剩下的可以参考源码自己实现。在学习之前推荐观看慕课，时间不是很长，但是对理清思路视频讲解更直接。 设计属性 其实就是两个button加一个textView。属性设计如下 123456789101112131415161718values/atts.xml&lt;declare-styleable name=\"TitleBar\"&gt; &lt;attr name=\"titleText\" format=\"string\" /&gt; &lt;attr name=\"titleTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"titleTextColor\" format=\"color\" /&gt; &lt;attr name=\"titleBackground\" format=\"reference|color\" /&gt; &lt;attr name=\"leftText\" format=\"string\" /&gt; &lt;attr name=\"leftTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"leftTextColor\" format=\"color\" /&gt; &lt;attr name=\"leftBackground\" format=\"reference|color\" /&gt; &lt;attr name=\"rightText\" format=\"string\" /&gt; &lt;attr name=\"rightTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"rightTextColor\" format=\"color\" /&gt; &lt;attr name=\"rightBackground\" format=\"reference|color\" /&gt;&lt;/declare-styleable&gt; 绑定属性 可以根据前面设计的属性来判断需要哪些变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private Button btnLeft;private Button btnRight;private TextView tvTitle;private String leftText;private float leftTextSize;private int leftTextColor;private Drawable leftBackground;private String rightText;private float rightTextSize;private int rightTextColor;private Drawable rightBackground;private String titleText;private float titleTextSize;private int titleTextColor;private Drawable titleBackground;/** * @param attrs this is titlebar's attribute set for binding with widgets */private void findAttrs(AttributeSet attrs) &#123; TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TitleBar); leftText = typedArray.getString(R.styleable.TitleBar_leftText); leftTextSize = typedArray.getDimension(R.styleable.TitleBar_leftTextSize, 24); leftTextColor = typedArray.getColor(R.styleable.TitleBar_leftTextColor, 0); leftBackground = typedArray.getDrawable(R.styleable.TitleBar_leftBackground); titleText = typedArray.getString(R.styleable.TitleBar_titleText); titleTextSize = typedArray.getDimension(R.styleable.TitleBar_titleTextSize, 24); titleTextColor = typedArray.getColor(R.styleable.TitleBar_titleTextColor, 0); titleBackground = typedArray.getDrawable(R.styleable.TitleBar_titleBackground); rightText = typedArray.getString(R.styleable.TitleBar_rightText); rightTextSize = typedArray.getDimension(R.styleable.TitleBar_rightTextSize, 24); rightTextColor = typedArray.getColor(R.styleable.TitleBar_rightTextColor, 0); rightBackground = typedArray.getDrawable(R.styleable.TitleBar_rightBackground); typedArray.recycle();&#125;/** * Init titlebar's widgets */private void initViews() &#123; btnLeft = new Button(context); btnRight = new Button(context); tvTitle = new TextView(context); btnLeft.setText(leftText); btnLeft.setTextSize(leftTextSize); btnLeft.setTextColor(leftTextColor); btnLeft.setBackground(leftBackground); btnRight.setText(rightText); btnRight.setTextSize(rightTextSize); btnRight.setTextColor(rightTextColor); btnRight.setBackground(rightBackground); tvTitle.setText(titleText); tvTitle.setTextSize(titleTextSize); tvTitle.setTextColor(titleTextColor); tvTitle.setBackground(titleBackground); tvTitle.setGravity(Gravity.CENTER); setBackgroundColor(0xFF01AAFF);&#125;/** * Setting titlebar's layout */private void setTitleBarLayoutParams() &#123; btnLeft.setAllCaps(false); btnRight.setAllCaps(false); LayoutParams btnLeftLayoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); btnLeftLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT, TRUE); addView(btnLeft, btnLeftLayoutParams); LayoutParams btnRightLayoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); btnRightLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, TRUE); addView(btnRight, btnRightLayoutParams); LayoutParams titleLayoutParams = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT); titleLayoutParams.addRule(RelativeLayout.CENTER_IN_PARENT, TRUE); addView(tvTitle, titleLayoutParams);&#125; 其实从使用角度来说，可以理出一条我们为什么这么做的线。因为在 XML 中我们使用一般都是 android : layout_width = “match_parent”很明显 layout_width 可以看做一个 Key ，而 match_parent 是一个 Value.所以 findAttrs(AttributeSet attrs) 就是把之前设计属性是所能识别的 Key 的值取出来，也就是 “XXX” 中的 XXX 数据，但是仅仅取出数据并没有什么用，最终还是要把数据赋值到控件上去，数据才能显示我们想要的效果。所以 initViews() 便是做这件事的。接下来的 setTitleBarLayoutParams() 只是对里面控件的属性的一个约束。 对于 Key-Value 的理解，其实可以这样看，如果声明了一个 app:no_name=”12” 在 xml 中，而实际你并没有声明这个属性在 atts.xml 中，所以编译器知道的是找不到 Key ，而不是判定 Value 的对错。所以对于属性文件 atts.xml 就自然而然有了存在的意义。我理解为就是规范作用，而之后的值传递给 TextView 或者其他已有控件，就是之后的绑定属性值的操作就顺理成章了。 文笔不好，不知道讲清了没。。。大家还是好好看看前面推荐的视频和自己写一个小控件实现一下加深理解。 目前这个控件只是静态的，不能响应点击事件。可以参考之前的 Button 怎么实现的。一般 Button.setOnClickListener()所以可以在控件中加一个 setTitleBarClickListetner() 方法。接下来就是有点难度的了。Button 自己的点击事件响应其实是由自己在 onClick() 方法中实现自己的逻辑的。 所以此时自定义控件就要对外提供一个接口，让实现者自己定义自己的点击事件。讲到这估计差不多了，看看代码就理解了。 12345678910111213141516171819202122232425262728293031323334view/TitleBar.javaprivate titleBarClickListener listener;/** * implement click events */public interface titleBarClickListener &#123; // 这两个方法相当于 Button 的 onCLick() void leftButtonClick(); void rightButtonClick();&#125;// 类似于 Button 的setOnClickListener();public void setTitleBarClickListetner(titleBarClickListener listetner) &#123; this.listener = listetner;&#125;// 内部设置按钮点击监听private void setButtonClickListener() &#123; btnLeft.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.leftButtonClick(); &#125; &#125;); btnRight.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; listener.rightButtonClick(); &#125; &#125;);&#125; 下面剩下的一个 PicAndTextBtn 大家可以自己实现，就是作为左侧滑动视图中的小控件，一个 ImageView 和 TextView组成的。 侧滑界面如果前面都写好了下面就使用上面的控件来写滑动界面，布局很简单。 12345678910111213141516171819202122232425262728&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;RelativeLayout&gt; &lt;LinearLayout&gt; &lt;LinearLayout&gt; &lt;ImageView/&gt; Avatar &lt;TextView/&gt; Username &lt;/LinearLayout&gt; &lt;TextView/&gt; Sign &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;Dress Up&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;Profile&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;/LinearLayout&gt; &lt;LinearLayout&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;setting&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;org.fitzeng.zzchat.view.PicAndTextBtn&gt;night&lt;/org.fitzeng.zzchat.view.PicAndTextBtn&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 接下来就是实现其逻辑了，这次主要实现以下setting，dressup和profile下次实验实现。实现控件的点击，虽然这个点击事件是你们自己写的，为了后面的实验一致，推荐命名最好和我一致。。。虽然我的命名也很烂。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647view/LayoutSlide.javaprivate void initViews() &#123; this.addView(LayoutInflater.from(context).inflate(R.layout.layout_slide, null)); dressUp = (PicAndTextBtn) findViewById(R.id.patb_dressup); profile = (PicAndTextBtn) findViewById(R.id.patb_profile); setting = (PicAndTextBtn) findViewById(R.id.patb_setting); night = (PicAndTextBtn) findViewById(R.id.patb_night); dressUp.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, AtyDressUp.class); context.startActivity(intent); &#125; &#125;); profile.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, AtyProfile.class); context.startActivity(intent); &#125; &#125;); setting.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, AtySetting.class); context.startActivity(intent); &#125; &#125;); night.setOnClickListener(new PicAndTextBtn.picAndTextBtnClickListener() &#123; @Override public void onClick(View view) &#123; if (nightMode) &#123; findViewById(R.id.layout_slide).setBackgroundColor(0xff878787); nightMode = false; &#125; else &#123; findViewById(R.id.layout_slide).setBackgroundColor(0xffe9e9e9); nightMode = true; &#125; &#125; &#125;);&#125; setting 界面的布局就不贴代码了，很简单。只分析 java 代码，其实目前也很水，也就实现了一个 Guide View 是否播放的功能。但是在之前的 Welcome 页面中还要做一点小小的修改。大家可以试验不该会怎么样。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768AtySetting.javaprivate void initViews() &#123; titleBar = (TitleBar) findViewById(R.id.tb_setting); guide = (ImageView) findViewById(R.id.iv_setting_guide); password = (ImageView) findViewById(R.id.iv_setting_password); offline = (ImageView) findViewById(R.id.iv_setting_offline); guideMode = getSharedPreferences(\"zzchat\", MODE_PRIVATE).getBoolean(\"guide\", true); guide.setImageResource(guideMode ? R.drawable.btnselected : R.drawable.btnunselected); password.setImageResource(passwordMode ? R.drawable.btnselected : R.drawable.btnunselected); offline.setImageResource(offlineMode ? R.drawable.btnselected : R.drawable.btnunselected); guide.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (guideMode) &#123; guide.setImageResource(R.drawable.btnunselected); guideMode = false; &#125; else &#123; guide.setImageResource(R.drawable.btnselected); guideMode = true; &#125; &#125; &#125;); password.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (passwordMode) &#123; password.setImageResource(R.drawable.btnunselected); passwordMode = false; &#125; else &#123; password.setImageResource(R.drawable.btnselected); passwordMode = true; &#125; &#125; &#125;); offline.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (offlineMode) &#123; offline.setImageResource(R.drawable.btnunselected); offlineMode = false; &#125; else &#123; offline.setImageResource(R.drawable.btnselected); offlineMode = true; &#125; &#125; &#125;); titleBar.setTitleBarClickListetner(new TitleBar.titleBarClickListener() &#123; @Override public void leftButtonClick() &#123; SharedPreferences sharedPreferences = getSharedPreferences(\"zzchat\", MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putBoolean(\"guide\", guideMode); editor.apply(); finish(); &#125; @Override public void rightButtonClick() &#123; &#125; &#125;);&#125; night 功能也基本没有实现，留给大家完善了。。。 chats下面开始 Chat 页面的设计。同理后面的 Contact 和 Moment 也是和这个类似，大家参考源码可以把代码写了，当做练习。有些坑自己不踩不知道多深。 把 titleBar 引进来是很简单的。直接在主界面中加就是了。 实现 Chats 这个列表功能我们使用更加易用的 RecyclerView 下次实验实现的聊天界面我们可以试试 ListView。好了，都决定好了就开始写代码吧。 和前面一样，一个 RecyclerView 怎么加载数据？答案就是通过 Adapter ，问题又来了，那么加载的怎样的数据呢？所以现在目的很明确，就是设计数据 Item 布局是一个头像，一个Username, 一个签名 123456789item_user.xml&lt;LinearLayout&gt; &lt;ImageView android:id=\"@+id/iv_item_avatar\" /&gt; &lt;LinearLayout&gt; &lt;TextView android:id=\"@+id/tv_item_username\" /&gt; &lt;TextView android:id=\"@+id/tv_item_sign\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 有了布局，接下来就是自己构造适配器加载布局。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950adapter/AdapterUserItem.javapublic class AdapterUserItem extends RecyclerView.Adapter&lt;AdapterUserItem.BaseViewHolder&gt; &#123; private Context context; private List&lt;UserItemMsg&gt; userItemMsgList; public AdapterUserItem(Context context, List&lt;UserItemMsg&gt; userItemMsgList) &#123; this.context = context; this.userItemMsgList = userItemMsgList; &#125; @Override public BaseViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return new BaseViewHolder(LayoutInflater.from(context).inflate(R.layout.item_user, parent, false)); &#125; @Override public void onBindViewHolder(BaseViewHolder holder, int position) &#123; holder.ivAvatar.setImageResource(userItemMsgList.get(position).getIconID()); holder.tvUsername.setText(userItemMsgList.get(position).getUsername()); holder.tvSign.setText(userItemMsgList.get(position).getSign()); &#125; @Override public int getItemCount() &#123; return (userItemMsgList == null ? 0 : userItemMsgList.size()); &#125; class BaseViewHolder extends RecyclerView.ViewHolder&#123; private ImageView ivAvatar; private TextView tvUsername; private TextView tvSign; BaseViewHolder(View itemView) &#123; super(itemView); ivAvatar = (ImageView) itemView.findViewById(R.id.iv_item_avatar); tvUsername = (TextView) itemView.findViewById(R.id.tv_item_username); tvSign = (TextView) itemView.findViewById(R.id.tv_item_sign); itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(context, tvUsername.getText().toString(), Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; &#125;&#125; 我把代码全贴上来了，其实这算是一个经常用的模板了吧。RecyclerView 内部自己实现了 ViewHolder 类，所以说使用方便。 下面就是比较有代表性的 recyclerView 代码实现，可以注意注意 setLayoutManager() 函数。 1234567891011private void initViews() &#123; context = getContext(); recyclerView = (RecyclerView) rootView.findViewById(R.id.chatsRecycleView); loadData(); adapterUserItem = new AdapterUserItem(context, userItemMsgList); recyclerView.setLayoutManager(new LinearLayoutManager(context)); recyclerView.setAdapter(adapterUserItem);&#125; 怕篇幅过多，细的知识点不会太陈述，主要是对整个一个 App 实现过程中思考的一个介绍，不会觉得自己无从下手。 。。。。。。。。好像篇幅有点长了，还没有涉及服务端就这么多了。。。剩下的效果大家可以按动图显示的自己实现，方法其实全概括了。 最后说下 TabHost 的一点东西 1234567891011121314151617181920tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; tabList.get(tab.getPosition()).setIcon(ImageManager.imageID[tab.getPosition() + 3]); tabLayout.setTabTextColors( ContextCompat.getColor(AtyMain.this, R.color.colorBlack), ContextCompat.getColor(AtyMain.this, R.color.colorBlue) ); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; tabList.get(tab.getPosition()).setIcon(ImageManager.imageID[tab.getPosition()]); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125;&#125;); 为什么要把下面的代码放在监听中执行，而不是在外面。大家可以做做实验，点击Tab和滑动ViewPager就能发现异同。 1234tabLayout.setTabTextColors( ContextCompat.getColor(AtyMain.this, R.color.colorBlack), ContextCompat.getColor(AtyMain.this, R.color.colorBlue)); 还有前面遗留的登录界面 Tab 上面的字母是大写，怎么解决？大家可以自己查资料，再看看我提供的源码。这次就这样，下次实现剩下的 DressUp，Profile 和聊天界面。再下次就是网络编程啦！","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-1","date":"2017-04-14T03:00:00.000Z","path":"2017/04/14/ZZChatApp1/","text":"GitHub 实现一个类似QQ的社交聊天工具-1准备 AndroidStudio 模拟器 资料 密码: jme4大家将图片复制到drawable供接下来的使用，部分图片源于网络，不做商业用途应该不算侵权吧。如果有，我会删除资源的。 实现目标按照最先开始的计划，我们只实现一个静态的ZZChat界面，考验的就是Android控件的基本知识。如果碰到没见到过的控件可以去Google看开发文档。 实现过程 在看到实现的设计下，我们最先想到的是有四的Activity（欢迎界面，引导页，登录注册，主界面），同时对应四个布局 修改Manifest12345678910111213141516171819AndroidManifest.xml&lt;application android:allowBackup=\"true\" android:icon=\"@drawable/icon\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".aty.AtyWelcome\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".aty.AtyGuide\" /&gt; &lt;activity android:name=\".aty.AtyLoginOrRegister\" /&gt; &lt;activity android:name=\".aty.AtyMain\" /&gt;&lt;/application&gt; 欢迎界面 全屏 1234onCreate()getSupportActionBar().hide();getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); 引导界面只在首次开启时显示 123456789101112131415161718192021222324252627282930313233AtyWelcome.javaprivate void initLoad() &#123; SharedPreferences sharedPreferences = getSharedPreferences(\"zzchat\", MODE_PRIVATE); boolean welcome = sharedPreferences.getBoolean(\"welcome\", true); if (!welcome) &#123; handler.sendEmptyMessageDelayed(GO_HOME, DELAY); &#125; else &#123; handler.sendEmptyMessageDelayed(GO_GUIDE, DELAY); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putBoolean(\"welcome\", false); editor.apply(); &#125;&#125;Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case GO_GUIDE: &#123; goGuide(); break; &#125; case GO_HOME: &#123; goHome(); break; &#125; default: break; &#125; &#125;&#125;; 引导页引导页我们使用一个ViewPager实现，如果之前不熟悉的可以看我的另一个利用ViewPager做的轮播图。 布局 相信看了前面动图的效果对布局实现应该是有底了 123456789101112131415161718192021222324252627282930313233343536373839404142434445aty_guide.xml&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/vp_guide\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;LinearLayout android:orientation=\"horizontal\" android:layout_centerHorizontal=\"true\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"20dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;ImageView android:id=\"@+id/iv_indicator_dot1\" android:src=\"@drawable/selected\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_width=\"10dp\" android:layout_height=\"10dp\" /&gt; &lt;ImageView android:id=\"@+id/iv_indicator_dot2\" android:src=\"@drawable/unselected\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_width=\"10dp\" android:layout_height=\"10dp\" /&gt; &lt;ImageView android:id=\"@+id/iv_indicator_dot3\" android:src=\"@drawable/unselected\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_width=\"10dp\" android:layout_height=\"10dp\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 适配布局 到这了，如何实现ViewPager加载布局就是我们现在应该想的事了。目前可以最先想到和做到的是实现三个加载的布局，为了方便我们只使用一个ImageView来实现，同理其他三个页面也是类似，第三个多加一个Enter入口进入主页。 1234567891011guide_page1.xml&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:src=\"@drawable/shot2\" android:scaleType=\"centerCrop\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; 适配器 现在的情况是有了布局和资源页面，怎么把资源页面加载进布局，这时就要用到Adapter了，也就是适配器。新建一个adapter资源包新建一个AdapterGuideViewPager类继承PagerAdapter 123456789101112131415161718192021222324252627282930313233adapter/AdapterGuideViewPager.javapublic class public class AdapterGuideViewPager extends PagerAdapter&#123; private Context context; private List&lt;View&gt; viewList; public AdapterGuideViewPager(Context context, List&lt;View&gt; viewList) &#123; this.context = context; this.viewList = viewList; &#125; @Override public int getCount() &#123; return viewList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return (view == object); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(viewList.get(position)); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(viewList.get(position)); return viewList.get(position); &#125;&#125; 一定要注意getCount()和isViewFromObject()函数的实现。 有了适配器，只要给adapter添加之前的guide视图作为资源，再给viewPager设置资源适配器。基本效果就实现了。 12345678910111213141516171819202122232425262728293031AtyGuide.javaprivate void initViews() &#123; // load view final LayoutInflater inflater = LayoutInflater.from(this); viewList = new ArrayList&lt;&gt;(); viewList.add(inflater.inflate(R.layout.guide_page1, null)); viewList.add(inflater.inflate(R.layout.guide_page2, null)); viewList.add(inflater.inflate(R.layout.guide_page3, null)); // bind Id with imageView for (int i = 0; i &lt; indicatorDotIds.length; i++) &#123; imageViews[i] = (ImageView) findViewById(indicatorDotIds[i]); &#125; adapterGuideViewPager = new AdapterGuideViewPager(this, viewList); viewPager = (ViewPager) findViewById(R.id.vp_guide); viewPager.setAdapter(adapterGuideViewPager); viewPager.addOnPageChangeListener(this); btnToMain = (Button) (viewList.get(2)).findViewById(R.id.btn_to_main); btnToMain.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(AtyGuide.this, AtyLoginOrRegister.class); startActivity(intent); &#125; &#125;);&#125; 指示器实现 当前页面是第几页，要给用户一个比较明显的提示，可以利用两个不同颜色的小圆点。但是要想知道移动的改变就要实现监听事件 实现onPageSelected()方法就可以了。 1234567891011AtyGuide.javapublic void onPageSelected(int position) &#123; for (int i = 0; i &lt; indicatorDotIds.length; i++) &#123; if (i != position) &#123; imageViews[i].setImageResource(R.drawable.unselected); &#125; else &#123; imageViews[i].setImageResource(R.drawable.selected); &#125; &#125;&#125; 登录注册 界面 这里可以自己设计，我使用TabHost实现，学习使用不同控件，不过布局值得主页的是ID的设置，自己可以试试如果不这样会出现什么效果。 12345678910111213141516&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:background=\"@drawable/shot1\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TabHost android:id=\"@+id/tabHost\"&gt; &lt;TabWidget android:id=\"@android:id/tabs\"&gt; &lt;/TabWidget&gt; &lt;FrameLayout android:id=\"@android:id/tabcontent\"&gt; &lt;LinearLayout&gt; Login Layout &lt;/LinearLayout&gt; &lt;LinearLayout&gt; Register Layout &lt;/LinearLayout&gt; &lt;/FrameLayout&gt; &lt;/TabHost&gt;&lt;/RelativeLayout&gt; 跳转 目前还没进行数据处理，所以我们直接跳转进入界面 123456789101112131415161718192021222324252627282930313233343536373839private void initViews() &#123; tabHost = (TabHost) findViewById(R.id.tabHost); btnLogin = (Button) findViewById(R.id.btn_login); etLoginUsername = (EditText) findViewById(R.id.et_login_username); etLoginPassword = (EditText) findViewById(R.id.et_login_password); btnRegister = (Button) findViewById(R.id.btn_register); etRegisterUsername = (EditText) findViewById(R.id.et_register_username); etRegisterPassword = (EditText) findViewById(R.id.et_register_password); etInsurePassword = (EditText) findViewById(R.id.et_insure_password); tabHost.setup(); tabHost.addTab(tabHost.newTabSpec(\"Login\").setIndicator(\"Login\").setContent(R.id.layout_login)); tabHost.addTab(tabHost.newTabSpec(\"Register\").setIndicator(\"Register\").setContent(R.id.layout_register)); btnLogin.setOnClickListener(this); btnRegister.setOnClickListener(this);&#125;@Overridepublic void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_login: &#123; Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); break; &#125; case R.id.btn_register: &#123; Intent intent = new Intent(this, AtyMain.class); startActivity(intent); finish(); break; &#125; default: break; &#125;&#125; 添加依赖库 如果你遇到上面的bug，说明到现在我们的TabHost是无法工作的，因为缺少一个依赖库。compile ‘com.android.support:design:2x.x.x’ 添加方式是在File-&gt;Project Structure 在弹出的窗口中选择app,之后操作看图此时需要重新Gradle, 这时可能一个错误在build.gradle。按Alt + Enter, 选择忽略就好。 12345678910dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.1' testCompile 'junit:junit:4.12' compile 'com.android.support:design:26.0.0-alpha1'&#125; 主界面之前的页面基本实现，那么主界面如何实现，参考QQ，为了避免控件上的使用难度，我们直接用google提供的DrawerLayout写代码之前先理清思路，这个主界面明显是包含三个页面加一个侧换页面，也就是四个。新建一个view资源文件，创建四个视图类接着新建四个布局供类加载 布局 这个布局有要主页的地方侧滑视图要设置android:layout_gravity=”start” 属性。DrawerLayout最好为根容器推荐如下布局最外层就是DrawerLayout，中间只有一个主内容和一个侧滑布局。你要添加的内容全部在主内容中实现。 这里采用ViewPager + TabLayout 来实现，不熟悉的点这里 123456789101112aty_main.xml&lt;android.support.v4.widget.DrawerLayout &gt; &lt;LinearLayout &gt; &lt;android.support.v4.view.ViewPager &gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;android.support.design.widget.TabLayout &gt; &lt;/android.support.design.widget.TabLayout&gt; &lt;/LinearLayout&gt; &lt;org.fitzeng.zzchat.view.SlideLayout android:layout_gravity=\"start\"&gt;侧换视图&lt;/org.fitzeng.zzchat.view.SlideLayout&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 加载页面 以Chats为例 123456&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:background=\"#09868f\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/LinearLayout&gt; 1234567891011public class LayoutChats extends Fragment &#123; private View rootView; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; rootView = inflater.inflate(R.layout.layout_chats, container, false); return rootView; &#125;&#125; 十分简单，看代码就能懂 之前已经使用了侧滑视图，接下来的三个视图分别对应加载进了三个类。如何将这些视图加载进主界面，前面已经说过如何加载经viewPager了，这里也是一样的。实现一个适配器。 适配器 和前面不一样的是前面直接inflate一个布局进资源列表，而这里是把布局加载进类中了。所以实现方式稍微有点不一样, 这样对布局的内容控制性个人认为较好,因为布局中的子控件逻辑可以在各自的类中实现。看代码就懂了。 123456789101112131415161718192021222324adapter/AdapterMainViewPager.javapublic class AdapterMainViewPager extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); public AdapterMainViewPager(FragmentManager fragmentManager) &#123; super(fragmentManager); &#125; public void addFragment(Fragment fragment) &#123; fragmentList.add(fragment); &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentList.size(); &#125;&#125; 123456789101112131415161718192021222324private void initViews() &#123; drawable = (DrawerLayout) findViewById(R.id.dl_main); viewPager = (ViewPager) findViewById(R.id.vp_main); tabLayout = (TabLayout) findViewById(R.id.tl_main); tabList = new ArrayList&lt;&gt;(); AdapterMainViewPager adapter = new AdapterMainViewPager(getSupportFragmentManager()); adapter.addFragment(new LayoutChats()); adapter.addFragment(new LayoutContacts()); adapter.addFragment(new LayoutMoments()); viewPager.setAdapter(adapter); tabLayout.setupWithViewPager(viewPager); tabList.add(tabLayout.getTabAt(0)); tabList.add(tabLayout.getTabAt(1)); tabList.add(tabLayout.getTabAt(2)); tabList.get(0).setIcon(R.drawable.icon).setText(\"Chats\"); tabList.get(1).setIcon(R.drawable.icon).setText(\"Contacts\"); tabList.get(2).setIcon(R.drawable.icon).setText(\"Moments\");&#125; 代码比较简洁，不知道意思的可以按ctrl点击类名或方法名看源码注释。 到这里基本的效果实现了，不清楚了可以参考阶段性源码。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个类似QQ的社交聊天工具-0","date":"2017-04-14T02:00:00.000Z","path":"2017/04/14/ZZChatApp0/","text":"GitHub 实现一个类似QQ的社交聊天工具-0 实现效果 原因由于在间间断断的学Android，所以学的知识比较杂，想做个小项目来复习复习。所以之前在课后十天左右的时间完成了一个刚刚具备聊天功能的App，由于这几天拼命的搜寻资料，发现网上并没有一个完整的开发过程的文章。平时也就是看看大牛们的博客学习，现在觉得也要多和大家分享自己学到的知识，共同进步。可能你在这学不到技术深度的东西，但是说不定可以扩展你的技术广度。 目标人群推荐给正处于Android进阶的人群，想写一个App却不知道如何开始。希望我的这些文字对你能有帮助。最少基本过了一遍《第一行代码》，读过《Android群英传》就更好了。由于我是以一个遇到问题解决问题的视角来写的，所以基本会让你的开发过程思路清晰，知道这么做的目的和好处。同时这也是一个开始完全不知道怎么写到实现基本功能的心路历程描述。所以应该会有点价值吧。当然涉及的东西确实有点多，所以不可能一一叙述，欢迎大家留言讨论。 知识数据库相关知识（基本的增删改查）Java（Java可视化界面编程，Socket网络通信）Android 软件Android: Android Studio本地服务器搭建： XAMPP（Apache + MySQL）服务器界面：Eclipse JavaEE 实现思路在电脑上利用Apache + MySQL搭建一个供服务端访问的数据库，有了数据库，就要写一个服务端在电脑上运行，读写数据库数据。开启一个线程一直检测是否有客户发送连接请求，有的话accept，并且给这个连接的用户开一个单独线程供客户端进行通讯。而客户端发送请求给服务器，所以客户端要有一个Action来激活发送请求，也就是我们的点击滑动等事件。但是同时又要接受来自服务端的数据，所以我们要使客户端的Action操作和与服务端通讯分别用两个不同的线程管理。不知道我讲没讲请，下面用图来描述一下。 实现程度由于学业较忙，博客只会更新到目前程度，接下的过程大家可以定制属于你自己的聊天软件。逻辑框架完成度：60%界面设计完成度：40%已实现：服务端，通讯协议，登录，聊天。接下来的功能基本可以根据上面的功能实现。 建议1 使用真机调试2 在整个过程中一定会遇到各种问题 Log + 断点 -&gt; StackOverflow 基本可以解决初学者99%的问题。 开始学习实现一个类似QQ的社交聊天工具-1实现一个类似QQ的社交聊天工具-2实现一个类似QQ的社交聊天工具-3实现一个类似QQ的社交聊天工具-4 最后这个App我会继续在GitHub完善，Blog是否更看课余时间，欢迎大家关注。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"},{"name":"ZZChat","slug":"ZZChat","permalink":"http://fitzeng.org/tags/ZZChat/"}]},{"title":"实现一个表情键盘控件","date":"2017-04-07T05:00:00.000Z","path":"2017/04/07/EmojiKeyboard/","text":"GitHub 任务目的 学习android控件的封装，viewPager的使用，以及SpannableString对文字加图片的处理 任务描述 能进行表情的输入，删除 表情大于一页，且可以翻页 表情键盘和输入法键盘的弹出逻辑要正确 结果演示 实现过程 一开始，其实也不知道从哪里下手，开始在网上浏览了一些博客，大概有了解决的思路，下面就从我个人的解决思路出发实现一个一个小功能。 step 1: 设计总体布局 采用LinearLayout基本上是上(textView)中(func Bar)下(keyboard)的设计，为了方便控制，keyboard的布局采用自定义，布局代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;org.fitzeng.emojikeyboard.simpleemojikeyboard.SimpleEmojiEditLayout android:id=\"@+id/etSimpleEmojiEdit\" android:hint=\"@string/typeing_something_here\" android:maxLines=\"30\" android:textSize=\"24sp\" android:gravity=\"top\" android:background=\"@null\" android:layout_margin=\"8dp\" android:layout_weight=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" /&gt;&lt;RelativeLayout android:background=\"@color/colorPrimary\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\"&gt; &lt;ImageView android:id=\"@+id/touchIcon\" android:src=\"@mipmap/ic_launcher\" android:layout_centerInParent=\"true\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:contentDescription=\"@string/an_icon_button\" /&gt; &lt;ImageView android:id=\"@+id/btnDelete\" android:src=\"@drawable/icon_delete_normal\" android:layout_alignParentRight=\"true\" android:layout_centerVertical=\"true\" android:layout_width=\"wrap_content\" android:layout_height=\"@dimen/dp40\" android:contentDescription=\"@string/delete\" /&gt;&lt;/RelativeLayout&gt;&lt;org.fitzeng.emojikeyboard.simpleemojikeyboard.SimpleEmojiKeyboardLayout android:id=\"@+id/simpleEmojiKeyboardLayout\" android:visibility=\"gone\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\"&gt;&lt;/org.fitzeng.emojikeyboard.simpleemojikeyboard.SimpleEmojiKeyboardLayout&gt; step 2：大概实现布局控件 设计好控件，就进行实现，通过对func Bar的设计，实现键盘的收缩功能。 1234567891011121314151617181920212223242526272829303132// Click icon to make keyboard hide or appeartouchIcon.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (simpleEmojiKeyboardLayout.getVisibility() == View.GONE) &#123; simpleEmojiKeyboardLayout.setVisibility(View.VISIBLE); simpleEmojiKeyboardLayout.slipUp(); &#125; else &#123; simpleEmojiKeyboardLayout.setVisibility(View.GONE); &#125; &#125;&#125;);// Make keyboard appear when click to editsimpleEmojiEditLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (simpleEmojiKeyboardLayout.getVisibility() == View.GONE) &#123; simpleEmojiKeyboardLayout.slipUp(); simpleEmojiKeyboardLayout.setVisibility(View.VISIBLE); &#125; &#125;&#125;);/** * keyboard slip out */public void slipUp() &#123; LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) this.getLayoutParams(); layoutParams.height = (int) (getMeasuredWidth() * 0.7); this.setLayoutParams(layoutParams);&#125; step 3: 封装表情加入keyboard 将emoji封装成一个对象 1234567891011121314151617181920212223242526public class Smile &#123; private int resId; private String info; public Smile(int resId, String info) &#123; this.resId = resId; this.info = info; &#125; public int getResId() &#123; return resId; &#125; public void setResId(int resId) &#123; this.resId = resId; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125;&#125; 为了方便管理，把表情资源都添加进一个Manager类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class EmojiManager &#123; private static List&lt;Smile&gt; smileList; private static Context context; public EmojiManager(Context context) &#123; this.context = context; &#125; public static List&lt;Smile&gt; getSmileList() &#123; if(smileList==null)&#123; smileList=new ArrayList&lt;&gt;(); smileList.add(new Smile(R.drawable.emotion_1001,\"[e]1001[/e]\")); smileList.add(new Smile(R.drawable.emotion_1002,\"[e]1002[/e]\")); smileList.add(new Smile(R.drawable.emotion_1003,\"[e]1003[/e]\")); smileList.add(new Smile(R.drawable.emotion_1004,\"[e]1004[/e]\")); smileList.add(new Smile(R.drawable.emotion_1005,\"[e]1005[/e]\")); smileList.add(new Smile(R.drawable.emotion_1006,\"[e]1006[/e]\")); smileList.add(new Smile(R.drawable.emotion_1007,\"[e]1007[/e]\")); smileList.add(new Smile(R.drawable.emotion_1008,\"[e]1008[/e]\")); smileList.add(new Smile(R.drawable.emotion_1009,\"[e]1009[/e]\")); smileList.add(new Smile(R.drawable.emotion_1010,\"[e]1010[/e]\")); smileList.add(new Smile(R.drawable.emotion_1011,\"[e]1011[/e]\")); smileList.add(new Smile(R.drawable.emotion_1012,\"[e]1012[/e]\")); smileList.add(new Smile(R.drawable.emotion_1013,\"[e]1013[/e]\")); smileList.add(new Smile(R.drawable.emotion_1014,\"[e]1014[/e]\")); smileList.add(new Smile(R.drawable.emotion_1015,\"[e]1015[/e]\")); smileList.add(new Smile(R.drawable.emotion_1016,\"[e]1016[/e]\")); smileList.add(new Smile(R.drawable.emotion_1017,\"[e]1017[/e]\")); smileList.add(new Smile(R.drawable.emotion_1018,\"[e]1018[/e]\")); smileList.add(new Smile(R.drawable.emotion_1019,\"[e]1019[/e]\")); smileList.add(new Smile(R.drawable.emotion_1020,\"[e]1020[/e]\")); smileList.add(new Smile(R.drawable.emotion_1021,\"[e]1021[/e]\")); smileList.add(new Smile(R.drawable.emotion_1022,\"[e]1022[/e]\")); smileList.add(new Smile(R.drawable.emotion_1023,\"[e]1023[/e]\")); smileList.add(new Smile(R.drawable.emotion_1024,\"[e]1024[/e]\")); smileList.add(new Smile(R.drawable.emotion_1025,\"[e]1025[/e]\")); smileList.add(new Smile(R.drawable.emotion_1026,\"[e]1026[/e]\")); smileList.add(new Smile(R.drawable.emotion_1027,\"[e]1027[/e]\")); smileList.add(new Smile(R.drawable.emotion_1028,\"[e]1028[/e]\")); smileList.add(new Smile(R.drawable.emotion_1029,\"[e]1029[/e]\")); smileList.add(new Smile(R.drawable.emotion_1030,\"[e]1030[/e]\")); smileList.add(new Smile(R.drawable.emotion_1031,\"[e]1031[/e]\")); smileList.add(new Smile(R.drawable.emotion_1032,\"[e]1032[/e]\")); smileList.add(new Smile(R.drawable.emotion_1033,\"[e]1033[/e]\")); smileList.add(new Smile(R.drawable.emotion_1034,\"[e]1034[/e]\")); smileList.add(new Smile(R.drawable.emotion_1035,\"[e]1035[/e]\")); smileList.add(new Smile(R.drawable.emotion_1036,\"[e]1036[/e]\")); smileList.add(new Smile(R.drawable.emotion_1037,\"[e]1037[/e]\")); smileList.add(new Smile(R.drawable.emotion_1038,\"[e]1038[/e]\")); smileList.add(new Smile(R.drawable.emotion_1039,\"[e]1039[/e]\")); smileList.add(new Smile(R.drawable.emotion_1040,\"[e]1040[/e]\")); smileList.add(new Smile(R.drawable.emotion_1041,\"[e]1041[/e]\")); smileList.add(new Smile(R.drawable.emotion_1042,\"[e]1042[/e]\")); smileList.add(new Smile(R.drawable.emotion_1043,\"[e]1043[/e]\")); smileList.add(new Smile(R.drawable.emotion_1044,\"[e]1044[/e]\")); smileList.add(new Smile(R.drawable.emotion_1045,\"[e]1045[/e]\")); smileList.add(new Smile(R.drawable.emotion_1046,\"[e]1046[/e]\")); smileList.add(new Smile(R.drawable.emotion_1047,\"[e]1047[/e]\")); smileList.add(new Smile(R.drawable.emotion_1048,\"[e]1048[/e]\")); smileList.add(new Smile(R.drawable.emotion_1049,\"[e]1049[/e]\")); smileList.add(new Smile(R.drawable.emotion_1050,\"[e]1050[/e]\")); smileList.add(new Smile(R.drawable.emotion_1051,\"[e]1051[/e]\")); smileList.add(new Smile(R.drawable.emotion_1052,\"[e]1052[/e]\")); smileList.add(new Smile(R.drawable.emotion_1053,\"[e]1053[/e]\")); smileList.add(new Smile(R.drawable.emotion_1054,\"[e]1054[/e]\")); smileList.add(new Smile(R.drawable.emotion_1055,\"[e]1055[/e]\")); smileList.add(new Smile(R.drawable.emotion_1056,\"[e]1056[/e]\")); smileList.add(new Smile(R.drawable.emotion_1057,\"[e]1057[/e]\")); smileList.add(new Smile(R.drawable.emotion_1058,\"[e]1058[/e]\")); smileList.add(new Smile(R.drawable.emotion_1059,\"[e]1059[/e]\")); smileList.add(new Smile(R.drawable.emotion_1060,\"[e]1060[/e]\")); smileList.add(new Smile(R.drawable.emotion_1061,\"[e]1061[/e]\")); smileList.add(new Smile(R.drawable.emotion_1062,\"[e]1062[/e]\")); smileList.add(new Smile(R.drawable.emotion_1063,\"[e]1063[/e]\")); smileList.add(new Smile(R.drawable.emotion_1064,\"[e]1064[/e]\")); smileList.add(new Smile(R.drawable.emotion_1065,\"[e]1065[/e]\")); smileList.add(new Smile(R.drawable.emotion_1066,\"[e]1066[/e]\")); smileList.add(new Smile(R.drawable.emotion_1067,\"[e]1067[/e]\")); smileList.add(new Smile(R.drawable.emotion_1068,\"[e]1068[/e]\")); smileList.add(new Smile(R.drawable.emotion_1069,\"[e]1069[/e]\")); smileList.add(new Smile(R.drawable.emotion_1070,\"[e]1070[/e]\")); smileList.add(new Smile(R.drawable.emotion_1071,\"[e]1071[/e]\")); smileList.add(new Smile(R.drawable.emotion_1072,\"[e]1072[/e]\")); smileList.add(new Smile(R.drawable.emotion_1073,\"[e]1073[/e]\")); smileList.add(new Smile(R.drawable.emotion_1074,\"[e]1074[/e]\")); smileList.add(new Smile(R.drawable.emotion_1075,\"[e]1075[/e]\")); smileList.add(new Smile(R.drawable.emotion_1076,\"[e]1076[/e]\")); smileList.add(new Smile(R.drawable.emotion_1077,\"[e]1077[/e]\")); smileList.add(new Smile(R.drawable.emotion_1078,\"[e]1078[/e]\")); smileList.add(new Smile(R.drawable.emotion_1079,\"[e]1079[/e]\")); smileList.add(new Smile(R.drawable.emotion_1080,\"[e]1080[/e]\")); smileList.add(new Smile(R.drawable.emotion_1081,\"[e]1081[/e]\")); smileList.add(new Smile(R.drawable.emotion_1082,\"[e]1082[/e]\")); smileList.add(new Smile(R.drawable.emotion_1083,\"[e]1083[/e]\")); smileList.add(new Smile(R.drawable.emotion_1084,\"[e]1084[/e]\")); smileList.add(new Smile(R.drawable.emotion_1085,\"[e]1085[/e]\")); smileList.add(new Smile(R.drawable.emotion_1086,\"[e]1086[/e]\")); smileList.add(new Smile(R.drawable.emotion_1087,\"[e]1087[/e]\")); smileList.add(new Smile(R.drawable.emotion_1088,\"[e]1088[/e]\")); smileList.add(new Smile(R.drawable.emotion_1089,\"[e]1089[/e]\")); smileList.add(new Smile(R.drawable.emotion_1090,\"[e]1090[/e]\")); smileList.add(new Smile(R.drawable.emotion_1091,\"[e]1091[/e]\")); smileList.add(new Smile(R.drawable.emotion_1092,\"[e]1092[/e]\")); smileList.add(new Smile(R.drawable.emotion_1093,\"[e]1093[/e]\")); smileList.add(new Smile(R.drawable.emotion_1094,\"[e]1094[/e]\")); smileList.add(new Smile(R.drawable.emotion_1095,\"[e]1095[/e]\")); &#125; return smileList; &#125;&#125; 表情资源基本准备好，现在要实现的功能是把表情添加进keyboard。可以通过GridView添加资源。 但是在添加资源时，需要借助适配器，所以还要自己构造一个表情的适配器，基本实现是将一个imageView(表情)添加进LinearLayout作为一个布局元素。 12345678910111213141516171819202122232425262728293031323334353637383940public class EmojiAdapter extends BaseAdapter &#123; private static List&lt;Smile&gt; smileList; private static Context context; public EmojiAdapter(Context context, List&lt;Smile&gt; list) &#123; EmojiAdapter.context = context; smileList = list; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ImageView imageView = new ImageView(context); imageView.setImageResource(smileList.get(position).getResId()); LinearLayout layout = new LinearLayout(context); layout.setGravity(Gravity.CENTER); layout.addView(imageView, dp2px(28), dp2px(28 + 20)); return layout; &#125; private static int dp2px(float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; @Override public int getCount() &#123; return smileList.size(); &#125; @Override public Object getItem(int position) &#123; return smileList.get(position); &#125; @Override public long getItemId(int position) &#123; return smileList.get(position).getResId(); &#125;&#125; 构造好了资源适配器就可以往GridView中加载资源了，再把GridView添加进键盘这个视图 1234567891011private void addEmojiToKeyBoard() &#123; gridView.setNumColumns(8); gridView.setId(R.id.gridView); EmojiAdapter adapter = new EmojiAdapter(getContext(), EmojiManager.getSmileList()); gridView.setAdapter(adapter);&#125;private void init() &#123; addEmojiToKeyBoard(); this.addView(gridView, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);&#125; step 4：实现编辑相关功能模块 现在基本UI已经实现，接下来就是实现对emoji的点击事件监听，从而实现在EditText中显示表情元素 表情的添加，在主Activity实现监听 参考: 在EditText中添加QQ表情 android EditText获取光标位置并插入字符删除字符 1234567891011121314151617181920212223// Called by click an emojigridView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; // Calc lineHeight for ensure icon size int lineHeight = simpleEmojiEditLayout.getLineHeight(); // Create a bitmap Bitmap bitmap = BitmapFactory.decodeResource(getResources(), (int) id); // Set width and height bitmap = Bitmap.createScaledBitmap(bitmap, lineHeight - 10, lineHeight - 10, true); // ImageSpan imageSpan = new ImageSpan(SimpleEmojiKeyboardActivity.this, bitmap); SpannableString spannableString = new SpannableString(\"e\"); spannableString.setSpan(imageSpan, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); // Get texts from textView content = simpleEmojiEditLayout.getText(); // Get cursor location location = simpleEmojiEditLayout.getSelectionStart(); // Insert text content.insert(location, spannableString); &#125;&#125;); 接下来实现func Bar的delete功能 123456789101112btndelete.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; content = simpleEmojiEditLayout.getText(); location = simpleEmojiEditLayout.getSelectionStart(); if (location != 0) &#123; content.delete(location - 1, location); &#125; else &#123; Toast.makeText(SimpleEmojiKeyboardActivity.this, \"Nothing to delete\", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;); 到这一个简单的表情键盘就实现了，其中还有很多小bug需要优化，最后把文件名列出来熟悉下这个过程。 emoji Smile EmojiManager EmojiAdapter SimpleEmojiKeyboard SimpleEmojiEditLayout SimpleEmojiKeyboardLayout SimpleEmojiKeyboardActivity 推荐阅读： Android 软键盘和emoji表情切换方案，和微信几乎一样的体验 The handler for the keyboard and panel layout conflict in Android 有机会要写一个更加完善的^_^ Tips: 作为一个Android小白，自然有很多不知道不理解的地方。如果文中有错或者有哪些值得改进的地方，欢迎大家提意见，我很开心能和大家一起交流学习，共同进步。 多谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"实现一个自动无线循环轮播图","date":"2017-04-07T04:00:00.000Z","path":"2017/04/07/SlideShow/","text":"GitHub 任务描述 每隔3秒轮播图自动滚动触摸改轮播图的时候，轮播图停止自动滚动轮播图能够循环滚动，并且第一幅图向左滚动的效果和其他图片滚动的效果要求一致。同理，最后一幅图向右滚动的效果也要求和其他图片的效果一致demo的轮播图至少包含3幅图 实现效果 实现过程 界面设计 首先要知道我们的UI界面是怎么样的，此处的设计如下图所示 代码： 1234567891011121314151617&lt;android.support.v4.view.ViewPager android:id=\"@+id/vpWallpaper\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;LinearLayout android:id=\"@+id/dotLayout\" android:gravity=\"center\" android:orientation=\"horizontal\" android:layout_alignParentBottom=\"true\" android:layout_marginBottom=\"28dp\" android:layout_centerInParent=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\"&gt;&lt;/LinearLayout&gt; 绘制UI(先设计滚动的页面，再设计指示器) 要给ViewPager添加图片，就要设置适配器和资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Set ViewPager Fragment */public static class ViewPagerFragment extends Fragment &#123; private ImageView image; private int id; public ViewPagerFragment(int id) &#123; this.id = id; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_adapter, container, false); image = (ImageView) rootView.findViewById(R.id.image); image.setImageResource(id); return rootView; &#125;&#125;// fragement layout(fragment_adapter)&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:id=\"@+id/image\" android:scaleType=\"fitXY\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:contentDescription=\"@string/image\" /&gt;&lt;/LinearLayout&gt;/** * Set ViewPager Adapter */private class ViewPagerAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); // Add pages to ViewPager private void addPage(Fragment fragment) &#123; fragmentList.add(fragment); &#125; ViewPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentList.size(); &#125;&#125; 添加资源 123456789101112131415161718private static final int[] srcId = &#123; R.drawable.pic0, R.drawable.pic1, R.drawable.pic2, R.drawable.pic3, R.drawable.pic4, R.drawable.pic5, R.drawable.pic6&#125;;ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager());// Add Fragmentsfor (int i = 0; i &lt; 7; i++) &#123; ViewPagerFragment fragment = new ViewPagerFragment(srcId[i]); adapter.addPage(fragment);&#125;viewPager.setAdapter(adapter); 设置循环效果 这里就是难点，要想实现两端的平缓循环滚动可以在两端添加一个cache page，[ 0 ( 1 2 3 4 0) 1]，只显示（）中的页，但是一旦出现cache page立马进行跳转。这样就能实现循环。接下来就是设置计时器了。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Set page change timer */@RequiresApi(api = Build.VERSION_CODES.KITKAT)private void setTimer() &#123; timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; handler.sendEmptyMessage(viewPager.getCurrentItem()); &#125; &#125;, 2000, 2000);&#125;private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 1: case 2: case 3: case 4: case 5: &#123; viewPager.setCurrentItem(msg.what + 1, true); break; &#125; // To make start or end slip smoothly case 0: &#123; viewPager.setCurrentItem(5, false); viewPager.setCurrentItem(6, true); break; &#125; case 6: &#123; viewPager.setCurrentItem(1, false); viewPager.setCurrentItem(2, true); break; &#125; default: break; &#125; &#125;&#125;; 设置平缓的滑动效果但是这种效果不能满足要求,我们可以设计一个滑动延时 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Set Duration */@RequiresApi(api = Build.VERSION_CODES.KITKAT)private void setDuration() &#123; try &#123; Field field = ViewPager.class.getDeclaredField(\"mScroller\"); field.setAccessible(true); FixSpeedScroller scroller = new FixSpeedScroller(this, new AccelerateInterpolator()); scroller.setDuration(500); field.set(viewPager, scroller); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125;/** * Set scroller duration, make it smoothly */class FixSpeedScroller extends Scroller &#123; private int _duration = 1000; FixSpeedScroller(Context context, Interpolator interpolator) &#123; super(context, interpolator); &#125; @Override public void startScroll(int startX, int startY, int dx, int dy) &#123; super.startScroll(startX, startY, dx, dy, _duration); &#125; @Override public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; super.startScroll(startX, startY, dx, dy, _duration); &#125; public void setDuration(int duration) &#123; _duration = duration; &#125;&#125; 基本效果就已经实现了，但是如果有触摸事件发生，我们要另行处理 添加点击监听 123456789101112131415161718viewPager.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; // Cancel the timer if (timer != null) &#123; timer.cancel(); timer = null; &#125; // when slip out cache view(page0, page6), set an another same page instantly if (viewPager.getCurrentItem() == 0) &#123; viewPager.setCurrentItem(5, false); &#125; if (viewPager.getCurrentItem() == 6) &#123; viewPager.setCurrentItem(1, false); &#125; return false; &#125;&#125;); 在滑动监听中恢复计时 12345678910111213141516171819viewPager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @RequiresApi(api = Build.VERSION_CODES.KITKAT) @Override public void onPageSelected(int position) &#123; &#125; @RequiresApi(api = Build.VERSION_CODES.KITKAT) @Override public void onPageScrollStateChanged(int state) &#123; // if this page was showed by figure slip, then set timer to continue auto slip for next page if (timer == null) &#123; setTimer(); &#125; &#125;&#125;); ViewPager的效果已经实现。下面开始实现指示器 指示器UI 利用两张图片实现选中和没选中效果，每张图片添加进一个LinearLayout，把所有的LinearLayout排列经另一个LinearLayout就可以实现效果 值得注意的是，在添加视图时，要加判断 123if (viewSelected.getParent() != null) &#123; ((ViewGroup) viewSelected.getParent()).removeView(viewSelected);&#125; 否则在有父布局的情况下添加不进别的视图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Create a dot view for an select view * @return view */private View createViewSelected() &#123; LinearLayout view = new LinearLayout(this); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(10, 0, 10, 0); view.setLayoutParams(lp); ImageView imageView = new ImageView(this); imageView.setImageResource(R.drawable.dot_selected); imageView.setLayoutParams(new LinearLayout.LayoutParams(30, 30)); imageView.setScaleType(ImageView.ScaleType.FIT_XY); view.addView(imageView); return view;&#125;/** * Create a dot view for an unselected view * @return view */private View createViewUnselected() &#123; LinearLayout view = new LinearLayout(this); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(10, 0, 10, 0); view.setLayoutParams(lp); ImageView imageView = new ImageView(this); imageView.setImageResource(R.drawable.dot_unselect); imageView.setLayoutParams(new LinearLayout.LayoutParams(30, 30)); imageView.setScaleType(ImageView.ScaleType.FIT_XY); view.addView(imageView); return view;&#125;/** * Refresh the Dot View when sliped * @param selectId current Id */private void refreshDotView(int selectId) &#123; dotLayout.removeAllViews(); for (int i = 1; i &lt; 6; i++) &#123; if (selectId != i) &#123; View viewUnselect = createViewUnselected(); if (viewUnselect.getParent() != null) &#123; ((ViewGroup) viewUnselect.getParent()).removeView(viewUnselect); &#125; dotLayout.addView(viewUnselect); &#125; else &#123; View viewSelected = createViewSelected(); if (viewSelected.getParent() != null) &#123; ((ViewGroup) viewSelected.getParent()).removeView(viewSelected); &#125; dotLayout.addView(viewSelected); &#125; &#125;&#125; 实现指示器功能 UI实现了之后就是实现指示功能就是直接在PageChange监听处加码就可以了，逻辑很简单，不过注意在恶劣环境下有可能会滑到cache page，这是传入的page ID要进行相应的变换 123456789101112131415161718192021222324252627282930313233// Delay to change dotviewTimer timer = new Timer();timer.schedule(new TimerTask() &#123; @Override public void run() &#123; handler.sendEmptyMessage(DOT_VIEW_CHANGE_SELECTED); &#125;&#125;, 500);// Refresh the dotView when page was loadedcase DOT_VIEW_CHANGE_SELECTED: int currentId = viewPager.getCurrentItem(); switch (currentId) &#123; case 0: &#123; refreshDotView(5); break; &#125; case 1: case 2: case 3: case 4: case 5: &#123; refreshDotView(currentId); break; &#125; case 6: &#123; refreshDotView(1); break; &#125; default: break; &#125; onCreate()调用顺序如下 12345678910public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_wallpaper); init(); listener(); setTimer(); setDuration();&#125; 不足不足比较多，在极端的操作下不流畅，比如在设置的延时中滑动次数过多会造成切换不自然，在手指滑动时更好的做法是直接监听手机的移动速度进行相关图片的移动。还有就是耗内存，内存溢出的话，可以自己在Manifest文件加两句代码 12android:hardwareAccelerated=\"false\"android:largeHeap=\"true\"","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"自定义滑动删除列表","date":"2017-04-07T03:00:00.000Z","path":"2017/04/07/SlideDeleteList/","text":"GitHub 任务描述 实现一个可以滑动删除的ListView列表，列表中的每一行可以通过从左向右滑动显示出删除按钮，点击该按钮之后删除该行 实现效果 实现过程 最开始还是要设计layout，这决定着你的代码写法。 layout activity_listview listitem content_view menu_view 我们可以把每一个Item设为一个布局控件，也就是listitem 1234567891011121314151617&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\"&gt; &lt;LinearLayout android:id=\"@+id/content\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/menu\" android:orientation=\"horizontal\" android:layout_width=\"80dp\" android:layout_height=\"match_parent\" &gt; &lt;/LinearLayout&gt;&lt;/merge&gt; 接着分别连个布局设置content和menu 12345678910111213141516171819202122232425262728content_view&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/textView\" android:text=\"@string/init_text\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:gravity=\"center_vertical\" android:layout_marginLeft=\"20dp\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt;menu_view&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/delete\" android:text=\"@string/delete\" android:textAllCaps=\"false\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:background=\"@color/colorAccent\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/RelativeLayout&gt; 接下来就很清楚了。利用listview添加控件listitem作为适配器的布局。 ViewHolder缓存加载 避免重复加载控件，采用缓存机制是比较合理的下面我们看看adapter的getView() 1234567891011121314151617181920212223242526272829303132333435363738394041public View getView(final int position, View convertView, ViewGroup parent) &#123; ViewHolder holder; SlideItemView slideItemView = (SlideItemView) convertView; if (convertView == null) &#123; // get content and menu view View contentView = inflater.inflate(R.layout.content_view, null); View menuView = inflater.inflate(R.layout.menu_view, null); // add content and menu to slideItemView slideItemView = new SlideItemView(context); slideItemView.setContentView(contentView); slideItemView.setMenuView(menuView); // setting widgets holder = new ViewHolder(contentView, menuView); // setting slide listener slideItemView.setOnSlideListener((SlideItemView.OnSlideListener) context); slideItemView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; // init widgets ItemMsg itemMsg = itemMsgList.get(position); itemMsg.setSlideItemView(slideItemView); itemMsg.getSlideItemView().shrink(); holder.text.setText(itemMsg.getContent()); holder.btnDel.setText(R.string.delete); holder.btnDel.setOnClickListener((View.OnClickListener) context); return slideItemView;&#125;private final class ViewHolder &#123; TextView text; Button btnDel; ViewHolder(View content, View menu) &#123; text = (TextView) content.findViewById(R.id.textView); btnDel = (Button) menu.findViewById(R.id.delete); &#125;&#125; 代码基本都有注释，逻辑比较清晰，主要是对适配器的控件初始化。注意返回的是slideItemView，同时也设置了监听，所以此处是加载两个布局（content,menu）合成一个slideItemView，这样便于以后的布局更改。也方便视图的添加和控件的监测。 构造slideItemView 部分函数 12345678910111213141516private void initView() &#123; Context context = getContext(); scroller = new Scroller(context); // inflate layout View.inflate(context, R.layout.listitem, this); contentView = (LinearLayout) findViewById(R.id.content); menuView = (LinearLayout) findViewById(R.id.menu);&#125;public void setContentView(View content) &#123; contentView.addView(content);&#125;public void setMenuView(View menu) &#123; menuView.addView(menu);&#125; 滑动监听 这个才是重点难点代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public boolean onTouchEvent(MotionEvent event) &#123; // Get event start coordinate int x = (int) event.getX(); int y = (int) event.getY(); int scrollX = getScrollX(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; // if another event unfinished, then finished if (!scroller.isFinished()) &#123; scroller.abortAnimation(); &#125; // get menu width btnWidth = menuView.getMeasuredWidth(); if (onSlideListener != null) &#123; onSlideListener.onSlide(this, OnSlideListener.STATUS_SLIDE_SCROLL); &#125; // represent the event was handled or consumed, see the resource code return true; &#125; case MotionEvent.ACTION_MOVE: &#123; // get offset int offsetX = x - lastX; int offsetY = y - lastY; // if offsetX miner than offsetY or offsetY more than 20, then cancel this event if (offsetY &gt; 20) &#123; break; &#125; int newScrollX = scrollX - offsetX; if (offsetX != 0) &#123; if (newScrollX &lt; 0) &#123; newScrollX = 0; &#125; else if (newScrollX &gt; btnWidth)&#123; newScrollX = btnWidth; &#125; scrollTo(newScrollX, 0); &#125; break; &#125; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: &#123; int newScroll = 0; // more than half of button width, scroll out. otherwise scroll in. if (scrollX - btnWidth * 0.7 &gt; 0) &#123; newScroll = btnWidth; &#125; smoothScrollTo(newScroll); // set item slide status if (onSlideListener != null) &#123; onSlideListener.onSlide(this, newScroll == 0 ? OnSlideListener.STATUS_SLIDE_OFF : OnSlideListener.STATUS_SLIDE_ON); &#125; break; &#125; &#125; lastX = x; lastY = y; return super.onTouchEvent(event);&#125;private void smoothScrollTo(int x) &#123; int scrollX = getScrollX(); int offsetX = x - scrollX; scroller.startScroll(scrollX, 0, offsetX, 0, Math.abs(offsetX)); invalidate();&#125;@Overridepublic void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; scrollTo(scroller.getCurrX(), scroller.getCurrY()); postInvalidate(); &#125;&#125;public void shrink() &#123; if (getScaleX() != 0) &#123; this.smoothScrollTo(0); &#125;&#125; 参考 列表滑动删除效果 Android触摸屏事件派发机制详解与源码分析一(View篇) android中的dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent 后两篇主要是讲Android中的事件分发，也就是为什么在MotionEvent.ACTION_DOWN中return true才能实现滑动效果。看了源码我们知道true代表这个控件的函数消耗这个事件，不会再分发，所以我们后面的处理事件的代码才能够执行。 设置接口 123456789101112131415161718192021222324interface OnSlideListener &#123; int STATUS_SLIDE_OFF = 0; int STATUS_SLIDE_ON = 1; int STATUS_SLIDE_SCROLL = 2; void onSlide(View view, int status);&#125;public void setOnSlideListener(OnSlideListener onSlideListener) &#123; this.onSlideListener = onSlideListener;&#125;@Overridepublic void onSlide(View view, int status) &#123; // if last slide item is on, close it if (mLastSlideViewWithStatusOn != null &amp;&amp; mLastSlideViewWithStatusOn != view) &#123; mLastSlideViewWithStatusOn.shrink(); &#125; // if a new item slide out, mark it if (status == STATUS_SLIDE_ON) &#123; mLastSlideViewWithStatusOn = (SlideItemView) view; &#125;&#125; 这个接口的主要目的是对这个ListView中Item的管理，保证当前只有一个侧滑出来。","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"实现一个TAB布局","date":"2017-04-07T02:30:00.000Z","path":"2017/04/07/TabLayout/","text":"GitHub 任务描述 实现常见的标签tab，并且点击tab跳转至对应页面实现页面滑动效果 实现效果 TabLayout + ViewPager（GIF） 实现过程 绘制页面 12345678910111213141516171819&lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPager\" android:scrollbars=\"none\" android:layout_weight=\"8\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;android.support.design.widget.TabLayout android:id=\"@+id/tabLayout\" android:layout_weight=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" app:tabGravity=\"fill\" app:tabIndicatorHeight=\"0dp\" app:tabMode=\"fixed\" app:tabSelectedTextColor=\"#FF4081\" app:tabTextColor=\"#000\"&gt;&lt;/android.support.design.widget.TabLayout&gt; 需要在配置文件中添加 compile ‘com.android.support:design:23.2.0’ 准备Adapter 1234567891011121314151617181920212223242526272829class ViewPagerAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); private List&lt;String&gt; fragmentTitleList = new ArrayList&lt;&gt;(); ViewPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; void addPage(Fragment fragment, String title) &#123; fragmentList.add(fragment); fragmentTitleList.add(title); &#125; @Override public Fragment getItem(int position) &#123; return fragmentList.get(position); &#125; @Override public int getCount() &#123; return fragmentTitleList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return fragmentTitleList.get(position); &#125;&#125; 准备Fragment布局 1234567891011121314151617181920public class ViewPagerFragment extends Fragment &#123; private String content; public ViewPagerFragment(String content) &#123; this.content = content; &#125; public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View rootView = inflater.inflate(R.layout.fragment_view_pager, container, false); TextView tvContent = (TextView) rootView.findViewById(R.id.tvContent); tvContent.setText(content); return rootView; &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125;&#125; 12345678&lt;TextView android:id=\"@+id/tvContent\" android:textSize=\"30sp\" android:hint=\"@string/default_text\" android:layout_gravity=\"center\" android:textAlignment=\"center\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 为了方便，此处所有Fragment共用一个 初始化布局 123456789101112131415161718192021222324252627/** * Init Layout, Load Fragments and draw Layouts. */private void initLayout() &#123; viewPager = (ViewPager) findViewById(R.id.viewPager); tabLayout = (TabLayout) findViewById(R.id.tabLayout); ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager()); // Add Fragments for (int i = 0; i &lt; 4; i++) &#123; adapter.addPage(new ViewPagerFragment(\"PAGE\" + i), \"PAGE\" + i); &#125; viewPager.setAdapter(adapter); // Connect TabLayout and ViewPage tabLayout.setupWithViewPager(viewPager); // Draw Tab View for (int i = 0; i &lt; 4; i++) &#123; tabListView.add(tabLayout.getTabAt(i)); if (i == 0) &#123; tabListView.get(i).setIcon(R.mipmap.selected_icon); &#125; else &#123; tabListView.get(i).setIcon(R.mipmap.ic_launcher); &#125; tabListView.get(i).setText(\"PAGE\" + i); &#125;&#125; 设置监听 123456789101112131415161718192021222324/** * Setting Tab Click Listener */private void initEvents() &#123; tabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; // Called when the tab was selected tabListView.get(tab.getPosition()).setIcon(R.mipmap.selected_icon); viewPager.setCurrentItem(tab.getPosition()); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; // Called when a tab from selected switch to unselected tabListView.get(tab.getPosition()).setIcon(R.mipmap.ic_launcher); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; // Called when a tab selected more than twice consecutively &#125; &#125;);&#125; 不足 利用控件已有的性质，基本的Tab切换已经实现。但是没有自己手动实现滑动等控件的效果。实现方式有很多种，以后来补充。 Tips: 作为一个Android小白，自然有很多不知道不理解的地方。如果文中有错或者有哪些值得改进的地方，欢迎大家提意见，我很开心能和大家一起交流学习，共同进步。 多谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]},{"title":"复现ANR","date":"2017-04-07T02:00:00.000Z","path":"2017/04/07/RecurrentANR/","text":"GitHub 任务描述写出不少于3种常见ANR错误的Android代码 主线程复现ANR BroadcastReceiver复现ANR Service复现ANR 1.什么是ANR? ANR(Application Not Responding),应用程序无响应. 参考ANR完全解析 2.ANR的三种类型 KeyDispatchTimeout(5 seconds) 主要类型按键或触摸事件在特定时间内无响应 BroadcastTimeout(10 seconds) BroadcastReceiver在特定时间内无法处理完成 ServiceTimeout(20 seconds) 小概率类型 Service在特定的时间内无法处理完成 3.复现ANRI 主线程复现ANR 代码 1234567891011121314/** * Recurrent ANR in main Thread */private void mainThreadANR() &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"MainThreadANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(20 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(\"MainThreadANR\", \"mainThreadANR() Done\");&#125; 结果 II BroadcastReceiver复现ANR 代码 1234567891011121314public class BroadcastANR extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"BroadcastANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(80 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; III Service复现ANR 代码 1234567891011121314151617181920public class ServiceANR extends Service &#123; @Override public void onCreate() &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"ServiceANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(60 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 4.避免ANR要想避免ANR，首先要分析为什么会发生ANR，主要是在一些不能耗时操作的函数中处理代码的时间过长，所以把耗时长的程序写入其他子进程中就可以避免。ANR机制以及问题分析写的很详细。 首先我们看看Log 12345678MainThreadANR: I/MainThreadANR: myLooper=Looper (main, tid 1) &#123;13467e36&#125;; mainLooper=Looper (main, tid 1) &#123;13467e36&#125;BroadcastANR:I/BroadcastANR: myLooper=Looper (main, tid 1) &#123;33c6137&#125;; mainLooper=Looper (main, tid 1) &#123;33c6137&#125;ServiceANR:I/ServiceANR: myLooper=Looper (main, tid 1) &#123;303e756a&#125;; mainLooper=Looper (main, tid 1) &#123;303e756a&#125; 前面的三个ANR都有一个特点，那就是当前的线程都是主线程，细心点会发现其实还有一句丢帧Log打印 1Skipped 1204 frames! The application may be doing too much work on its main thread. 我实现下通过在主线程中创建一个新线程的方法来避免ANR 代码 1234567891011121314151617181920/** * Deal ANR in main Thread */private void mainThreadNotANR() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Looper myLooper = Looper.myLooper(); Looper mainLooper = Looper.getMainLooper(); Log.i(\"MainThreadNotANR\", \"myLooper=\" + myLooper + \"; mainLooper=\" + mainLooper); try &#123; Thread.sleep(20 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.i(\"MainThreadNotANR\", \"Thread Run() Done\"); &#125; &#125;).start(); Log.i(\"MainThreadNotANR\", \"mainThreadNotANR() Done\");&#125; 下面我们来对比下和主线程中直接处理的Log有什么不同 12345678910111213141516MainThreadNotANR:点击按钮MainThreadNotANRI/MainThreadNotANR: mainThreadNotANR() DoneI/MainThreadNotANR: myLooper=null; mainLooper=Looper (main, tid 1) &#123;303e756a&#125;I/MainThreadNotANR: ThreadRun() DoneW/art: Suspending all threads took: 6.032msMainThreadANR:点击按钮MainThreadANRI/MainThreadANR: myLooper=Looper (main, tid 1) &#123;303e756a&#125;; mainLooper=Looper (main, tid 1) &#123;303e756a&#125;I/MainThreadANR: mainThreadANR() Done再多次点击按钮MainThreadANRI/Choreographer: Skipped 1200 frames! The application may be doing too much work on its main thread.I/MainThreadANR: myLooper=Looper (main, tid 1) &#123;303e756a&#125;; mainLooper=Looper (main, tid 1) &#123;303e756a&#125;I/art: Thread[5,tid=2037,WaitingInMainSignalCatcherLoop,Thread*=0xef70d400,peer=0x12c00080,&quot;Signal Catcher&quot;]: reacting to signal 3I/art: Wrote stack traces to &apos;/data/anr/traces.txt&apos; 从Log中可以看出MainThreadNotANR中先打印mainThreadNotANR() Done后打印ThreadRun() Done说明代码没在MainThreadNotANR这个线程中运行，从myLooper=null; mainLooper=Looper (main, tid 1) {303e756a}可以验证我们的猜想。而MainThreadANR中就很明显，各种丢帧奔溃。不过I/art: Wrote stack traces to ‘/data/anr/traces.txt’告诉我们可以在/data/anr/traces.txt中追踪奔溃的缘由1234567891011121314151617181920212223242526traces.txtDALVIK THREADS (18):&quot;main&quot; prio=5 tid=1 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x73581970 self=0xf4306800 | sysTid=2030 nice=0 cgrp=apps sched=0/0 handle=0xf7761160 | state=S schedstat=( 545706267 72336573 314 ) utm=30 stm=23 core=3 HZ=100 | stack=0xff7c7000-0xff7c9000 stackSize=8MB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x2ce90c0d&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x2ce90c0d&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at org.fitzeng.recurrentanr.MainActivity.mainThreadANR(MainActivity.java:47) at org.fitzeng.recurrentanr.MainActivity.onClick(MainActivity.java:81) at android.view.View.performClick(View.java:4756) at android.view.View$PerformClick.run(View.java:19749) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:135) at android.app.ActivityThread.main(ActivityThread.java:5221) at java.lang.reflect.Method.invoke!(Native method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:899) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:694) 这是定位ANR的有效手段。 Tips: 作为一个Android小白，自然有很多不知道不理解的地方。如果文中有错或者有哪些值得改进的地方，欢迎大家提意见，我很开心能和大家一起交流学习，共同进步。 多谢阅读","tags":[{"name":"Android","slug":"Android","permalink":"http://fitzeng.org/tags/Android/"}]}]