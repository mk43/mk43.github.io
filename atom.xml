<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fitzeng</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fitzeng.org/"/>
  <updated>2018-02-17T03:38:28.204Z</updated>
  <id>http://fitzeng.org/</id>
  
  <author>
    <name>fitzeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习基本算法之逻辑回归</title>
    <link href="http://fitzeng.org/2018/02/16/MLLogisticRegression/"/>
    <id>http://fitzeng.org/2018/02/16/MLLogisticRegression/</id>
    <published>2018-02-16T03:27:00.000Z</published>
    <updated>2018-02-17T03:38:28.204Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<blockquote>
<p>写在前面：我将从一个入门者的视角（水平）将机器学习中的常用算法娓娓道来。自身水平确实有限，如果其中有什么错误的话希望大家指出，避免误导大家。然后这是这个系列的第二篇了，对于初学者来说，如果你没看过第一篇，推荐看看<a href="http://fitzeng.org/2018/02/11/MLLinearRegression/">机器学习基本算法之线性回归</a>，里面提及到了很多基础的数学知识和一些的机器学习思维，对于理解这篇文章很有帮助，很多机器学习流程化的东西这里就不在具体介绍为什么这样做了，而是直接解释为什么在逻辑回归中需要使用这样的方式来实现，更加聚焦于逻辑回归实现本身，而非机器学习的流程理解。</p>
<p><a href="https://github.com/mk43/machine-learning/tree/master/algorithm/logistic-regression" target="_blank" rel="external">实验代码</a>-<a href="https://github.com/mk43/machine-learning/tree/master/reference" target="_blank" rel="external">参考书籍</a>-[参考博客详见最后]</p>
</blockquote>
<a id="more"></a>
<h2 id="0-准备"><a href="#0-准备" class="headerlink" title="0 准备"></a>0 准备</h2><h3 id="0-1-环境"><a href="#0-1-环境" class="headerlink" title="0.1 环境"></a>0.1 环境</h3><blockquote>
<p>Python: 3.5</p>
<p>TensorFlow: Anaconda3 envs</p>
<p>IDE: PyCharm 2017.3.3</p>
</blockquote>
<h3 id="0-2-基本认识"><a href="#0-2-基本认识" class="headerlink" title="0.2 基本认识"></a>0.2 基本认识</h3><p>如果你看过前面的线性回归介绍，可以知道，线性回归是通过对一类呈线性分布的数据进行拟合，然后训练一个线性模型对数据进行预测。那么在逻辑回归中，可以暂时理解为处理分类问题。比如给出一个人的经纬度，要判断这个人在哪个国家，如果仅仅以线性回归的思维，我们很难根据经纬度去构造出一个很好的线性模型去预测地区，我们就需要知道的是国家分界线，而这些分界线的获得就是通过逻辑回归。</p>
<h2 id="1-二元分类"><a href="#1-二元分类" class="headerlink" title="1 二元分类"></a>1 二元分类</h2><h3 id="1-1-提出拟合函数-Sigmoid"><a href="#1-1-提出拟合函数-Sigmoid" class="headerlink" title="1.1 提出拟合函数 Sigmoid"></a>1.1 提出拟合函数 <code>Sigmoid</code></h3><p>如果你还没有太理解逻辑回归处理的问题和线性回归比的独特性，我们再来举个小例子(注意：为了简单，这里的数据都是特殊取值的)，来引出今天的主角：</p>
<p><img src="/2018/02/16/MLLogisticRegression/linear2LogisticreGressionGraph.png" alt=""></p>
<p>对于上面这张图，很明显，怎么画直线也不好，总会产生较大的误差。而如果有一个函数能够表示：</p>
<p>$$<br>y=\begin{cases}<br>1,\quad x &gt; 5 \\<br>0,\quad x \leq 5<br>\end{cases}<br>$$</p>
<p>那么就完美符合当前的数据分布，直觉告诉我们有很大可能其对数据的预测能力也比较强。接下来，就是找一个 \( S \) 形函数来作为拟合函数。这里很明显我们的函数不是线性的。这里提出一个叫 \( Sigmoid \) 的函数：</p>
<p>$$<br>y = \frac{1}{1 + e^{-x}}<br>$$</p>
<p><img src="/2018/02/16/MLLogisticRegression/linear2LogisticreGressionGraphAddSigmoid.png" alt=""></p>
<p>从图像中可以看到，这个函数的完美符合我们心中的预期。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div><div class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line"></div><div class="line">train_X = np.asarray(x)</div><div class="line">train_Y = np.asarray(y)</div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">plt.xlim(<span class="number">-1</span>, <span class="number">12</span>)</div><div class="line">plt.ylim(<span class="number">-0.5</span>, <span class="number">1.5</span>)</div><div class="line">plt.scatter(train_X, train_Y)</div><div class="line"></div><div class="line">s_X = np.linspace(<span class="number">-2</span>, <span class="number">12</span>, <span class="number">100</span>)</div><div class="line">s_Y = <span class="number">1</span>/(<span class="number">1</span> + np.power(np.e, <span class="number">-6</span>*(s_X - <span class="number">5</span>)))</div><div class="line">plt.plot(s_X, s_Y)</div><div class="line">plt.savefig(<span class="string">"linear2LogisticreGressionGraphAddSigmoid.png"</span>)</div><div class="line"><span class="comment"># plt.savefig("linear2LogisticreGressionGraph.png")</span></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h3 id="1-2-扩充分类"><a href="#1-2-扩充分类" class="headerlink" title="1.2 扩充分类"></a>1.2 扩充分类</h3><p>前面已经说了，为了更好体会逻辑回归，所以数据有点特殊和单一，下面我们再来看一组数据：</p>
<p><img src="/2018/02/16/MLLogisticRegression/linear2LogisticreGressionGraphAddScatter.png" alt=""></p>
<p>像这种有明显的聚拢效果的散点图，可以看做是一个分类问题，所以对于这里我们怎么利用前面提到的逻辑回归来处理类似于这种分类问题？</p>
<p>这里思维要稍微转换一下，以前我们以 \( y \) 的值作为输出，这里不是了，这里需要预测的结果是给定 \( (x, y) \) 求出该点是红色的圆形还是蓝色的三角形？所以要找一个形如  \( g(x, y) \)<br>的函数来处理，前面的 \( Sigmoid\)函数可以帮我们分类，只要假设 \( 1 \) 和 \( 0 \) 各代表一种情况，那么得出 \( 1/0 \) 时就可以推断出 \( (x, y) \)现在的情况是红色的圆形还是蓝色的三角形，现在的情况是，如何将 \( g(x, y) \) 预处理的结果与 \( Sigmoid \) 函数联系起来。可能你已经想到了，将 \( g(x, y) \) 的值域当做 \( Sigmoid \) 的定义域。那么给定一个 \( (x,y) \) 我们就能得出一个在区间 \( [0, 1] \) 内的值。这下，函数就能够满足我们的要求了。</p>
<p>模仿前面机器学习的思维，我们对于给定的输入统一用一个输入矩阵 \( X \) 表示 \( (x, y) \) 然后加入权重 \( W \)，则得出函数 \( g(W, X) \)，接下来我们要定义一个模型去区分这种分布？如果你看过代码就知道，在做数据的时候默认就是利用 \( x + y &gt; 7 \) 来分的类，所以自然取的是线性模型作为首选。至于怎么选模型我认为最简洁的表示往往就是最好的，下面看看吴恩达老师的例子体会一下这个过程。</p>
<p><img src="/2018/02/16/MLLogisticRegression/wuenda_1.png" alt=""></p>
<p>既然是线性，那么直接得出 \( g(W, X) = W^TX \) 这里提醒下加 \({}^T \) 是因为我们默认的向量都是列向量。 理解了这里那就好办了，综合我们的 \( Sigmoid \) 可以得出拟合函数：</p>
<p>$$<br>h_W(X) = \frac{1}{1 + e^{-W^TX}}<br>$$</p>
<h3 id="1-3-从直观感受推导损失函数"><a href="#1-3-从直观感受推导损失函数" class="headerlink" title="1.3 从直观感受推导损失函数"></a>1.3 从直观感受推导损失函数</h3><p>既然我们都已经把数据做了处理，所以对于输入是二元还是一元没差了，就是一个 \( h_W(X) \)而已。下面我们根据之前线性函数的例子，找一个适合描述误差的函数。看图：</p>
<p><img src="/2018/02/16/MLLogisticRegression/linear2LogisticreGressionGraphAddSigmoid2.png" alt=""></p>
<p>下面我们先只分析为 \( 1 \) 的点如何通过 \( h_W(x_1) &lt; h_W(x_2) &lt; h_W(x_3) \) 的关系找到一个函数来表达损失。首先可以肯定的是，要对 \( h_W(x_1) \) 的惩罚力度是最大的。因为从图中看出对它的预测最离谱，所以损失函数要是一个递减函数，然后继续分析损失函数是否对于 \( h_W(x_i) \) 的变化呈均匀变化，也就是这个递减函数的递减幅度是设么样的？很明显，\( h_W(x_i) \) 越靠近 \( 0 \)，它的惩罚力度应该和指数增长有点类似。越小一点点，惩罚力度立刻激增，这样对于最后损失函数收敛时的参数拟合结果比较符合大多数数据的情况，不会出现它极端的分类，因为对极端的数据处罚力度实在是太大了。好了，这个函数符合三个特点，<code>递减</code>、<code>导数绝对值递减</code>（递减幅度要减小）和定义域在 \( [0, 1] \)内的跨度必须大，最好是从正无穷到 \( 0 \) 因为如果函数值为 \( 0 \)我们就不要对这个点进行惩罚了，所以肯定是要有 \( 0 \) 这个函数值的。这时你可能想到了，对数函数正好满足情况。所以有如下结果：</p>
<p>$$<br>loss(h_W(x_i), y_i) = -log(h_W(x_i))\quad if\ y_i = 1<br>$$</p>
<p>这里就不贴函数图了，下面大家自己分析一下 \( y = 0 \) 的情况。自己实在想不出来再往下阅读吧，如果直接看缺少思考过程对自己的理解可能有点欠缺。就像很多书很多博客都是直接给公式，虽然勉强也能看懂，但是更多时候是自己记住，对于其中的思考过程没有一点自己的体会和心得。给个图大家自己猜猜：</p>
<p><img src="/2018/02/16/MLLogisticRegression/linear2LogisticreGressionGraphAddSigmoid3.png" alt=""></p>
<p>下面直接给出最后的结果：</p>
<p>$$<br>loss(h_W(x_i), y_i) = -y_i <em> log(h_W(x_i)) - (1 - y_i)</em>log(1 - h_W(x_i))<br>$$</p>
<h3 id="1-4-从概率论角度分析损失函数"><a href="#1-4-从概率论角度分析损失函数" class="headerlink" title="1.4 从概率论角度分析损失函数"></a>1.4 从概率论角度分析损失函数</h3><p>还记得前面说的逻辑回归可以看做是分类问题吗？而对于分类问题的预测我们可以看做概率来计算。所以函数 \( h_W(x_i) \) 可以看做，在 \( W \) 下，输入 \( x_i \) 取值为 \( 1 \) 的概率。而我们要做的就是求出一个 \( W \) 是的对于给定的 \( x_i \) 的概率尽可能和 \( y_i \) 符合。这时候你会发现，结果 \( y_i \) 服从伯努利分布，也就是随机变量 \( Y \)的取值只能是 \( 0/1 \)，在 \( h_W(x_i) \) 看做是取 \( 1 \) 的概率的情况下，当这个值大于 \( 0.5 \) 我们认为分类为 \( 1 \)。</p>
<p>好了，把上面的东西都“忘掉”，接下来进入一个概率论的思维模式。假设这一个平面内有无数个点，而我们给出的数据只是一个抽样数据。但是我们不可能把所有的情况都列举出来，所以我们要做的就是通过给出的样本来估测整体分布。其实这也和机器学习需要大量样本训练有关，很明显数据量越大，偶然误差越小，样本的分布越接近整体分布。收回到概率论，我发现容易写着写着就跑偏了😂😂😂。现在我们统计数据的情况是：符合伯努利分布。而这种知道分布的求能够和分布匹配的参数的方法概率论中有一个参数估计方法叫：<code>极大似然估计</code>。如果不懂看一下简短介绍：</p>
<blockquote>
<p>极大似然估计，通俗理解来说，就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！<br>换句话说，极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。</p>
</blockquote>
<p>参考自<a href="https://zhuanlan.zhihu.com/p/26614750" target="_blank" rel="external">@忆臻：一文搞懂极大似然估计</a></p>
<p>依照上面的意思那很明显，我们是把 \( h_W(x_i) = P(y = 1|x_i;W)\) 那自然就有：</p>
<p>$$<br>P(y_i|x_i;W) = {h_W(x_i)}^{y_i} * {(1 - h_W(x_i))}^{1 - y_i}<br>$$</p>
<p>这是单个 \(（x_i, y_i）\)的概率。如果把整个样本看做 \( n \) 次的独立重复实验呢？那发生的概率就是这个的乘积了。这里使用 \( X, Y \) 向量表示整个数据。即：</p>
<p>$$<br>P(Y|X;W) = \prod_{i = 1}^{n}P(y_i|x_i; W) = \prod_{i = 1}^{n}{h_W(x_i)}^{y_i} * {(1 - h_W(x_i))}^{1 - y_i}<br>$$</p>
<p>可以看出这是一个关于 \( W \) 的函数，现在比较玄学的部分来了，我们认为，这个事件既然发生了，那么它发生的概率就应该是所有事件中概率最大的，如果不是那它凭什么发生？哈哈，就是这么讲道(xuan)理(xue)。最大值？那就好办了，直接求导？不行不行，太难了。。。高中最常用的把戏：乘变加，用对数。然后乘以 \( -\frac{1}{n} \) 就编程求最小值了。</p>
<p>$$<br>loss(W) = -\frac{1}{n}log(P(Y|X;W)) = -\frac{1}{n}\sum_{i = 1}^{n}y_i <em> log(h_W(x_i)) + (1 - y_i)</em>log(1 - h_W(x_i))<br>$$</p>
<h3 id="1-5-梯度下降求极值"><a href="#1-5-梯度下降求极值" class="headerlink" title="1.5 梯度下降求极值"></a>1.5 梯度下降求极值</h3><p>前面已经给出了损失函数，我们再次利用梯度下降算法更新权重。如果自己手写代码来实现，我们还是要求偏导的😂😂😂</p>
<p>高数的东西，这里偷懒了，字有点难打就直接截图了，毕竟这不是什么难点：</p>
<p><img src="/2018/02/16/MLLogisticRegression/wuenda_2.png" alt=""></p>
<p>那么更新函数就是：</p>
<p>$$<br>w_j := w_j - \frac{\alpha}{n}\sum_{i=1}^{n}(h_W(x_i) - y_i)x_{i_j}<br>$$</p>
<p>注意这里的 \( i, j \)，\( x_i \) 代表的是一个列向量，\( x_{i_j} \) 代表第 \( i \) 列第 \( j \) 个数字。其实仔细想想就可以发现，更新的 \( w_j \)就是一个数，对它求偏导的时候余出来就是和它相乘的那个 \( x_{i_j} \)。由于前面都是从单个点开始研究，为了好理解所以直接使用下标表示，但是在使用线性边界函数的时候要有一个矩阵的思想。这里就不细讲了，后面多元的就必须使用向量形式了。</p>
<h3 id="1-6-手写代码"><a href="#1-6-手写代码" class="headerlink" title="1.6 手写代码"></a>1.6 手写代码</h3><p>好了，基本逻辑已经搞清楚了，就是和线性回归类似，只不过这里处理的是一个线性二分类问题，需要对原始数据处理成线性值然后把线性值映射到 \( sigmoid \) 函数的定义域上，根据 \( sigmoid \) 函数特征我们可以得出数据分类为正 \( (1) \) 的概率大小，然后进行评估。</p>
<p>如果对公式还有什么不懂的话，参考这篇 <a href="http://blog.csdn.net/ligang_csdn/article/details/53838743" target="_blank" rel="external">机器学习–Logistic回归计算过程的推导</a> 里面讲解了如何向量化，如果你对线性代数不熟悉可以自己去看看这篇文章的讲解。下面我只讲解代码，就不对原理重复介绍了。</p>
<p>需要的库和数据，这里为了获取更好的精度最好使用 <code>float64</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.animation <span class="keyword">as</span> animation</div><div class="line"></div><div class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div><div class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line"></div><div class="line">train_X = np.asarray(np.row_stack((np.ones(shape=(<span class="number">1</span>, len(x))), x)), dtype=np.float64)</div><div class="line">train_Y = np.asarray(y, dtype=np.float64)</div><div class="line">train_W = np.asarray([<span class="number">-1</span>, <span class="number">-1</span>], dtype=np.float64).reshape(<span class="number">1</span>, <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>定义 \( sigmoid \) 和 \( loss \) 函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(X)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.power(np.e, -(X)))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lossfunc</span><span class="params">(X, Y, W)</span>:</span></div><div class="line">    n = len(Y)</div><div class="line">    <span class="keyword">return</span> (<span class="number">-1</span> / n) * np.sum(Y * np.log(sigmoid(np.matmul(W, X))) + (<span class="number">1</span> - Y) * np.log((<span class="number">1</span> - sigmoid(np.matmul(W, X)))))</div></pre></td></tr></table></figure>
<p>实现参数更新（梯度下降算法）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span><span class="params">(X, Y, W, learningrate=<span class="number">0.001</span>, trainingtimes=<span class="number">500</span>)</span>:</span></div><div class="line">    n = len(Y)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(trainingtimes):</div><div class="line">        W = W - (learningrate / n) * np.sum((sigmoid(np.matmul(W, X)) - Y) * X, axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>这里的一个重点是把之前的分析向量化了，然后注意维度变化就很简单了。其中 \( axis=1 \) 是一个值得注意的点，它代表求某个维度的和。</p>
<p>其实到这里整个算法就算是完成了。下面我们进行可视化，不会的可以参考我之前的文章 <a href="http://fitzeng.org/2018/02/08/MatplotlibGenerateGif/">Matplotlib 保存 GIF 动图</a>，下面给出效果和源代码：</p>
<p><img src="/2018/02/16/MLLogisticRegression/logisticregression.gif" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.animation <span class="keyword">as</span> animation</div><div class="line"></div><div class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</div><div class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line"></div><div class="line">train_X = np.asarray(np.row_stack((np.ones(shape=(<span class="number">1</span>, len(x))), x)), dtype=np.float64)</div><div class="line">train_Y = np.asarray(y, dtype=np.float64)</div><div class="line">train_W = np.asarray([<span class="number">-1</span>, <span class="number">-1</span>], dtype=np.float64).reshape(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(X)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.power(np.e, -(X)))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lossfunc</span><span class="params">(X, Y, W)</span>:</span></div><div class="line">    n = len(Y)</div><div class="line">    <span class="keyword">return</span> (<span class="number">-1</span> / n) * np.sum(Y * np.log(sigmoid(np.matmul(W, X))) + (<span class="number">1</span> - Y) * np.log((<span class="number">1</span> - sigmoid(np.matmul(W, X)))))</div><div class="line"></div><div class="line"></div><div class="line">Training_Times = <span class="number">100000</span></div><div class="line">Learning_Rate = <span class="number">0.3</span></div><div class="line"></div><div class="line">loss_Trace = []</div><div class="line">w_Trace = []</div><div class="line">b_Trace = []</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span><span class="params">(X, Y, W, learningrate=<span class="number">0.001</span>, trainingtimes=<span class="number">500</span>)</span>:</span></div><div class="line">    n = len(Y)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(trainingtimes):</div><div class="line">        W = W - (learningrate / n) * np.sum((sigmoid(np.matmul(W, X)) - Y) * X, axis=<span class="number">1</span>)</div><div class="line">        <span class="comment"># for GIF</span></div><div class="line">        <span class="keyword">if</span> <span class="number">0</span> == i % <span class="number">1000</span> <span class="keyword">or</span> (<span class="number">100</span> &gt; i <span class="keyword">and</span> <span class="number">0</span> == i % <span class="number">2</span>):</div><div class="line">            b_Trace.append(W[<span class="number">0</span>, <span class="number">0</span>])</div><div class="line">            w_Trace.append(W[<span class="number">0</span>, <span class="number">1</span>])</div><div class="line">            loss_Trace.append(lossfunc(X, Y, W))</div><div class="line">    <span class="keyword">return</span> W</div><div class="line"></div><div class="line"></div><div class="line">final_W = gradientDescent(train_X, train_Y, train_W, learningrate=Learning_Rate, trainingtimes=Training_Times)</div><div class="line"></div><div class="line">print(<span class="string">"Final Weight:"</span>, final_W)</div><div class="line">print(<span class="string">"Weight details trace: "</span>, np.asarray([b_Trace, w_Trace]))</div><div class="line">print(<span class="string">"Loss details trace: "</span>, loss_Trace)</div><div class="line"></div><div class="line">fig, ax = plt.subplots()</div><div class="line">ax.scatter(np.asarray(x), np.asarray(y))</div><div class="line">ax.set_title(<span class="string">r'$Fitting\ line$'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        ax.lines.pop(<span class="number">0</span>)</div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    plot_X = np.linspace(<span class="number">-1</span>, <span class="number">12</span>, <span class="number">100</span>)</div><div class="line">    W = np.asarray([b_Trace[i], w_Trace[i]]).reshape(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line">    X = np.row_stack((np.ones(shape=(<span class="number">1</span>, len(plot_X))), plot_X))</div><div class="line">    plot_Y = sigmoid(np.matmul(W, X))</div><div class="line">    line = ax.plot(plot_X, plot_Y[<span class="number">0</span>], <span class="string">'r-'</span>, lw=<span class="number">1</span>)</div><div class="line">    ax.set_xlabel(<span class="string">r"$Cost\ %.6s$"</span> % loss_Trace[i])</div><div class="line">    <span class="keyword">return</span> line</div><div class="line"></div><div class="line"></div><div class="line">ani = animation.FuncAnimation(fig, update, frames=len(w_Trace), interval=<span class="number">100</span>)</div><div class="line">ani.save(<span class="string">'logisticregression.gif'</span>, writer=<span class="string">'imagemagick'</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h2 id="2-多元分类"><a href="#2-多元分类" class="headerlink" title="2 多元分类"></a>2 多元分类</h2><p>先从三元分类开始了解，加入给了以下分布，要你求边界：</p>
<p><img src="/2018/02/16/MLLogisticRegression/multiClass3ToAll.png" alt=""></p>
<p>比起前面的来就难多了，首先前面是线性分类的而这里很明显不是，其次这里又多出了一个变量。。。别急，对比一下三幅图你就清楚了。</p>
<p><img src="/2018/02/16/MLLogisticRegression/multiClass3To1.png" alt=""><br><img src="/2018/02/16/MLLogisticRegression/multiClass3To2.png" alt=""><br><img src="/2018/02/16/MLLogisticRegression/multiClass3To3.png" alt=""></p>
<p>这里我们就解决了多一个变量的问题，通过选取一个主变量为 \( 1 \)，其它的值就为 \( 0 \)，然后就可以进行二分。还有一个问题是如何选取参数？我们既然可以转换成二分问题了，那么对于每一次二分都只要选取 \( (W, X) \) 了。\( X \) 很明显有两个基本的 \( (X1, X2) \) 但是为了能过选取更加合适的边界，如果只是这两个特征的话是不够的，所以其它的 \( X1^2，X1*X2 \ldots \) 等等，看你要拟合成什么样的边界就选取什么样的特征，同理三维就选取一个能表达弯弯曲曲的平面的特征量。下面选取权重，也就是特征前前面的系数，如果特征选取好了，那么只要在此基础上加一个 \( bias \) 就好了。</p>
<p>下面我们来举个小例子如何操作：</p>
<p><img src="/2018/02/16/MLLogisticRegression/circleGraph.png" alt=""></p>
<p>很明显这里有一个包围趋势，所以理所当然想到圆。也就是说选取的 \( X: X1,\ X2,\ X1^2,\ X2^2 \) 那么\( sigmoid \)函数就可以定义为：</p>
<p>$$<br>h_{(bias, w_1, w_2, w_3, w_4)}({x_1, x_2, x_1^2, x_2^2}) = \frac{1}{1 + e^{-{bias + w_1 <em> x_1 + w_2 </em> x_2 + w_3 <em> x_1^2 + w_4 </em> x_2^2}}}<br>$$</p>
<p>至于解法就和上面类似了，把这些都抽象成向量，那么至于什么维度，有几个变量都没差了。需要记得的是，这里要跑的次数是分类的种数的大小，也就是把每一种都当做主角处理一次得到属于它把其它元素区分的分界线，预测是也要把所有模型跑一遍，哪个模型的概率高就取哪个作为分类预测的结果。</p>
<p>这里就不详细介绍应用了，以后有机会补充代码实践，下面给出几篇参考博客：</p>
<ul>
<li><a href="http://blog.csdn.net/gamer_gyt/article/details/51236978" target="_blank" rel="external">《机器学习实战》Logistic回归算法（1）</a></li>
<li><a href="http://blog.csdn.net/lookqlp/article/details/51161640" target="_blank" rel="external">逻辑回归梯度下降法详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28775274" target="_blank" rel="external">深入机器学习系列3-逻辑回归</a></li>
</ul>
<h2 id="3-模型优化"><a href="#3-模型优化" class="headerlink" title="3 模型优化"></a>3 模型优化</h2><h3 id="3-1-算法方向"><a href="#3-1-算法方向" class="headerlink" title="3.1 算法方向"></a>3.1 算法方向</h3><p>求解最优化问题不只是只有梯度下降算法，还有其它能够收敛更快的方式。比如：共轭梯度法 <code>BFGS</code> (变尺度法) 和 <code>L-BFGS</code> (限制变尺度法) 等，不过我现在还没看过这些算法的具体实现，这里就立下 FLAG 了。不过一般我们使用这些算法都是调用现成的库，毕竟自己写的算法多多少少还是有缺陷的，</p>
<h3 id="3-2-拟合度方向"><a href="#3-2-拟合度方向" class="headerlink" title="3.2 拟合度方向"></a>3.2 拟合度方向</h3><p>在之前的例子中，你会发现个选取好特征量之后，怎么选取迭代次数很重要。举个小例子：我们拟合一个符合二次函数分布的散点图，如果你选取的模型是 \( b + w*x \) 那怎么跑都跑不出理想结果，必须把 \( x^2 \) 这个特征项加上，这样就不会欠拟合。同样，如果你选取好了一个二次模型，但是迭代次数不够，也会导致欠拟合，讲道理如果模型预测和分布一致，那么迭代次数自然是越多越好。但但是，如果你不能确定，又加一个 \( x^3 \) 的特征量进去，本来是数据是符合二次函数的特征，如果训练次数控制得比较好，也可以训练出好模型，无非就是把 \( x^3 \) 的权重置零，如果训练次数控制不好，那么必将造成欠拟合（训练次数过少）或过拟合（训练次数过多），这里不是说损失函数值越小越少，而是说那拟合函数的趋势符合整体数据的趋势，从概率论的角度讲，就是我们抽取的是总体中的一个样本，由于获得全体数据不现实，所以只能使用样本估计整体，所以这里的估计的就应该是一个趋势。</p>
<p>那么如何避免过拟合或欠拟合呢？我觉得可以从一下角度考虑：</p>
<ul>
<li>数据量（越多越好）</li>
<li>特征量（最小能描述趋势原则）</li>
<li>训练次数（朝着趋势行进方向训练次数越多越好）</li>
</ul>
<p>总之这里最最关键的是模型的准确度，如果一开始模型选错那怎么迭代也不会跑出好的效果。</p>
<p>下面给出吴恩达老师的课件图，大家体会一下：</p>
<p><img src="/2018/02/16/MLLogisticRegression/wuenda_3.png" alt=""></p>
<p><img src="/2018/02/16/MLLogisticRegression/wuenda_4.png" alt=""></p>
<p>可以看到，我们还有一种方式处理：<code>正则化</code></p>
<p>我根据我自己的理解来大胆解释一下吧，如果你有自己的理解就可以不看了。。避免误导。正则化一般就是解决过拟合，也就是我们根本不能确定趋势，所以添加了很多多余的特征量，那么对于这个模型什么样的结果是我们可以接受的呢？如果那些多余特征量的权重接近 \( 0 \) 是不是就意味着我们也能得到较好的拟合效果，甚至和没有这些干扰特征是达到一样的效果。这里就是对那些特征量的系数进行处罚达到这个目的的。</p>
<p>从上面的解释可以看出，我们不需要对 \( bias \) 进行惩罚，所以结果就是在损失函数后面加上 \( \sum_{i = 1}^{n}{w_i}^2 \)。当然这只是其中一种方式，你可以选取其可行的方式，主要目的是避免权重过大，拟合的曲线过于弯曲（因为求导之后，斜率和系数是正相关的）。这里的哲学思想就是在拟合结果能够接受的情况下，曲线越平滑，容错能力越高，样本越能够代表总体。</p>
<p>这里就直接截图举例子了：</p>
<ul>
<li><p>正则化线性回归<br><img src="/2018/02/16/MLLogisticRegression/wuenda_5.png" alt=""></p>
</li>
<li><p>正则化逻辑回归</p>
</li>
</ul>
<p><img src="/2018/02/16/MLLogisticRegression/wuenda_6.png" alt=""><br><img src="/2018/02/16/MLLogisticRegression/wuenda_7.png" alt=""></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>经过一些细节的阅读，对整个过程的了解又加深了不少。动手实践才是最好的方式，之前以为自己公式看懂了就行了，然后这次写代码是把一个变量写在了括号里面，死活拟合不出效果。然后花了几个小时之后决心自己再推一遍公式并且重新敲一下公式代码（因为打印数据发现很诡异），后面就一遍过了。所以如果你也是刚刚开始学习，哪怕照着敲一遍，之后也要自己将思路整理成文字/代码形式，最好是能整理成博客，方便以后自己复习。</p>
<p>还是很喜欢那就话：<code>花时间弄懂细节就是节省时间</code></p>
<p>最后：Happy Year Of Dog ^_^ ! </p>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/26614750" target="_blank" rel="external">@忆臻：一文搞懂极大似然估计</a></li>
<li><a href="http://blog.csdn.net/ligang_csdn/article/details/53838743" target="_blank" rel="external">机器学习–Logistic回归计算过程的推导</a></li>
<li><a href="http://blog.csdn.net/gamer_gyt/article/details/51236978" target="_blank" rel="external">《机器学习实战》Logistic回归算法（1）</a></li>
<li><a href="http://blog.csdn.net/lookqlp/article/details/51161640" target="_blank" rel="external">逻辑回归梯度下降法详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28775274" target="_blank" rel="external">深入机器学习系列3-逻辑回归</a></li>
<li><a href="https://chenrudan.github.io/blog/2016/01/09/logisticregression.html" target="_blank" rel="external">【机器学习算法系列之二】浅析Logistic Regression</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;写在前面：我将从一个入门者的视角（水平）将机器学习中的常用算法娓娓道来。自身水平确实有限，如果其中有什么错误的话希望大家指出，避免误导大家。然后这是这个系列的第二篇了，对于初学者来说，如果你没看过第一篇，推荐看看&lt;a href=&quot;http://fitzeng.org/2018/02/11/MLLinearRegression/&quot;&gt;机器学习基本算法之线性回归&lt;/a&gt;，里面提及到了很多基础的数学知识和一些的机器学习思维，对于理解这篇文章很有帮助，很多机器学习流程化的东西这里就不在具体介绍为什么这样做了，而是直接解释为什么在逻辑回归中需要使用这样的方式来实现，更加聚焦于逻辑回归实现本身，而非机器学习的流程理解。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mk43/machine-learning/tree/master/algorithm/logistic-regression&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验代码&lt;/a&gt;-&lt;a href=&quot;https://github.com/mk43/machine-learning/tree/master/reference&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考书籍&lt;/a&gt;-[参考博客详见最后]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Math" scheme="http://fitzeng.org/tags/Math/"/>
    
      <category term="MachineLearning" scheme="http://fitzeng.org/tags/MachineLearning/"/>
    
      <category term="Python" scheme="http://fitzeng.org/tags/Python/"/>
    
      <category term="NumPy" scheme="http://fitzeng.org/tags/NumPy/"/>
    
      <category term="Matplotlib" scheme="http://fitzeng.org/tags/Matplotlib/"/>
    
      <category term="LogisticRegression" scheme="http://fitzeng.org/tags/LogisticRegression/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 算法集锦（二）</title>
    <link href="http://fitzeng.org/2018/02/14/AlgoAndMath2/"/>
    <id>http://fitzeng.org/2018/02/14/AlgoAndMath2/</id>
    <published>2018-02-14T03:27:00.000Z</published>
    <updated>2018-02-15T03:02:44.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode-算法集锦（二）"><a href="#leetcode-算法集锦（二）" class="headerlink" title="leetcode 算法集锦（二）"></a><a href="https://www.nowcoder.com/ta/leetcode" target="_blank" rel="external">leetcode 算法集锦（二）</a></h2><blockquote>
<p>主要是牛客网上 leetcode 的算法题实践. 在 Blog 包含自己的解法和对别人优秀解法的分析.</p>
</blockquote>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">考点</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">C/C++</th>
<th style="text-align:center">Java     </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">  11</td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">word-break-ii</td>
<td style="text-align:center">NULL</td>
<td style="text-align:center"><a href="#jump_11">题解</a>  </td>
</tr>
<tr>
<td style="text-align:center">  12</td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">word-break</td>
<td style="text-align:center">NULL</td>
<td style="text-align:center"><a href="#jump_12">题解</a> </td>
</tr>
</tbody>
</table>
<h3 id="12-word-break"><a href="#12-word-break" class="headerlink" title="12 : word-break"></a><span id="jump_12"><a href="https://www.nowcoder.com/practice/5f3b7bf611764c8ba7868f3ed40d6b2c" target="_blank" rel="external">12 : word-break</a></span></h3><h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>参考上一题，不过不用记录结果，用个标记就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</div><div class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            String word = s.substring(i, s.length());</div><div class="line">            <span class="keyword">if</span> (dict.contains(word)) &#123;</div><div class="line">                flag = wordBreak(s.substring(<span class="number">0</span>, i), dict);</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">true</span> == flag || <span class="number">0</span> == i) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flag;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h4><p>用动态规划，dp[i]表示字符串s[0~i]是否可分的bool值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> len = s.length();</div><div class="line"><span class="function">vector&lt;bool&gt; <span class="title">dp</span><span class="params">(len+<span class="number">1</span>,<span class="keyword">false</span>)</span></span>;</div><div class="line">dp[<span class="number">0</span>]=<span class="keyword">true</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pos=<span class="number">0</span>;pos&lt;len;++pos)</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;dp[pos] &amp;&amp; i&lt;len;++i)</div><div class="line">        <span class="keyword">if</span> (dict.find(s.substr(pos,i-pos+<span class="number">1</span>))!=dict.end())</div><div class="line">            dp[i+<span class="number">1</span>]=<span class="keyword">true</span>;</div><div class="line"><span class="keyword">return</span> dp[len];</div></pre></td></tr></table></figure>
<h3 id="11-word-break-ii"><a href="#11-word-break-ii" class="headerlink" title="11 : word-break-ii"></a><span id="jump_11"><a href="https://www.nowcoder.com/practice/bd73f6b52fdc421d91b14f9c909f9104" target="_blank" rel="external">11 : word-break-ii</a></span></h3><h4 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h4><p>利用递归和动态规划的思想，每次截取最后面的一个然后把剩下的递归截取，接下来继续循环计算不截取该单词之后的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</div><div class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        ArrayList&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            String word = s.substring(i, s.length());</div><div class="line">            <span class="keyword">if</span> (dict.contains(word)) &#123;</div><div class="line">                temp = wordBreak(s.substring(<span class="number">0</span>, i), dict);</div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span> == temp.size() &amp;&amp; i == <span class="number">0</span>) &#123;</div><div class="line">                    result.add(word);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">for</span> (String str : temp) &#123;</div><div class="line">                        result.add(str + <span class="string">" "</span> + word);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="其他思路-1"><a href="#其他思路-1" class="headerlink" title="其他思路"></a>其他思路</h4><p>很基本的动态规划思路，值得学习。DP[i][j] 表示 S 从第 i 个字母到第 j 个字母的字符串，如果在字典中，就标记为 1，直到整个遍历完成。<br>然后从 i = 0 开始找寻为 1 的下标 j 代表截取前面一个字母成功，然后从 i = j + 1 开始找下一个等于 1 的 j 直到 j = S.length() 就说明截取成功。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line">思路CSDN Allan:</div><div class="line">=================================思路Allan========================================</div><div class="line">s ="catsand",</div><div class="line">dict =["cat", "cats", "and", "sand", "dog"].</div><div class="line"> </div><div class="line">动态规划根本思想是记录状态值:</div><div class="line">DP[i][j]:</div><div class="line">           j    0       1       2       3       4       5       6  </div><div class="line">        i </div><div class="line">        0       c       ca      cat(1)  cats(1) catsa   catsan  catsand</div><div class="line">        1               a       at      ats     atsa    atsan   atsand       </div><div class="line">        2                       t       ts      tsa     tsan    tsand</div><div class="line">        3                               s       sa      san     sand(1)</div><div class="line">        4                                       a       an      and(1)</div><div class="line">        5                                               n       nd</div><div class="line">        6                                                       d</div><div class="line"> </div><div class="line">DP[i][j]里:</div><div class="line">0       c       ca      cat(1)  cats(1) catsa   catsan  catsand</div><div class="line">1       a       at      ats     atsa    atsan   atsand</div><div class="line">2       t       ts      tsa     tsan    tsand</div><div class="line">3       s       sa      san     sand(1)</div><div class="line">4       a       an      and(1)</div><div class="line">5       n       nd</div><div class="line">6       d</div><div class="line">思路:</div><div class="line">DP[i][j]存放着字符串s的所有子字符串在dict中的状态值。</div><div class="line">遍历顺序是先搜索i到串尾的子串，若子串在dict里，再搜索串头到i的子串。</div><div class="line">        c a t s a n d</div><div class="line">        j     i</div><div class="line">比如，dp[3][3]=1表明"sand"在dict里，再搜索cat......</div><div class="line">再搜索顺序为cat at t......</div><div class="line"> </div><div class="line"> </div><div class="line">output(6,s):</div><div class="line">i=6     k:0 1 2 3 4 5 6</div><div class="line">dp[k][i-k]:偏移为k，截断字符串长度i-k+1</div><div class="line">沿着次对角线遍历,相当于从头部每隔一个字符截断!!!</div><div class="line">dp[0][6]:偏移为0，截断字符串长度7      0</div><div class="line">dp[1][5]:偏移为1，截断字符串长度6      0</div><div class="line">dp[2][4]:偏移为2，截断字符串长度5      0</div><div class="line">dp[3][3]:偏移为3，截断字符串长度4      1   --&gt;output(2,s)</div><div class="line">dp[4][2]:偏移为4，截断字符串长度3      1   --&gt;output(3,s)</div><div class="line">dp[5][1]:偏移为5，截断字符串长度2      0</div><div class="line">dp[6][0]:偏移为6，截断字符串长度1      0</div><div class="line"> </div><div class="line">output(2,s):</div><div class="line">i=2     k:0 1 2</div><div class="line">dp[k][i-k]:偏移为k，截断字符串长度i-k+1</div><div class="line">沿着次对角线遍历,相当于从头部每隔一个字符截断!!!</div><div class="line">dp[0][2]:偏移为0，截断字符串长度3      1   --&gt;output(-1,s)</div><div class="line">dp[1][1]:偏移为1，截断字符串长度2      0</div><div class="line">dp[2][0]:偏移为2，截断字符串长度1      0</div><div class="line"> </div><div class="line">output(-1,s):</div><div class="line">......</div><div class="line"> </div><div class="line"> </div><div class="line">mystring.push_back(s.substr(k,i-k+1));</div><div class="line">output(k-1,s);</div><div class="line">s.substr(k,i-k+1)==&gt;递归output(k-1,s)!!!</div><div class="line">偏移为k,截断长度i-(k-1);                           ------</div><div class="line">==&gt;递归为k-1                                              |---&gt;处理字符串长度i </div><div class="line">从偏移为0，截断长度k开始以次对角线方向遍历!!!       ------</div><div class="line">================================================================================</div><div class="line"> </div><div class="line">*/</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stack&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;unordered_set&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;numeric&gt;        //accmulate</div><div class="line">#include &lt;functional&gt;   //greater&lt;int&gt;()!!!</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123;</div><div class="line">        dp = new vector&lt;bool&gt;[s.size()];</div><div class="line"> </div><div class="line">        for (int i = 0; i &lt; s.size(); i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = i; j &lt; s.size(); j++)</div><div class="line">            &#123;</div><div class="line">                dp[i].push_back(match(s.substr(i, j - i + 1), dict));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        /*</div><div class="line">        for (int i = 0; i &lt; s.size(); i++)</div><div class="line">        &#123;</div><div class="line">            for (int j = 0; j &lt; dp[i].size(); j++)</div><div class="line">            &#123;</div><div class="line">                cout &lt;&lt; dp[i][j] &lt;&lt; " ";</div><div class="line">            &#125;</div><div class="line">            cout &lt;&lt; endl;</div><div class="line">        &#125;</div><div class="line">        */</div><div class="line">        output(s.size() - 1, s);</div><div class="line">         </div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    bool match(string s, unordered_set&lt;string&gt; &amp;dict)</div><div class="line">    &#123;</div><div class="line">        if (dict.find(s) != dict.end()) return true;</div><div class="line">        else return false;</div><div class="line">    &#125;</div><div class="line">    void output(int i, string s)</div><div class="line">    &#123;</div><div class="line">        if (i == -1)    //递归退出条件</div><div class="line">        &#123;</div><div class="line">            string str;</div><div class="line">            for (int j = mystring.size() - 1; j &gt;= 0; j--)</div><div class="line">            &#123;</div><div class="line">                str += mystring[j];</div><div class="line">                if (j != 0) str += " ";</div><div class="line">            &#125;</div><div class="line">            result.push_back(str);</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            for (int k = 0; k &lt;= i; k++) //error!!!  for (int k = 0; k &lt; i; k++)</div><div class="line">            &#123;</div><div class="line">                if (dp[k][i - k])       //dp[k][i-k]:偏移为k，截断长度i-k+1</div><div class="line">                &#123;</div><div class="line">                    mystring.push_back(s.substr(k, i - k + 1));</div><div class="line">                    output(k - 1, s);   //递归:dp[0][i]:偏移为0，截断长度i+1      i=k-1,则截断长度为k,与递归前偏移k互补</div><div class="line">                    mystring.pop_back();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;string&gt; result;</div><div class="line">    vector&lt;string&gt; mystring;</div><div class="line">    vector&lt;bool&gt; *dp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;leetcode-算法集锦（二）&quot;&gt;&lt;a href=&quot;#leetcode-算法集锦（二）&quot; class=&quot;headerlink&quot; title=&quot;leetcode 算法集锦（二）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/ta/leetcode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;leetcode 算法集锦（二）&lt;/a&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;主要是牛客网上 leetcode 的算法题实践. 在 Blog 包含自己的解法和对别人优秀解法的分析.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Algo" scheme="http://fitzeng.org/tags/Algo/"/>
    
      <category term="Math" scheme="http://fitzeng.org/tags/Math/"/>
    
      <category term="Java" scheme="http://fitzeng.org/tags/Java/"/>
    
      <category term="C/C++" scheme="http://fitzeng.org/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基本算法之线性回归</title>
    <link href="http://fitzeng.org/2018/02/11/MLLinearRegression/"/>
    <id>http://fitzeng.org/2018/02/11/MLLinearRegression/</id>
    <published>2018-02-11T03:27:00.000Z</published>
    <updated>2018-02-12T08:50:48.613Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<blockquote>
<p>写在前面：我将从一个入门者的视角（水平）将机器学习中的常用算法娓娓道来。自身水平确实有限，如果其中有什么错误的话希望大家指出，避免误导大家。对于开篇有比较多的东西想说，所以另取一章介绍一下我个人对机器学习这个领域的理解和一些基本常识介绍。如果你时间比较充裕，可以看看我<code>前言</code>的文字介绍。</p>
</blockquote>
<a id="more"></a>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>介绍一下个人想法</p>
<h3 id="0-1-关于机器学习"><a href="#0-1-关于机器学习" class="headerlink" title="0.1 关于机器学习"></a>0.1 关于机器学习</h3><p>毫无疑问，机器学习现在越来越热门了，需求随着以后人工智能大爆发会持续增长。不管你是不是这个编程领域的人，都有必要了解一下机器学习是怎么回事，至少有个理性的认识，而不是觉得很神秘。但是涉及到算法数学知识是可以忽略的，只要知道，我们通过某个数学手段可以达到某个目的。比如这里要介绍的线性回归在更新权重时是依据梯度下降算法的，你可以不必知道什么是梯度下降，知道知道数学上对于求解最优化是有自己的手段的，当然如果能知道更好。由于机器学习的性质，速成基本不太可能，而且现在处于高速发展的阶段，必须保持学习的热情才能学得下去。另外，这个前期的学习成本是比较高的，在自己写代码之前，要想心里有点底，至少要对 <code>微积分</code>、<code>线性代数</code> 和 <code>概率论</code> 的应用要有点自己的理解的。所以这也是一大优势，不太容易被取代。</p>
<h3 id="0-2-关于线性回归"><a href="#0-2-关于线性回归" class="headerlink" title="0.2 关于线性回归"></a>0.2 关于线性回归</h3><p>对于理性了解机器学习的捷径就是弄懂线性回归算法的整个流程，如果你通过这篇文章真的理解了线性回归，那么你应该就理解这句话了。当然，对于大多数阅读者篇文章的人来说，可能早就对线性回归有了自己的理解。但是我这要提的是，如果你没打算入门机器学习，阅读一下线性回归也是对自己知识面进行拓展的一个好方式，因为基本大多数人都是从这里开始的。</p>
<h3 id="0-3-关于基础"><a href="#0-3-关于基础" class="headerlink" title="0.3 关于基础"></a>0.3 关于基础</h3><p>首先，你需要一点 \( Python \) 基础。如果没有也简单，自学一下就行。然后就是要学习一下以下工具的使用：<code>NumPy</code>，<code>Matplotlib</code>，<code>sklearn</code>，<code>TensorFlow</code>。其中部分可以参考我以前的文章。</p>
<ul>
<li><a href="http://fitzeng.org/2018/02/03/TensorFlowIntroduction/">从 TensorFlow 入门机器学习</a></li>
<li><a href="http://fitzeng.org/2018/02/04/NumPyOfficialQuickstartTutorial/">NumPy 官方快速入门教程(译)</a></li>
<li><a href="http://fitzeng.org/2018/02/07/MatplotlibDraw/">Matplotlib 基本操作</a></li>
<li><a href="http://fitzeng.org/2018/02/08/MatplotlibGenerateGif/">Matplotlib 保存 GIF 动图</a></li>
</ul>
<p>有了这些你还需要一些数学基础。数学的话我觉得不要求全学会，也不太现实，可以在写代码过程中碰到什么算法再去寻求数学证明，前提是之前的知识量最好能达到看懂大多数数学知识的水平。这里我觉得知乎上有些数学科普其实挺不错的，毕竟不是数学系，所以理解主要逻辑之后持有一种拿来用的态度我觉得没问题。</p>
<ul>
<li><a href="http://fitzeng.org/2018/01/26/reProbabilityTheory/">机器学习之重拾概率论</a></li>
</ul>
<h3 id="0-4-关于参考"><a href="#0-4-关于参考" class="headerlink" title="0.4 关于参考"></a>0.4 关于参考</h3><p>这里很感谢像吴恩达、莫烦等老师的无私奉献，还有很多在网上写博客分享知识的人，让编程这个行业形成一个良好的学习风气。而且网上还流传很多优质的学习资源，所以这里我将我学习过程的参考资料整理进了 <a href="https://github.com/mk43" target="_blank" rel="external">GitHub</a>，我想大家奉献出来就是为了别人更好的学习吧，如果有侵权之类的话，我会立即删除的。然后这一系列的文章，我会主要以吴恩达老师的课程为基础，以初学者的视角记录并且实践。</p>
<ul>
<li><a href="https://github.com/mk43/machine-learning/tree/master/reference" target="_blank" rel="external">学习参考书籍</a></li>
</ul>
<h3 id="0-5-关于我"><a href="#0-5-关于我" class="headerlink" title="0.5 关于我"></a>0.5 关于我</h3><p>一个即将毕业的知识水平有限的本科生，所以文章肯定有很多不足之处，望大家指正。然后实验的代码在<a href="https://github.com/mk43/machine-learning/tree/master/algorithm/linear-regression" target="_blank" rel="external">这里</a>。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>故事就不讲了，可以参考视视频。下面我讲讲这个是要解决什么问题？生活中往往有很多现象，而我们可以从现象总结出某些结论，但是，如果我们看到了一个之前从来都没有看到过的现象，我们就无法下结论了。但但是一些有经验的人可以凭借丰富的经验进行预测。就比如，一个处于懵懂期的小孩子，看见一片乌云不能推测出会下雨，而一个大人就会知道，提醒小孩出门要带伞。。。好吧，还是在讲故事，那就继续吧😂😂😂。这个例子中的大人小孩的区别在于年龄不同，见识不同，知识水平自然不同，能做出的判断也自然不同。所以要想达到对现象进行预测，那么就必须进行学习，等小孩慢慢长大了，看到蚂蚁搬家就会带伞出门了。</p>
<p>好了，我们总结一下上面的故事：现象可以比喻成数据，结论造成的行为也是数据，唯一不同的是，是有现象得出的结论，所以可以将现象的数据看作是输入，结论的数据看成是输出。那么机器学习就是将输入数据输入进一个模型，然后将模型的输出结果和之前的“正确”结论作比对慢慢更改模型，直到这个模型对出入数据有较好的预测，那么这个模型就可以拿来用了。抽象出来的话就是找一个输入\( X \) 和输出 \( Y \)之间的映射\( f \)，使得对于绝大多数 \( X \) 都能通过映射 \( f(X) \rightarrow Y \) 较好地得到 \( Y \)。</p>
<p>房价的例子我就不举了，直接看下面的图，看看能不能解决 \( X = 4,\ Y = ? \) </p>
<p><img src="/2018/02/11/MLLinearRegression/scattergraph.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># coding: utf-8</div><div class="line"></div><div class="line">import numpy as np</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line">def draw():</div><div class="line">    X = np.linspace(0, 10, 50)</div><div class="line">    noise = np.random.normal(0, 0.5, X.shape)</div><div class="line">    Y = X * 0.5 + 3 + noise</div><div class="line"></div><div class="line">    plt.scatter(X, Y)</div><div class="line">    plt.savefig(&quot;scattergraph.png&quot;)</div><div class="line">    plt.show()</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    draw()</div></pre></td></tr></table></figure>
<p>好了，你可能会发现，要想给出 \( Y \) 依赖的是直觉，所以每一个人的答案都是不一样的，而对于某些标准统一的领域（比如军事项目），这种依靠直觉判断的情况绝对不容许发生。想象在现代信息化战场上靠直觉怎么可能作战成功？</p>
<p>所以我们需要一个模型，你可以理解成一个黑盒，把 \( X \) 喂进去，把 \( Y \) 取出来，而且无论谁，只要那个黑盒是同一个，那么每个人的输入 \( X \) 相同的话，输出 \( Y \) 就是相同的。 那么在这里这个模型大概是什么形状的呢？目前这个还是我们人为干预进行选择的。直观来说，可以这个分布看成一条很粗的线，那么我们选择线性模型来模拟分布。那么如何确定这个线性模型呢？这里就涉及到今天的主角：<a href="https://en.wikipedia.org/w/index.php?title=Linear_regression" target="_blank" rel="external">线性回归</a></p>
<h2 id="2-一元线性回归"><a href="#2-一元线性回归" class="headerlink" title="2 一元线性回归"></a>2 一元线性回归</h2><p>先从一元线性函数开始分析，既然假设是一元线性，那么我们的拟合函数就可以定义为 \( Y = X*W + b \) 了。同样那前一个图作为例子，我们现在的目的是求出\( W, b \)，如果求出来了，给定任意一个 \( X \) 就能求出 \( Y \) 来了。</p>
<h3 id="2-1-定义评估函数-损失函数"><a href="#2-1-定义评估函数-损失函数" class="headerlink" title="2.1 定义评估函数-损失函数"></a>2.1 定义评估函数-损失函数</h3><p>这里讲解如何求出 \( W, b \) 的整个思考过程。</p>
<p>我们选取一个点 \( (x_0, y_0) \) 因为误差的存在，所以 \( y_0 = x_0 <em> W + b + \delta_0 \)。同理如果有很多点，那么就有以下结果，为了方便，我们取评估值 \( h(x) = x </em> W + b \)。</p>
<p>$$<br>\delta_0 = y_0 - h(x_0) \\<br>\delta_1 = y_1 - h(x_1) \\<br>\ldots \\<br>\delta_n = y_n - h(x_n) \\\<br>$$</p>
<p>我们的目的自然是误差越小越好，所以采用平方和的形式表达误差：</p>
<p>$$<br>loss(W, b) = \sum_{i = 0}^{n}\delta_i^2 = \sum_{i = 0}^{n} [y_i - h(x_i)]^2<br>$$</p>
<p>到这里，我们来看看图像是怎么样的？</p>
<p><img src="/2018/02/11/MLLinearRegression/lossgraph.png" alt=""></p>
<p>PS：图有点丑，实在是没办法了，设置了噪点，使得函数值跨度很大，稍微改一下就会呼脸。只能设置散点图凑合看了，望知道的小伙伴告知。好了，就不在这浪费过多时间了，直接看代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">ax = Axes3D(fig)</div><div class="line">ax.set_xlabel(<span class="string">r'$Weight$'</span>)</div><div class="line">ax.set_ylabel(<span class="string">r'$bias$'</span>)</div><div class="line">ax.set_zlabel(<span class="string">r'$loss\ value$'</span>)</div><div class="line">N = <span class="number">200</span></div><div class="line"></div><div class="line">X = np.linspace(<span class="number">0</span>, <span class="number">10</span>, N)</div><div class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>, X.shape)</div><div class="line">Y = X * <span class="number">0.5</span> + <span class="number">3</span> + noise</div><div class="line"></div><div class="line">W = np.linspace(<span class="number">-10</span>, <span class="number">10</span>, N)</div><div class="line">b = np.linspace(<span class="number">-2</span>, <span class="number">8</span>, N)</div><div class="line"></div><div class="line">p = <span class="number">0.6</span></div><div class="line">plt.xlim(W.min() * p, W.max() * p)</div><div class="line">plt.ylim(b.min() * p, b.max() * p)</div><div class="line">ax.set_zlim(<span class="number">0</span>, <span class="number">1000</span>)</div><div class="line"></div><div class="line">h = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> W:</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> b:</div><div class="line">        h.append(np.sum(np.square(Y - (X * i + j))))</div><div class="line"></div><div class="line">print(np.min(h))</div><div class="line">h = np.asarray(h).reshape(N, N)</div><div class="line">W, b = np.meshgrid(W, b)</div><div class="line"></div><div class="line">ax.scatter(W, b, h, c=<span class="string">'b'</span>)</div><div class="line">plt.savefig(<span class="string">"lossgraph.png"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>现在我们通过可视化的手段知道了大概什么位置取最小值，其实我们还是没有达到目的，我们要的是 \( W, b \) 具体值。</p>
<h3 id="2-2-求解最小值-梯度下降"><a href="#2-2-求解最小值-梯度下降" class="headerlink" title="2.2 求解最小值-梯度下降"></a>2.2 求解最小值-梯度下降</h3><p>问题被进一步细化，就是求解下面二元函数在什么时候取极值：</p>
<p>$$<br>loss(W, b) = \sum_{i = 0}^{n}\delta_i^2 = \sum_{i = 0}^{n} [y_i - h(x_i)]^2<br>$$</p>
<p>这时候高数就登场了，找了一张图</p>
<p><img src="/2018/02/11/MLLinearRegression/findextremum.png" alt=""></p>
<p>那问题就很简单了，就是直接求对 \( W, b \) 的偏导等于 \( 0 \) 的方程组。但是这是数学方法，不符合计算机思维，就好像我们解一个一元一次方程，普通方法是直接拿定义域内的值一个一个试，直到结果符合预期。当然，高级一点点的方法是可以写一个解释器，把人类计算方法程序化。显然这里不太现实，而且方程类型一变，解释器很可能就不适用了。所以我们还是采用那种机器认可的“笨”办法，想起开学时计算机导论老师评价计算机的一句话：<code>fast but stupid</code>。说明在这种情况下，我们可以接受用快来弥补其它劣势，只要计算的值一步一步靠近最终结果就能满足需求。其实说到这里，计算机变快的这些特点和现在机器学习、人工智能领域的兴起有一定关系。</p>
<p>好了，下面开始想一个办法如何让结果慢慢趋近与极值。</p>
<p>我们可以这样想，随机放一个球在这个平面上，等到球禁止时，它所在的位置就是极值的位置。那我们如何模仿这一过程呢？</p>
<blockquote>
<p>第一步：放球</p>
</blockquote>
<p>这个好做，就是直接随机一个在定义域内的任意位置就好了。</p>
<blockquote>
<p>第二步：滚动</p>
</blockquote>
<p>滚动的话如何去模拟是一个比较难的点，但是仔细分析就很好理解了。你可以把自己想象成那个球，开始站在某个地方，这个地方很不稳，那么你自然反应肯定是往平整的地方去，前提是每个位置的海拔差不多。那这样就说明那些斜率越大的地方有更大的几率更快跌落谷底。这个例子有个不恰当的地方，可以思考下二次函数，这里主要是体会这种思维，而我们是可以变通的。当你有了这种斜率的思维，那就好办了，下面给出总结：<code>我们总是希望在给定步长的情况下，往水平最低的地方行进</code>。而其中要知道那个是最低，又是一个难题，计算机可没有直觉，如果数值设置不当，可能导致函数收敛过慢或者直接发散，而这些都是机器学习应该极力避免的。</p>
<p>为了好分析问题，我们采用控制变量方法。可以看到，在损失函数中有两个变量 \( W, b \)，当 \( W \) 取某一值得时候，\( loss(n, b) \ n\ is\ a\ constant \)是一个二次函数。</p>
<p><img src="/2018/02/11/MLLinearRegression/quadraticFunction.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line"></div><div class="line">N = <span class="number">200</span></div><div class="line"></div><div class="line">X = np.linspace(<span class="number">0</span>, <span class="number">10</span>, N * <span class="number">2</span>)</div><div class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>, X.shape)</div><div class="line">Y = X * <span class="number">0.5</span> + <span class="number">3</span> + noise</div><div class="line"></div><div class="line">W = <span class="number">1</span></div><div class="line">b = np.linspace(<span class="number">-5</span>, <span class="number">6</span>, N)</div><div class="line"></div><div class="line">h = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</div><div class="line">    h.append(np.sum(np.square(Y - (X * W + i))))</div><div class="line"></div><div class="line">plt.plot(b, h)</div><div class="line"></div><div class="line">plt.savefig(<span class="string">"quadraticFunction.png"</span>)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>我们来直接看吴恩达老师的课件吧，有点不想做图了。。。</p>
<p><img src="/2018/02/11/MLLinearRegression/wuenda_1.png" alt=""></p>
<p>现在我们可以引出更新规则了，在这里求解最小值，对于一元函数来说就是求导，对于多元函数就是求偏导了。很明显，当斜率为正的时候，我们要往负反向走，反之往正方向走。所以我们可以加上一个关于斜率呈反比的函数来跟新值，至于更新力度也就是前面说的一次走多远就是学习率的设定了。而且离极值点越远，斜率绝对值越大，步子迈得越大，符合更新逻辑。</p>
<p>$$<br>\begin{aligned}<br>&amp;W:=W-\frac{\alpha}{2n}\frac{\partial\,loss(W)}{\partial\,W} = W + \frac{ \alpha}{n}\sum_{i = 1}^{n}{x_i*(y_i-h(x_i))}\\<br>&amp;b:=b-\frac{\alpha}{2n}\frac{\partial\,loss(b)}{\partial\,b} = b + \frac{ \alpha}{n}\sum_{i = 0}^{n}{y_i-h(x_i)}<br>\end{aligned}<br>$$</p>
<p>这里可能有点思维跳跃的是除了一个 \( 2n \)，可以从数据量的角度思考，也可以从更新斜率的角度思考，因为在更新权重中，我们不仅仅只是计算一个点的斜率，如果直接求和必定会导致权重过大从而最终结果是发散的，这点大家可以自己改改代码试试。好了，既然基本思路都出来了，那就写代码实现吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">N = <span class="number">200</span></div><div class="line"></div><div class="line">X = np.linspace(<span class="number">0</span>, <span class="number">10</span>, N * <span class="number">2</span>)</div><div class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.5</span>, X.shape)</div><div class="line">Y = X * <span class="number">0.5</span> + <span class="number">3</span> + noise</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcLoss</span><span class="params">(train_X, train_Y, W, b)</span>:</span></div><div class="line">    <span class="keyword">return</span> np.sum(np.square(train_Y - (train_X * W + b)))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradientDescent</span><span class="params">(train_X, train_Y, W, b, learningrate=<span class="number">0.001</span>, trainingtimes=<span class="number">500</span>)</span>:</span></div><div class="line">    <span class="keyword">global</span> loss</div><div class="line">    <span class="keyword">global</span> W_trace</div><div class="line">    <span class="keyword">global</span> b_trace</div><div class="line">    size = train_Y.size</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(trainingtimes):</div><div class="line">        prediction = W * train_X + b</div><div class="line">        tempW = W + learningrate * np.sum(train_X * (train_Y - prediction)) / size</div><div class="line">        tempb = b + learningrate * np.sum(train_Y - prediction) / size</div><div class="line">        W = tempW</div><div class="line">        b = tempb</div><div class="line">        loss.append(calcLoss(train_X, train_Y, W, b))</div><div class="line">        W_trace.append(W)</div><div class="line">        b_trace.append(b)</div><div class="line"></div><div class="line"></div><div class="line">Training_Times = <span class="number">100</span></div><div class="line">Learning_Rate = <span class="number">0.002</span></div><div class="line"></div><div class="line">loss = []</div><div class="line">W_trace = [<span class="number">-1</span>]</div><div class="line">b_trace = [<span class="number">1</span>]</div><div class="line">gradientDescent(X, Y, W_trace[<span class="number">0</span>], b_trace[<span class="number">0</span>], learningrate=Learning_Rate, trainingtimes=Training_Times)</div><div class="line">print(W_trace[<span class="number">-1</span>], b_trace[<span class="number">-1</span>])</div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">plt.title(<span class="string">r'$loss\ function\ change\ tendency$'</span>)</div><div class="line">plt.xlabel(<span class="string">r'$learning\ times$'</span>)</div><div class="line">plt.ylabel(<span class="string">r'$loss\ value$'</span>)</div><div class="line">plt.plot(np.linspace(<span class="number">1</span>, Training_Times, Training_Times), loss)</div><div class="line">plt.savefig(<span class="string">"gradientDescentLR.png"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/11/MLLinearRegression/gradientDescentLR.png" alt=""></p>
<p>到这里，我们基本手写实现了一元变量的线性回归，这里为了方便训练次数取得比较少，只有 \( 100 \) 次，这远远不够，我测试了一下，大概达到 \( 10000 \) 次训练效果就比较好了。当然也可以调整学习率，初始值……读者可以自行尝试。</p>
<h2 id="3-多元线性回归"><a href="#3-多元线性回归" class="headerlink" title="3 多元线性回归"></a>3 多元线性回归</h2><p>这里我们先拆分理解多元代表多个自变量，线性代表自变量之间满足齐次性和可加性，回归就是一种方法的表述。一元好办，我们可以通过各种工具实现可视化，但是多元的表述就有了一些困难，特别是在高维线性空间我们想象不出来。所以我们就必须抽象出来，使用数学符号代替那些复杂的变量。</p>
<p>可能你已经想到了，对，没错，我们要使用线性代数了。如果之前没有一点基础的话，可以稍微花点时间在知乎上了解下线性代数是做什么的就好了，这里只涉及线性代数的基础认识应用。</p>
<p>假如当我们有三个自变量 \( X_1, X_2, X_3 \) 和一个因变量 \( Y \)，且符合线性关系。那么就会有以下方程成立：</p>
<p>$$<br>w_1X_1 + w_2X_2 + w_3X_3 + b = Y<br>$$</p>
<p>再假设我们有四组数据\((x_1, x_2, x_3, y): \{(1,1,1,1), (1,1,2,3), (1,3,4,1), (3,2,4,2) \} \)，那么有：</p>
<p>$$<br>1w_1 + 1w_2 + 1w_3 + b = 1 \\<br>1w_1 + 1w_2 + 2w_3 + b = 3 \\<br>1w_1 + 3w_2 + 4w_3 + b = 1 \\<br>3w_1 + 2w_2 + 4w_3 + b = 2<br>$$</p>
<p>于是我们可以抽象以下，写成矩阵的形式：</p>
<p>$$<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 \\<br>1 &amp; 1 &amp; 2 &amp; 1 \\<br>1 &amp; 3 &amp; 4 &amp; 1 \\<br>3 &amp; 2 &amp; 4 &amp; 1<br>\end{bmatrix} * \begin{bmatrix}<br>w_1 \\<br>w_2 \\<br>w_3 \\ b \end{bmatrix} = \begin{bmatrix}<br>1 \\<br>3 \\<br>1 \\<br>2<br>\end{bmatrix}<br>$$</p>
<p>再抽象：</p>
<p>$$<br>XW = Y<br>$$</p>
<p>其中</p>
<p>$$<br>X =<br>\begin{bmatrix}<br>X_1 &amp; X_2 &amp; X_3 &amp; 1<br>\end{bmatrix}<br>and\ X_i =<br>\begin{bmatrix}<br>x_{1i} \\<br>x_{2i} \\<br>\ldots \\<br>x_{ni}<br>\end{bmatrix} \\<br>W =<br>\begin{bmatrix}<br>w_1 \\<br>w_2 \\<br>w_3 \\<br>b<br>\end{bmatrix}<br>$$</p>
<p>我们的目的是求解 \( W \)，也就是把方程 \(XW = Y \) 中的 \( W \) 解出来。直接解个方程就能得到我们想要的效果，太好了，马上开始：</p>
<p>$$<br>\begin{aligned}<br>&amp;XW = Y \\<br>\Longrightarrow &amp;X^TXW = X^TY \\<br>\Longrightarrow &amp;(X^TX)^{-1}X^TXW = (X^TX)^{-1}X^TY \\<br>\Longrightarrow &amp;W = (X^TX)^{-1}X^TY<br>\end{aligned}<br>$$</p>
<p>如果这里不理解的话，我简单说一下，求逆运算必须是形如 \( \mathbb{R}^{n*n} \) 的形式，也就是行和列要相等。为什么这样呢？我的理解是矩阵是对一个线性空间到另一个线性空间的映射，所以如果一个矩阵的秩小于行数，也就是里面有线性相关的向量，在对线性空间进行变换时，可能进行降维影响，也就是造成某个维度塌缩，这种影响是不可逆的，所以这种矩阵是没有逆矩阵进行恢复的。如果要从一个向量映射到另一个向量，还有从另一个向量映射回来的话，这个矩阵必须有逆矩阵也就是满秩的。还有个东西叫奇异矩阵，感兴趣的可以了解一下。</p>
<p>回到主线，直接求解方程吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">X1 = np.asarray([<span class="number">2104</span>, <span class="number">1416</span>, <span class="number">1534</span>, <span class="number">852</span>]).reshape(<span class="number">4</span>, <span class="number">1</span>)</div><div class="line">X2 = np.asarray([<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>]).reshape(<span class="number">4</span>, <span class="number">1</span>)</div><div class="line">X3 = np.asarray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]).reshape(<span class="number">4</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">X = np.mat(np.column_stack((X1, X2, X3, np.ones(shape=(<span class="number">4</span>, <span class="number">1</span>)))))</div><div class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>, X1.shape)</div><div class="line">Y = np.mat(<span class="number">2.5</span> * X1 - X2 + <span class="number">2</span> * X3 + <span class="number">4</span> + noise)</div><div class="line">YTwin = np.mat(<span class="number">2.5</span> * X1 - X2 + <span class="number">2</span> * X3 + <span class="number">4</span>)</div><div class="line"></div><div class="line">W = (X.T * X).I * X.T * Y</div><div class="line">WTWin = (X.T * X).I * X.T * YTwin</div><div class="line">print(W, <span class="string">"\n"</span>, WTWin)</div><div class="line"></div><div class="line"><span class="comment"># output:</span></div><div class="line"><span class="comment"># [[ 2.50043958]</span></div><div class="line"><span class="comment">#  [-1.16868808]</span></div><div class="line"><span class="comment">#  [ 1.79213736]</span></div><div class="line"><span class="comment">#  [ 4.27637958]] </span></div><div class="line"><span class="comment">#  [[ 2.5]</span></div><div class="line"><span class="comment">#  [-1. ]</span></div><div class="line"><span class="comment">#  [ 2. ]</span></div><div class="line"><span class="comment">#  [ 4. ]]</span></div></pre></td></tr></table></figure>
<p><img src="/2018/02/11/MLLinearRegression/wuenda_2.png" alt=""></p>
<p>这里我们采用吴恩达老师的房子数据，自己生成的数据之间有太大的相似性，算出的结果误差太大。</p>
<p>我们基本可以计算多元线性回归，但是一点也体现不出机器学习中学习这个词，当然我们可以自己利用前面给出的例子利用 \( loss \) 函数求解。这里我们借助 \( TensorFlow \) 帮我们完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">N = <span class="number">1000</span></div><div class="line">train_X1 = np.linspace(<span class="number">1</span>, <span class="number">10</span>, N).reshape(N, <span class="number">1</span>)</div><div class="line">train_X2 = np.linspace(<span class="number">1</span>, <span class="number">10</span>, N).reshape(N, <span class="number">1</span>)</div><div class="line">train_X3 = np.linspace(<span class="number">1</span>, <span class="number">10</span>, N).reshape(N, <span class="number">1</span>)</div><div class="line">train_X4 = np.linspace(<span class="number">1</span>, <span class="number">10</span>, N).reshape(N, <span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment"># train_X = np.column_stack((train_X1, np.ones(shape=(N, 1))))</span></div><div class="line">train_X = np.column_stack((train_X1, train_X2, train_X3, train_X4, np.ones(shape=(N, <span class="number">1</span>))))</div><div class="line"></div><div class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.5</span>, train_X1.shape)</div><div class="line"><span class="comment"># train_Y = 3 * train_X1 + 4</span></div><div class="line">train_Y = train_X1 + train_X2 + train_X3 + train_X4 + <span class="number">4</span> + noise</div><div class="line"></div><div class="line">length = len(train_X[<span class="number">0</span>])</div><div class="line"></div><div class="line">X = tf.placeholder(tf.float32, [<span class="keyword">None</span>, length], name=<span class="string">"X"</span>)</div><div class="line">Y = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">1</span>], name=<span class="string">"Y"</span>)</div><div class="line"></div><div class="line">W = tf.Variable(np.random.random(size=length).reshape(length, <span class="number">1</span>), dtype=tf.float32, name=<span class="string">"weight"</span>)</div><div class="line"></div><div class="line">activation = tf.matmul(X, W)</div><div class="line">learning_rate = <span class="number">0.006</span></div><div class="line"></div><div class="line">loss = tf.reduce_mean(tf.reduce_sum(tf.pow(activation - Y, <span class="number">2</span>), reduction_indices=[<span class="number">1</span>]))</div><div class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss)</div><div class="line"></div><div class="line">training_epochs = <span class="number">2000</span></div><div class="line">display_step = <span class="number">100</span></div><div class="line"></div><div class="line">loss_trace = []</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(training_epochs):</div><div class="line">        sess.run(optimizer, feed_dict=&#123;X: train_X, Y: train_Y&#125;)</div><div class="line">        temp_loss = sess.run(loss, feed_dict=&#123;X: train_X, Y: train_Y&#125;)</div><div class="line">        loss_trace.append(temp_loss)</div><div class="line">        <span class="keyword">if</span> <span class="number">1</span> == epoch % display_step:</div><div class="line">            print(<span class="string">'epoch: %4s'</span>%epoch, <span class="string">'\tloss: %s'</span>%temp_loss)</div><div class="line">    print(<span class="string">"\nOptimization Finished!"</span>)</div><div class="line">    print(<span class="string">"\nloss = "</span>, loss_trace[<span class="number">-1</span>], <span class="string">"\nWeight =\n"</span>, sess.run(W, feed_dict=&#123;X: train_X, Y: train_Y&#125;))</div><div class="line"></div><div class="line"></div><div class="line">plt.plot(np.linspace(<span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), loss_trace[:<span class="number">100</span>])</div><div class="line">plt.savefig(<span class="string">"tensorflowLR.png"</span>)</div><div class="line">plt.show()</div><div class="line"></div><div class="line"><span class="comment"># output:</span></div><div class="line"><span class="comment"># epoch:    1 	loss: 118.413925</span></div><div class="line"><span class="comment"># epoch:  101 	loss: 1.4500043</span></div><div class="line"><span class="comment"># epoch:  201 	loss: 1.0270562</span></div><div class="line"><span class="comment"># epoch:  301 	loss: 0.75373846</span></div><div class="line"><span class="comment"># epoch:  401 	loss: 0.5771168</span></div><div class="line"><span class="comment"># epoch:  501 	loss: 0.46298113</span></div><div class="line"><span class="comment"># epoch:  601 	loss: 0.38922414</span></div><div class="line"><span class="comment"># epoch:  701 	loss: 0.34156123</span></div><div class="line"><span class="comment"># epoch:  801 	loss: 0.31076077</span></div><div class="line"><span class="comment"># epoch:  901 	loss: 0.29085675</span></div><div class="line"><span class="comment"># epoch: 1001 	loss: 0.27799463</span></div><div class="line"><span class="comment"># epoch: 1101 	loss: 0.26968285</span></div><div class="line"><span class="comment"># epoch: 1201 	loss: 0.2643118</span></div><div class="line"><span class="comment"># epoch: 1301 	loss: 0.26084095</span></div><div class="line"><span class="comment"># epoch: 1401 	loss: 0.2585978</span></div><div class="line"><span class="comment"># epoch: 1501 	loss: 0.25714833</span></div><div class="line"><span class="comment"># epoch: 1601 	loss: 0.25621164</span></div><div class="line"><span class="comment"># epoch: 1701 	loss: 0.2556064</span></div><div class="line"><span class="comment"># epoch: 1801 	loss: 0.2552152</span></div><div class="line"><span class="comment"># epoch: 1901 	loss: 0.2549625</span></div><div class="line"><span class="comment"># Optimization Finished!</span></div><div class="line"><span class="comment"># loss =  0.25480175 </span></div><div class="line"><span class="comment"># Weight =</span></div><div class="line"><span class="comment">#  [[1.0982682 ]</span></div><div class="line"><span class="comment">#  [0.9760315 ]</span></div><div class="line"><span class="comment">#  [1.0619627 ]</span></div><div class="line"><span class="comment">#  [0.87049955]</span></div><div class="line"><span class="comment">#  [3.9700394 ]]</span></div></pre></td></tr></table></figure>
<p>这里的拟合效果不太好，不知道是不是数据的问题，因为数据增长的相似性太高，感觉可能过拟合了，如果有知道的小伙伴欢迎告知。下图可以看到 \( loss \) 早早就收敛了。</p>
<p><img src="/2018/02/11/MLLinearRegression/tensorflowLR.png" alt=""></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>线性回归的求解过程很直观，符合我们的理解。对于这个问题有一个先入为主的观点就是数据一定是拟合成线性的，因为这里讲的是线性回归。当然，数据分布不是线性的这个方法就不适用了，同样，如果我们看不到数据的分布，不能对模型进行预估，那只能一步一步去试探，所以机器学习开始就是选取适用于当前数据的模型，可以理解为找一个输入输出的合理映射关系，然后导入数据，构造一个能够正确评估拟合效果的损失函数，接着就是对损失函数进行最优化，这里有一个问题前面没有提及的是如果只是随机地找，其实我们不能保证找到的就是全局最优，当然一般情况下，局部最优得到的模型已经能很好的预测输出了。这只是我的个人理解啦，欢迎大家一起讨论，然后实验的代码在我的 <a href="https://github.com/mk43/machine-learning" target="_blank" rel="external">GitHub</a> 上，需要的可以自取。然后这个系列可能会继续更新，不过离下一次更新可能要点时间，因为新年快乐^_^，对了参考资料前面又给出，就不一一列举感谢了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;写在前面：我将从一个入门者的视角（水平）将机器学习中的常用算法娓娓道来。自身水平确实有限，如果其中有什么错误的话希望大家指出，避免误导大家。对于开篇有比较多的东西想说，所以另取一章介绍一下我个人对机器学习这个领域的理解和一些基本常识介绍。如果你时间比较充裕，可以看看我&lt;code&gt;前言&lt;/code&gt;的文字介绍。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Math" scheme="http://fitzeng.org/tags/Math/"/>
    
      <category term="MachineLearning" scheme="http://fitzeng.org/tags/MachineLearning/"/>
    
      <category term="Python" scheme="http://fitzeng.org/tags/Python/"/>
    
      <category term="NumPy" scheme="http://fitzeng.org/tags/NumPy/"/>
    
      <category term="Matplotlib" scheme="http://fitzeng.org/tags/Matplotlib/"/>
    
      <category term="LinearRegression" scheme="http://fitzeng.org/tags/LinearRegression/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib 保存 GIF 动图</title>
    <link href="http://fitzeng.org/2018/02/08/MatplotlibGenerateGif/"/>
    <id>http://fitzeng.org/2018/02/08/MatplotlibGenerateGif/</id>
    <published>2018-02-08T03:27:00.000Z</published>
    <updated>2018-02-08T12:55:13.776Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<blockquote>
<p>写在前面：为了可视化机器学习过程，并且保存下来，所以想直接利用 \( Matplotlib.animation \) 保存动图，期间参考了好多资料，过程比较艰辛，所以想记录下来。当然，此文还参考了好多网上的其它文章，再此一并感谢那些热爱分享的 \( coder \)，并且参考资料中给出链接。所有代码整理到<a href="https://github.com/mk43/python-practice/tree/master/matplotlib" target="_blank" rel="external">GitHub</a>。</p>
</blockquote>
<a id="more"></a>
<h2 id="0-前期准备"><a href="#0-前期准备" class="headerlink" title="0. 前期准备"></a>0. 前期准备</h2><p>安装 \( NumPy \) 和 \( Matplotlib \)。具体安装直接上官网便可，遇到什么问题在网上基本可以搜到答案的，这里就不介绍了。这里要简单的使用 \( NumPy \) 生成一些测试数据，如果对 \( NumPy \) 不熟悉，参考 <a href="http://fitzeng.org/2018/02/04/NumPyOfficialQuickstartTutorial/">NumPy 官方快速入门教程(译)</a>，如果对 \( Matplotlib \) 不熟悉，参考<a href="http://fitzeng.org/2018/02/07/MatplotlibDraw/">Matplotlib 基本操作</a>。当然如果要能够保存 \( GIF \) 还需要一个工具 <a href="http://www.imagemagick.org/script/download.php#macosx" target="_blank" rel="external">ImageMagick</a>，按照官方指导安装就好，确保在命令中输入 <code>magick</code> 有响应。如果使用 \( PyCharm \) 之类的 \( IDE \) 请将环境变量配置到全局，避免在 \( IDE \) 中找不到命令。</p>
<h2 id="1-绘制基本动图"><a href="#1-绘制基本动图" class="headerlink" title="1. 绘制基本动图"></a>1. 绘制基本动图</h2><p>请确保已经安装了 <a href="http://www.imagemagick.org/script/download.php#macosx" target="_blank" rel="external">ImageMagick</a> 并且可用的情况下再继续，不然代码跑步起来。</p>
<p>这里采用两种方式绘制动图</p>
<h3 id="1-1-重置重绘"><a href="#1-1-重置重绘" class="headerlink" title="1.1 重置重绘"></a>1.1 重置重绘</h3><p>重置重绘主要是每次更新原来图形的值来达到绘制动图的效果。</p>
<ul>
<li>导入基本库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">from matplotlib import pyplot as plt</div><div class="line">from matplotlib import animation</div></pre></td></tr></table></figure>
<ul>
<li>生成数据，画出原始图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fig, ax = plt.subplots()</div><div class="line"></div><div class="line">x = np.arange(0, 2 * np.pi, 0.01)</div><div class="line">line0 = ax.plot(x, np.cos(x))</div><div class="line">line, = ax.plot(x, np.sin(x))</div></pre></td></tr></table></figure>
<p>注意，这里申明的 \( line, \) 中 <code>,</code> 不能少，好像是为了更新值时类型匹配。没深究，希望知道的可以指点一下。</p>
<ul>
<li>定义初始函数和跟新函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def init():</div><div class="line">    line.set_ydata(np.sin(x))</div><div class="line">    return line,</div><div class="line"></div><div class="line">def animate(i):</div><div class="line">    line.set_ydata(np.sin(x + i / 10.0))</div><div class="line">    return line,</div></pre></td></tr></table></figure>
<p>其实就是更新一下 \( Y \) 坐标的值。</p>
<ul>
<li>执行动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animation = animation.FuncAnimation(fig=fig, func=animate, frames=100, init_func=init, interval=20, blit=False)</div></pre></td></tr></table></figure>
<p>这个函数的参数可以看源码，以及官网的介绍，这里就是每个 \( 20\ ms \) 绘制一帧，总共有 \( 100 \) 帧。</p>
<ul>
<li>保存 \( GIF \)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">animation.save(&apos;resetvalue.gif&apos;, writer=&apos;imagemagick&apos;)</div></pre></td></tr></table></figure>
<p>这里就是直接保存成 \( GIF \) 格式就好了。</p>
<ul>
<li>显示动图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>生成图片的效果如图所示：</p>
<p><img src="/2018/02/08/MatplotlibGenerateGif/resetvalue.gif" alt=""></p>
<h3 id="1-2-擦除重绘"><a href="#1-2-擦除重绘" class="headerlink" title="1.2 擦除重绘"></a>1.2 擦除重绘</h3><p>与上一种方法比较，这种就是不利用上一次的任何坐标，直接擦除，然后再 \( plot \) 图形上去。</p>
<ul>
<li>导入基本库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">from matplotlib import pyplot as plt</div><div class="line">from matplotlib import animation</div></pre></td></tr></table></figure>
<ul>
<li>生成数据，画出原始图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fig, ax = plt.subplots()</div><div class="line"></div><div class="line">x = np.arange(0, 2 * np.pi, 0.01)</div><div class="line">ax.plot(x, np.cos(x))</div></pre></td></tr></table></figure>
<p>这里就没有那个要求了，因为这种方式不依赖于前面的图形。</p>
<ul>
<li>定义初始函数和跟新函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def init():</div><div class="line">    return ax.plot(x, np.sin(x))</div><div class="line"></div><div class="line"></div><div class="line">def animate(i):</div><div class="line">    try:</div><div class="line">        ax.lines.pop(1)</div><div class="line">    except Exception:</div><div class="line">        pass</div><div class="line">    line = ax.plot(x, np.sin(x + i / 10.0), &apos;r&apos;)</div><div class="line">    return line,</div></pre></td></tr></table></figure>
<p>初始化没什么好说的，其实也可以不初始化，时间间隔太短效果基本是看不出来的。下面介绍一下 <code>ax.lines.pop(1)</code> 这句“擦除”函数。这里的 \( lines \)可以理解为存储 \( plot \) 上来的图像栈，前面 \( plot \) 了一个余弦函数，在初始化的时候绘制了第二条，所以索引是 \( 1 \) 的正弦函数被 \( pop \) 了然后进行下一条绘制。于是执行 <code>line = ax.plot(x, np.sin(x + i / 10.0), &#39;r&#39;)</code></p>
<ul>
<li>后续</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">animation = animation.FuncAnimation(fig=fig, func=animate, frames=100, init_func=init, interval=20, blit=False)</div><div class="line">animation.save(&apos;redraw.gif&apos;, writer=&apos;imagemagick&apos;)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>没区别</p>
<p>生成图片的效果如图所示：</p>
<p><img src="/2018/02/08/MatplotlibGenerateGif/redraw.gif" alt=""></p>
<h2 id="2-机器学习过程可视化"><a href="#2-机器学习过程可视化" class="headerlink" title="2. 机器学习过程可视化"></a>2. 机器学习过程可视化</h2><p>前面介绍了的知识基本够用了，但终究不是实操。如果你不是学习机器学习的，其实有上面的基础就可以了，这一节可以跳过。但是，如果你想学机器学习的话，这里提供一个小例子让你更加清晰的理解机器学习的过程中的数据变化。不过这里只专注于绘制，机器学习的部分参考<a href="http://fitzeng.org/2018/02/03/TensorFlowIntroduction/">从 TensorFlow 入门机器学习</a></p>
<p>同样还是拿线性回归作为例子。</p>
<p>原始代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"># coding: utf-8</div><div class="line">from __future__ import print_function</div><div class="line">import tensorflow as tf</div><div class="line">import numpy as np</div><div class="line">import matplotlib.pyplot as plt</div><div class="line">import matplotlib.animation as animation</div><div class="line">from scipy.interpolate import spline</div><div class="line"></div><div class="line">train_X = np.linspace(0, 10, 50)</div><div class="line">noise = np.random.normal(0, 1, train_X.shape)</div><div class="line">train_Y = train_X * 1 - 2 + noise</div><div class="line"></div><div class="line">X = tf.placeholder(tf.float32)</div><div class="line">Y = tf.placeholder(tf.float32)</div><div class="line"></div><div class="line">W = tf.Variable(-1., name=&quot;weight&quot;)</div><div class="line">b = tf.Variable(1., name=&quot;bias&quot;)</div><div class="line"></div><div class="line">activation = tf.add(tf.multiply(X, W), b)</div><div class="line"></div><div class="line">learning_rate = 0.0001</div><div class="line"></div><div class="line">cost = tf.reduce_sum(tf.pow(activation - Y, 2))</div><div class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)</div><div class="line"></div><div class="line">training_epochs = 20</div><div class="line">display_step = 10</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    for epoch in range(training_epochs):</div><div class="line">        for (x, y) in zip(train_X, train_Y):</div><div class="line">            sess.run(optimizer, feed_dict=&#123;X: x, Y: y&#125;)</div><div class="line">        if epoch &lt; 10 or epoch % display_step == 0:</div><div class="line">            c_tmp = sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;)</div><div class="line">            W_tmp = sess.run(W)</div><div class="line">            b_tmp = sess.run(b)</div><div class="line">            activation_tmp = sess.run(activation, feed_dict=&#123;X: train_X&#125;)</div><div class="line">            print(&quot;Epoch: %04d&quot; % (epoch + 1), &quot;cost=&quot;, &quot;&#123;:.9f&#125;&quot;.format(c_tmp), &quot;W=&quot;, W_tmp, &quot;b=&quot;, b_tmp)</div><div class="line">    print(&quot;Optimization Finished!&quot;)</div><div class="line">    print(&quot;cost=&quot;, sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;), &quot;W=&quot;, sess.run(W), &quot;b=&quot;, sess.run(b))</div></pre></td></tr></table></figure>
<p>上面的代码就不解释了，为了方便测试，把迭代次数调的比较小。接下来我们在上面的基础上进行扩充。</p>
<p>首先进行可视化，首先把我们觉得有用的数据提取出来吧。因为经过测试，前面的变化幅度比较大，为了图示明显，刻意进行非均匀采样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">c_trace = []</div><div class="line">W_trace = []</div><div class="line">b_trace = []</div><div class="line">activation_trace = []</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    for epoch in range(training_epochs):</div><div class="line">        for (x, y) in zip(train_X, train_Y):</div><div class="line">            sess.run(optimizer, feed_dict=&#123;X: x, Y: y&#125;)</div><div class="line">        if epoch &lt; 10 or epoch % display_step == 0:</div><div class="line">            c_tmp = sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;)</div><div class="line">            W_tmp = sess.run(W)</div><div class="line">            b_tmp = sess.run(b)</div><div class="line">            activation_tmp = sess.run(activation, feed_dict=&#123;X: train_X&#125;)</div><div class="line">            print(&quot;Epoch: %04d&quot; % (epoch + 1), &quot;cost=&quot;, &quot;&#123;:.9f&#125;&quot;.format(c_tmp), &quot;W=&quot;, W_tmp, &quot;b=&quot;, b_tmp)</div><div class="line">            c_trace.append(c_tmp)</div><div class="line">            W_trace.append(W_tmp)</div><div class="line">            b_trace.append(b_tmp)</div><div class="line">            activation_trace.append(activation_tmp)</div><div class="line">    print(&quot;Optimization Finished!&quot;)</div><div class="line">    print(&quot;cost=&quot;, sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;), &quot;W=&quot;, sess.run(W), &quot;b=&quot;, sess.run(b))</div></pre></td></tr></table></figure>
<p>参考前面的小例子，把数据填进去，做出动图来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">fig, ax = plt.subplots()</div><div class="line">l1 = ax.scatter(train_X, train_Y, color=&apos;red&apos;, label=r&apos;$Original\ data$&apos;)</div><div class="line">ax.set_xlabel(r&apos;$X\ data$&apos;)</div><div class="line">ax.set_ylabel(r&apos;$Y\ data$&apos;)</div><div class="line"></div><div class="line"></div><div class="line">def update(i):</div><div class="line">    try:</div><div class="line">        ax.lines.pop(0)</div><div class="line">    except Exception:</div><div class="line">        pass</div><div class="line">    line, = ax.plot(train_X, activation_trace[i], &apos;g--&apos;, label=r&apos;$Fitting\ line$&apos;, lw=2)</div><div class="line">    return line,</div><div class="line"></div><div class="line"></div><div class="line">ani = animation.FuncAnimation(fig, update, frames=len(activation_trace), interval=100)</div><div class="line">ani.save(&apos;linearregression.gif&apos;, writer=&apos;imagemagick&apos;)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>效果如下图所示：</p>
<p><img src="/2018/02/08/MatplotlibGenerateGif/linearregression1.gif" alt=""></p>
<p>接着把 \( Cost \) 函数也加上来并且在最后显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def update(i):</div><div class="line">    try:</div><div class="line">        ax.lines.pop(0)</div><div class="line">    except Exception:</div><div class="line">        pass</div><div class="line">    line, = ax.plot(train_X, activation_trace[i], &apos;g--&apos;, label=r&apos;$Fitting\ line$&apos;, lw=2)</div><div class="line">    if i == len(activation_trace) - 1:</div><div class="line">        twinax = ax.twinx()</div><div class="line">        twinax.plot(np.linspace(0, 10, np.size(c_trace)), c_trace, &apos;b&apos;, label=&apos;Cost line&apos;, lw=2)</div><div class="line">    return line,</div></pre></td></tr></table></figure>
<p><img src="/2018/02/08/MatplotlibGenerateGif/linearregression2.gif" alt=""><br><img src="/2018/02/08/MatplotlibGenerateGif/linearregression2.png" alt=""></p>
<p>可以看到，线条十分锋利，这时就可以使用 \( spline \)平滑过渡一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def update(i):</div><div class="line">    try:</div><div class="line">        ax.lines.pop(0)</div><div class="line">    except Exception:</div><div class="line">        pass</div><div class="line">    line, = ax.plot(train_X, activation_trace[i], &apos;g--&apos;, label=r&apos;$Fitting\ line$&apos;, lw=2)</div><div class="line">    if i == len(activation_trace) - 1:</div><div class="line">        xnew = np.linspace(0, 10, np.max(c_trace) - np.min(c_trace))</div><div class="line">        smooth = spline(np.linspace(0, 10, np.size(c_trace)), c_trace, xnew)</div><div class="line">        twinax = ax.twinx()</div><div class="line">        twinax.set_ylabel(r&apos;Cost&apos;)</div><div class="line">        twinax.plot(xnew, smooth, &apos;b&apos;, label=r&apos;$Cost\ line$&apos;, lw=2)</div><div class="line">    return line,</div></pre></td></tr></table></figure>
<p>其实就是对 \( [0, 10] \) 这个区间进行采样。添加 <code>np.max(c_trace) - np.min(c_trace)</code> 个点来绘制这线条。</p>
<p><img src="/2018/02/08/MatplotlibGenerateGif/linearregression3.png" alt=""></p>
<p>加上图例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def update(i):</div><div class="line">    try:</div><div class="line">        ax.lines.pop(0)</div><div class="line">    except Exception:</div><div class="line">        pass</div><div class="line">    line, = ax.plot(train_X, activation_trace[i], &apos;g--&apos;, label=r&apos;$Fitting\ line$&apos;, lw=2)</div><div class="line">    plt.legend(handles=[l1, line], loc=&apos;upper center&apos;)</div><div class="line">    if i == len(activation_trace) - 1:</div><div class="line">        ax.text(6, -2, &apos;Cost: %s&apos; % c_trace[i], fontdict=&#123;&apos;size&apos;: 16, &apos;color&apos;: &apos;r&apos;&#125;)</div><div class="line">        xnew = np.linspace(0, 10, np.max(c_trace) - np.min(c_trace))</div><div class="line">        smooth = spline(np.linspace(0, 10, np.size(c_trace)), c_trace, xnew)</div><div class="line">        twinax = ax.twinx()</div><div class="line">        twinax.set_ylabel(r&apos;Cost&apos;)</div><div class="line">        costline, = twinax.plot(xnew, smooth, &apos;b&apos;, label=r&apos;$Cost\ line$&apos;, lw=2)</div><div class="line">        plt.legend(handles=[l1, line, costline], loc=&apos;upper center&apos;)</div><div class="line">    return line,</div></pre></td></tr></table></figure>
<p><img src="/2018/02/08/MatplotlibGenerateGif/linearregression3.gif" alt=""><br><img src="/2018/02/08/MatplotlibGenerateGif/linearregression4.png" alt=""></p>
<p>下面把数据细节处理下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">learning_rate = 0.001</div><div class="line"></div><div class="line">training_epochs = 500</div><div class="line">display_step = 40</div></pre></td></tr></table></figure>
<p><img src="/2018/02/08/MatplotlibGenerateGif/linearregression5.png" alt=""></p>
<p>可以看到，\( Cost \) 函数并非严格递减的，我们采用的是梯度下降算法求最优，所以问题出在学习率，具体为什么也是一个机器学习中应该注意的问题。另外大家还可以试试继续把学习率调大看看会发生什么有趣的事情？</p>
<p>我们把学习率调整到 <code>0.0001</code> 将会得到以下结果：</p>
<p><img src="/2018/02/08/MatplotlibGenerateGif/linearregression4.gif" alt=""><br><img src="/2018/02/08/MatplotlibGenerateGif/linearregression6.png" alt=""></p>
<p>其实你观察输出可能并不怎么符合原始函数。而且在不断调整训练参数的时候会发现拟合程度似乎也没法每次后很好。原因其实在于加的干扰，至于为什么干扰会造成这样，就不在本文的讨论范围了。好了，到这里你应该可以绘制自己的 \( GIF \)了吧。</p>
<p>源码详见 <a href="https://github.com/mk43/python-practice/tree/master/matplotlib" target="_blank" rel="external">GitHub</a></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>花时间把小细节搞懂就是节省时间，其实眼前的问题可以引申出其它更多值得思考的问题。多联系，多思考。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul>
<li><a href="https://morvanzhou.github.io/tutorials/data-manipulation/plt/" target="_blank" rel="external">morvan：markdown + 视频</a></li>
<li><a href="https://matplotlib.org/tutorials/index.html" target="_blank" rel="external">官方文档</a></li>
<li><a href="https://www.jianshu.com/p/aa4150cf6c7f" target="_blank" rel="external">Matplotlib 入门教程</a></li>
<li><a href="https://www.jianshu.com/p/aa4150cf6c7f" target="_blank" rel="external">Matplotlib 教程</a></li>
<li><a href="https://www.tuicool.com/articles/Z7BzY3V" target="_blank" rel="external">如何用 Matplotlib 画 GIF 动图</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;写在前面：为了可视化机器学习过程，并且保存下来，所以想直接利用 \( Matplotlib.animation \) 保存动图，期间参考了好多资料，过程比较艰辛，所以想记录下来。当然，此文还参考了好多网上的其它文章，再此一并感谢那些热爱分享的 \( coder \)，并且参考资料中给出链接。所有代码整理到&lt;a href=&quot;https://github.com/mk43/python-practice/tree/master/matplotlib&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Math" scheme="http://fitzeng.org/tags/Math/"/>
    
      <category term="MachineLearning" scheme="http://fitzeng.org/tags/MachineLearning/"/>
    
      <category term="Python" scheme="http://fitzeng.org/tags/Python/"/>
    
      <category term="NumPy" scheme="http://fitzeng.org/tags/NumPy/"/>
    
      <category term="Matplotlib" scheme="http://fitzeng.org/tags/Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib 基本操作</title>
    <link href="http://fitzeng.org/2018/02/07/MatplotlibDraw/"/>
    <id>http://fitzeng.org/2018/02/07/MatplotlibDraw/</id>
    <published>2018-02-07T03:27:00.000Z</published>
    <updated>2018-02-13T02:43:09.248Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<blockquote>
<p>写在前面：这篇主要为了自己的学习，先理一下基础概念，然后记录下来，下次使用起来就方便了。学这个的主要目的是为了可视化机器学习的学习过程。网络上的资料太多了，每次写的时候去查算起来也是挺花费时间的。所以还是花点时间直接整理记录好了。这里推荐<a href="https://morvanzhou.github.io/tutorials/data-manipulation/plt/" target="_blank" rel="external">morvan：markdown + 视频</a> 和 <a href="https://matplotlib.org/tutorials/index.html" target="_blank" rel="external">官方文档</a>。当然，此文还参考了好多网上的其它文章，再此一并感谢，并且参考资料中给出链接。所有代码整理到<a href="https://github.com/mk43/python-practice/tree/master/matplotlib" target="_blank" rel="external">GitHub</a>。</p>
</blockquote>
<a id="more"></a>
<h2 id="0-前期准备"><a href="#0-前期准备" class="headerlink" title="0. 前期准备"></a>0. 前期准备</h2><p>安装 \( NumPy \) 和 \( Matplotlib \)。具体安装直接上官网便可，遇到什么问题在网上基本可以搜到答案的，这里就不介绍了。这里要简单的使用 \( NumPy \) 生成一些测试数据，如果对 \( NumPy \) 不熟悉的话可以参考我之前记录的 <a href="http://fitzeng.org/2018/02/04/NumPyOfficialQuickstartTutorial/">NumPy 官方快速入门教程(译)</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PyCharm: 2017.3.3</div><div class="line">Python: Python 3.6.4 :: Anaconda, Inc.</div></pre></td></tr></table></figure>
<h2 id="1-Matplotlib-快速入门"><a href="#1-Matplotlib-快速入门" class="headerlink" title="1. Matplotlib 快速入门"></a>1. Matplotlib 快速入门</h2><p>主要内容是把图画出来，然后认识图中的基本元素。</p>
<h3 id="1-1-显示图像"><a href="#1-1-显示图像" class="headerlink" title="1.1 显示图像"></a>1.1 显示图像</h3><p>直接上代码吧。整个过程就是<code>导库-准备数据-绘制-显示</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">x = np.linspace(0, 10, 20)</div><div class="line">y = x + 1</div><div class="line"></div><div class="line">plt.plot(x, y)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_1_01.png" alt=""></p>
<p>那么显示多条线怎么办？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x = np.linspace(0, 10, 20)</div><div class="line">y1 = x + 1</div><div class="line">y2 = -x + 1</div><div class="line"></div><div class="line">plt.plot(x, y1)</div><div class="line">plt.plot(x, y2)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_1_02.png" alt=""></p>
<p>看到这里，我们就很清楚了，\( plot \) 函数就是把数据绘制在画框里。</p>
<h3 id="1-2-认识-figure"><a href="#1-2-认识-figure" class="headerlink" title="1.2 认识 figure"></a>1.2 认识 figure</h3><p>\( figure \) 可以理解为一个画框，往里面 \( plot \) 图形。所以以下代码会显示出两个窗体。一个窗体比例是 \( 9 : 6 \)。更多参数可以参考源码注释，讲的很清楚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x = np.linspace(0, 10, 20)</div><div class="line">y1 = x + 1</div><div class="line">y2 = -x - 10</div><div class="line">plt.figure()</div><div class="line">plt.plot(x, y1)</div><div class="line">plt.figure(figsize=(9, 6))</div><div class="line">plt.plot(x, y2)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_2_01.png" alt=""><br><img src="/2018/02/07/MatplotlibDraw/1_2_02.png" alt=""></p>
<h3 id="1-3-plot-参数设置"><a href="#1-3-plot-参数设置" class="headerlink" title="1.3 plot 参数设置"></a>1.3 plot 参数设置</h3><p>先看下一些效果吧。<br><img src="/2018/02/07/MatplotlibDraw/1_3_01.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">x = np.linspace(0, 10, 20)</div><div class="line">y1 = x + 1</div><div class="line">y2 = x + 2</div><div class="line">y3 = x + 3</div><div class="line">y4 = x + 4</div><div class="line">y5 = x + 5</div><div class="line">y6 = x + 6</div><div class="line">y7 = x + 7</div><div class="line"></div><div class="line">plt.figure()</div><div class="line">plt.plot(x, y1, &apos;bo&apos;)</div><div class="line">plt.plot(x, y2, &apos;r-&apos;)</div><div class="line">plt.plot(x, y3, &apos;g--&apos;)</div><div class="line">plt.plot(x, y4, &apos;y.-&apos;)</div><div class="line">plt.plot(x, y5, &apos;m^&apos;, x, y6, &apos;m-&apos;)</div><div class="line">plt.plot(x, y7, &apos;c-&apos;, linewidth=6)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>这里可供实验的东西实在太多，只要知道这个函数大概可以给我提供什么效果就可以了，其它的交给<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot" target="_blank" rel="external">API: matplotlib.pyplot.plot</a></p>
<h3 id="1-4-坐标轴设置"><a href="#1-4-坐标轴设置" class="headerlink" title="1.4 坐标轴设置"></a>1.4 坐标轴设置</h3><p>设置范围和标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">x = np.linspace(-10, 10, 40)</div><div class="line">y1 = 10 * x + 50</div><div class="line">y2 = x**2</div><div class="line"></div><div class="line">plt.figure()</div><div class="line">plt.plot(x, y1, &apos;b-&apos;)</div><div class="line">plt.plot(x, y2, &apos;b--&apos;)</div><div class="line">plt.xlim((-20, 20))</div><div class="line">plt.ylim((-60, 160))</div><div class="line">plt.xlabel(&apos;I am x&apos;)</div><div class="line">plt.ylabel(&apos;I am y&apos;)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_4_01.png" alt=""></p>
<p>设置刻度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plt.xticks(np.linspace(-20, 20, 5))</div><div class="line">plt.yticks([0, 50, 100], [r&apos;$bad$&apos;, r&apos;$normal$&apos;, r&apos;$good$&apos;])</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_4_02.png" alt=""></p>
<p>设置边框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boderparameter = plt.gca()</div><div class="line">boderparameter.spines[&apos;right&apos;].set_color(&apos;none&apos;)</div><div class="line">boderparameter.spines[&apos;top&apos;].set_color(&apos;none&apos;)</div></pre></td></tr></table></figure></p>
<p><img src="/2018/02/07/MatplotlibDraw/1_4_03.png" alt=""></p>
<p>设置刻度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boderparameter.xaxis.set_ticks_position(&apos;top&apos;)</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_4_04.png" alt=""></p>
<p>通过边框参数设置属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">boderparameter.spines[&apos;left&apos;].set_position((&apos;data&apos;,0))</div><div class="line">boderparameter.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))</div><div class="line">boderparameter.xaxis.set_ticks_position(&apos;bottom&apos;)</div><div class="line">boderparameter.set_xlabel(&apos;&apos;)</div><div class="line">boderparameter.set_ylabel(&apos;&apos;)</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_4_05.png" alt=""></p>
<h3 id="1-5-图例设置"><a href="#1-5-图例设置" class="headerlink" title="1.5 图例设置"></a>1.5 图例设置</h3><p>这里很简单，设置 \( label \) 和 位置就可以了。其它可以参考文档。需要注意的一点是 \( l1\ l2 \)后面要加一个 <code>,</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">x = np.linspace(-10, 10, 40)</div><div class="line">y1 = 10 * x + 50</div><div class="line">y2 = x**2</div><div class="line"></div><div class="line">plt.figure()</div><div class="line">l1, = plt.plot(x, y1, &apos;b-&apos;)</div><div class="line">l2, = plt.plot(x, y2, &apos;b--&apos;)</div><div class="line"></div><div class="line">plt.legend(handles=[l1, l2], labels=[r&apos;$line\ 1$&apos;, r&apos;$line\ 2$&apos;],  loc=&apos;best&apos;)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_5_01.png" alt=""></p>
<h3 id="1-6-添加注释"><a href="#1-6-添加注释" class="headerlink" title="1.6 添加注释"></a>1.6 添加注释</h3><p>直接看代码，就不一一介绍了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">x = np.linspace(-10, 10, 40)</div><div class="line">y = x + 5</div><div class="line"></div><div class="line">plt.figure()</div><div class="line">plt.plot(x, y, &apos;b-&apos;)</div><div class="line"></div><div class="line">plt.xticks(np.linspace(-10, 10, 6))</div><div class="line">plt.yticks(np.linspace(-6, 14, 6))</div><div class="line"></div><div class="line">ax = plt.gca()</div><div class="line">ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)</div><div class="line">ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)</div><div class="line"></div><div class="line">ax.xaxis.set_ticks_position(&apos;bottom&apos;)</div><div class="line">ax.spines[&apos;bottom&apos;].set_position(&apos;zero&apos;)</div><div class="line"></div><div class="line">ax.yaxis.set_ticks_position(&apos;left&apos;)</div><div class="line">ax.spines[&apos;left&apos;].set_position(&apos;zero&apos;)</div><div class="line"></div><div class="line">x0 = 4</div><div class="line">y0 = x0 + 5</div><div class="line">plt.plot([x0, x0], [0, y0], &apos;k--&apos;, linewidth=2.5)</div><div class="line">plt.scatter([x0], [y0], color=&apos;k&apos;)</div><div class="line"></div><div class="line">plt.annotate(r&apos;$(%s,\ %s)$&apos; % (x0, y0), xy=(x0, y0),</div><div class="line">             xycoords=&apos;data&apos;, xytext=(+30, -30),</div><div class="line">             textcoords=&apos;offset points&apos;, fontsize=16,</div><div class="line">             arrowprops=dict(arrowstyle=&apos;-&gt;&apos;, connectionstyle=&quot;arc3,rad=.1&quot;))</div><div class="line"></div><div class="line">plt.text(2, 14, r&apos;$y\ =\ x\ +\ 5$&apos;, fontdict=&#123;&apos;size&apos;: 16, &apos;color&apos;: &apos;r&apos;&#125;)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>主要是观察倒数第二三行代码进行设置。</p>
<p><img src="/2018/02/07/MatplotlibDraw/1_6_01.png" alt=""></p>
<h3 id="1-7-散点图"><a href="#1-7-散点图" class="headerlink" title="1.7 散点图"></a>1.7 散点图</h3><p>散点图在上面标点的时候就已经用过了，这里回顾一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">n = 1024</div><div class="line">X = np.random.normal(0, 1, n)</div><div class="line">Y = np.random.normal(0, 1, n)</div><div class="line">T = np.arctan2(Y, X)</div><div class="line"></div><div class="line">plt.scatter(X, Y, s=50, c=T, alpha=.5)</div><div class="line"></div><div class="line">plt.xlim(-2.5, 2.5)</div><div class="line">plt.xticks(())</div><div class="line">plt.ylim(-2.5, 2.5)</div><div class="line">plt.yticks(())</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="/2018/02/07/MatplotlibDraw/1_7_01.png" alt=""></p>
<h3 id="1-8-柱状图"><a href="#1-8-柱状图" class="headerlink" title="1.8 柱状图"></a>1.8 柱状图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">n = 12</div><div class="line">X = np.arange(n)</div><div class="line">Y1 = np.random.uniform(0.1, 1.0, n)</div><div class="line">Y2 = np.random.uniform(0.1, 1.0, n)</div><div class="line"></div><div class="line">plt.bar(X, +Y1)</div><div class="line">plt.bar(X, -Y2)</div><div class="line"></div><div class="line">plt.xlim(-.5, n)</div><div class="line">plt.xticks(())</div><div class="line">plt.ylim(-1.25, 1.25)</div><div class="line">plt.yticks(())</div><div class="line"></div><div class="line">for x, y in zip(X, Y1):</div><div class="line">    plt.text(x, y + 0.02, &apos;%.2f&apos; % y, ha=&apos;center&apos;, va=&apos;bottom&apos;)</div><div class="line"></div><div class="line">for x, y in zip(X, Y2):</div><div class="line">    plt.text(x, -y - 0.02, &apos;%.2f&apos; % y, ha=&apos;center&apos;, va=&apos;top&apos;)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_8_01.png" alt=""></p>
<h3 id="1-9-饼状图"><a href="#1-9-饼状图" class="headerlink" title="1.9 饼状图"></a>1.9 饼状图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line">labels = &apos;Frogs&apos;, &apos;Hogs&apos;, &apos;Dogs&apos;, &apos;Logs&apos;</div><div class="line">sizes = [15, 30, 45, 10]</div><div class="line">explode = (0, 0.1, 0, 0)</div><div class="line">colors = [&apos;y&apos;, &apos;g&apos;, &apos;c&apos;, &apos;m&apos;]</div><div class="line"></div><div class="line">fig1, ax1 = plt.subplots()</div><div class="line">ax1.pie(sizes, colors=colors, explode=explode, labels=labels, autopct=&apos;%1.f%%&apos;, shadow=True, startangle=90)</div><div class="line">ax1.axis(&apos;equal&apos;)  # Equal aspect ratio ensures that pie is drawn as a circle.</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_9_01.png" alt=""></p>
<h3 id="1-10-等高线"><a href="#1-10-等高线" class="headerlink" title="1.10 等高线"></a>1.10 等高线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">import numpy as np</div><div class="line"></div><div class="line"></div><div class="line">def f(x, y):</div><div class="line">    return (1 - x / 2 + x ** 5 + y ** 3) * np.exp(-x ** 2 - y ** 2)</div><div class="line"></div><div class="line"></div><div class="line">n = 256</div><div class="line">x = np.linspace(-3, 3, n)</div><div class="line">y = np.linspace(-3, 3, n)</div><div class="line">X, Y = np.meshgrid(x, y)</div><div class="line"></div><div class="line">plt.contourf(X, Y, f(X, Y), 12, alpha=.9, cmap=plt.cm.coolwarm)</div><div class="line"></div><div class="line">C = plt.contour(X, Y, f(X, Y), 12, colors=&apos;black&apos;)</div><div class="line"></div><div class="line">plt.clabel(C, inline=True, fontsize=10)</div><div class="line">plt.xticks(())</div><div class="line">plt.yticks(())</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_10_01.png" alt=""></p>
<h3 id="1-11-图像"><a href="#1-11-图像" class="headerlink" title="1.11 图像"></a>1.11 图像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">a = np.random.normal(2, 1, 16).reshape(4, 4)</div><div class="line"></div><div class="line">plt.imshow(a, interpolation=&apos;nearest&apos;, cmap=&apos;coolwarm&apos;, origin=&apos;lower&apos;)</div><div class="line"></div><div class="line">plt.colorbar(shrink=.98)</div><div class="line"></div><div class="line">plt.xticks(())</div><div class="line">plt.yticks(())</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_11_01.png" alt=""></p>
<h3 id="1-12-3D"><a href="#1-12-3D" class="headerlink" title="1.12 3D"></a>1.12 3D</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import matplotlib.pyplot as plt</div><div class="line">from mpl_toolkits.mplot3d import Axes3D</div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">ax = Axes3D(fig)</div><div class="line"></div><div class="line">X = np.arange(-4, 4, 0.25)</div><div class="line">Y = np.arange(-4, 4, 0.25)</div><div class="line">X, Y = np.meshgrid(X, Y)</div><div class="line">R = np.sqrt(X ** 2 + Y ** 2)</div><div class="line">Z = np.sin(R)</div><div class="line"></div><div class="line">ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap(&apos;rainbow&apos;))</div><div class="line"></div><div class="line">ax.contourf(X, Y, Z, zdir=&apos;x&apos;, offset=-5, cmap=plt.get_cmap(&apos;rainbow&apos;))</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_12_01.png" alt=""></p>
<h3 id="1-13-子图"><a href="#1-13-子图" class="headerlink" title="1.13 子图"></a>1.13 子图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line"># example 1:</div><div class="line">###############################</div><div class="line">plt.figure(figsize=(6, 4))</div><div class="line"># plt.subplot(n_rows, n_cols, plot_num)</div><div class="line">plt.subplot(2, 2, 1)</div><div class="line">plt.plot([0, 1], [0, 1])</div><div class="line"></div><div class="line">plt.subplot(222)</div><div class="line">plt.plot([0, 1], [0, 2])</div><div class="line"></div><div class="line">plt.subplot(223)</div><div class="line">plt.plot([0, 1], [0, 3])</div><div class="line"></div><div class="line">plt.subplot(224)</div><div class="line">plt.plot([0, 1], [0, 4])</div><div class="line"></div><div class="line">plt.tight_layout()</div><div class="line"></div><div class="line"># example 2:</div><div class="line">###############################</div><div class="line">plt.figure(figsize=(6, 4))</div><div class="line"># plt.subplot(n_rows, n_cols, plot_num)</div><div class="line">plt.subplot(2, 1, 1)</div><div class="line"># figure splits into 2 rows, 1 col, plot to the 1st sub-fig</div><div class="line">plt.plot([0, 1], [0, 1])</div><div class="line"></div><div class="line">plt.subplot(234)</div><div class="line"># figure splits into 2 rows, 3 col, plot to the 4th sub-fig</div><div class="line">plt.plot([0, 1], [0, 2])</div><div class="line"></div><div class="line">plt.subplot(235)</div><div class="line"># figure splits into 2 rows, 3 col, plot to the 5th sub-fig</div><div class="line">plt.plot([0, 1], [0, 3])</div><div class="line"></div><div class="line">plt.subplot(236)</div><div class="line"># figure splits into 2 rows, 3 col, plot to the 6th sub-fig</div><div class="line">plt.plot([0, 1], [0, 4])</div><div class="line"></div><div class="line"></div><div class="line">plt.tight_layout()</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_13_01.png" alt=""><br><img src="/2018/02/07/MatplotlibDraw/1_13_02.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">import matplotlib.gridspec as gridspec</div><div class="line"></div><div class="line"># method 1: subplot2grid</div><div class="line">##########################</div><div class="line">plt.figure()</div><div class="line">ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3)  # stands for axes</div><div class="line">ax1.plot([1, 2], [1, 2])</div><div class="line">ax1.set_title(&apos;ax1_title&apos;)</div><div class="line">ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)</div><div class="line">ax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)</div><div class="line">ax4 = plt.subplot2grid((3, 3), (2, 0))</div><div class="line">ax4.scatter([1, 2], [2, 2])</div><div class="line">ax4.set_xlabel(&apos;ax4_x&apos;)</div><div class="line">ax4.set_ylabel(&apos;ax4_y&apos;)</div><div class="line">ax5 = plt.subplot2grid((3, 3), (2, 1))</div><div class="line"></div><div class="line"># method 2: gridspec</div><div class="line">#########################</div><div class="line">plt.figure()</div><div class="line">gs = gridspec.GridSpec(3, 3)</div><div class="line"># use index from 0</div><div class="line">ax6 = plt.subplot(gs[0, :])</div><div class="line">ax7 = plt.subplot(gs[1, :2])</div><div class="line">ax8 = plt.subplot(gs[1:, 2])</div><div class="line">ax9 = plt.subplot(gs[-1, 0])</div><div class="line">ax10 = plt.subplot(gs[-1, -2])</div><div class="line"></div><div class="line"># method 3: easy to define structure</div><div class="line">####################################</div><div class="line">f, ((ax11, ax12), (ax13, ax14)) = plt.subplots(2, 2, sharex=True, sharey=True)</div><div class="line">ax11.scatter([1,2], [1,2])</div><div class="line"></div><div class="line">plt.tight_layout()</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_13_03.png" alt=""><br><img src="/2018/02/07/MatplotlibDraw/1_13_04.png" alt=""><br><img src="/2018/02/07/MatplotlibDraw/1_13_05.png" alt=""></p>
<h3 id="1-14-图中图"><a href="#1-14-图中图" class="headerlink" title="1.14 图中图"></a>1.14 图中图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">x = [1, 2, 3, 4, 5, 6, 7]</div><div class="line">y = [1, 3, 4, 2, 5, 8, 6]</div><div class="line"></div><div class="line"># below are all percentage</div><div class="line">left, bottom, width, height = 0.1, 0.1, 0.8, 0.8</div><div class="line">ax1 = fig.add_axes([left, bottom, width, height])  # main axes</div><div class="line">ax1.plot(x, y, &apos;r&apos;)</div><div class="line">ax1.set_xlabel(&apos;x&apos;)</div><div class="line">ax1.set_ylabel(&apos;y&apos;)</div><div class="line">ax1.set_title(&apos;title&apos;)</div><div class="line"></div><div class="line">ax2 = fig.add_axes([0.2, 0.6, 0.25, 0.25])  # inside axes</div><div class="line">ax2.plot(y, x, &apos;b&apos;)</div><div class="line">ax2.set_xlabel(&apos;x&apos;)</div><div class="line">ax2.set_ylabel(&apos;y&apos;)</div><div class="line">ax2.set_title(&apos;title inside 1&apos;)</div><div class="line"></div><div class="line"></div><div class="line"># different method to add axes</div><div class="line">####################################</div><div class="line">plt.axes([0.6, 0.2, 0.25, 0.25])</div><div class="line">plt.plot(y[::-1], x, &apos;g&apos;)</div><div class="line">plt.xlabel(&apos;x&apos;)</div><div class="line">plt.ylabel(&apos;y&apos;)</div><div class="line">plt.title(&apos;title inside 2&apos;)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_14_01.png" alt=""></p>
<h3 id="1-15-第二-Y-坐标"><a href="#1-15-第二-Y-坐标" class="headerlink" title="1.15 第二 Y 坐标"></a>1.15 第二 Y 坐标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">x = np.arange(0, 10, 0.1)</div><div class="line">y1 = 0.05 * x**2</div><div class="line">y2 = -1 *y1</div><div class="line"></div><div class="line">fig, ax1 = plt.subplots()</div><div class="line"></div><div class="line">ax2 = ax1.twinx()    # mirror the ax1</div><div class="line">ax1.plot(x, y1, &apos;g-&apos;)</div><div class="line">ax2.plot(x, y2, &apos;b-&apos;)</div><div class="line"></div><div class="line">ax1.set_xlabel(&apos;X data&apos;)</div><div class="line">ax1.set_ylabel(&apos;Y1 data&apos;, color=&apos;g&apos;)</div><div class="line">ax2.set_ylabel(&apos;Y2 data&apos;, color=&apos;b&apos;)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_15_01.png" alt=""></p>
<h3 id="1-16-动画"><a href="#1-16-动画" class="headerlink" title="1.16 动画"></a>1.16 动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">from matplotlib import pyplot as plt</div><div class="line">from matplotlib import animation</div><div class="line"></div><div class="line">fig, ax = plt.subplots()</div><div class="line"></div><div class="line">x = np.arange(0, 2*np.pi, 0.01)</div><div class="line">line, = ax.plot(x, np.sin(x))</div><div class="line"></div><div class="line"></div><div class="line">def animate(i):</div><div class="line">    line.set_ydata(np.sin(x + i/10.0))  # update the data</div><div class="line">    return line,</div><div class="line"></div><div class="line"></div><div class="line"># Init only required for blitting to give a clean slate.</div><div class="line">def init():</div><div class="line">    line.set_ydata(np.sin(x))</div><div class="line">    return line,</div><div class="line"></div><div class="line"># call the animator.  blit=True means only re-draw the parts that have changed.</div><div class="line"># blit=True dose not work on Mac, set blit=False</div><div class="line"># interval= update frequency</div><div class="line">ani = animation.FuncAnimation(fig=fig, func=animate, frames=100, init_func=init,</div><div class="line">                              interval=20, blit=False)</div><div class="line"></div><div class="line"># save the animation as an mp4.  This requires ffmpeg or mencoder to be</div><div class="line"># installed.  The extra_args ensure that the x264 codec is used, so that</div><div class="line"># the video can be embedded in html5.  You may need to adjust this for</div><div class="line"># your system: for more information, see</div><div class="line"># http://matplotlib.sourceforge.net/api/animation_api.html</div><div class="line"># anim.save(&apos;basic_animation.mp4&apos;, fps=30, extra_args=[&apos;-vcodec&apos;, &apos;libx264&apos;])</div><div class="line"></div><div class="line">ani.save(&apos;myanimation.gif&apos;, writer=&apos;imagemagick&apos;)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/07/MatplotlibDraw/1_16_01.gif" alt=""></p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>花时间把小细节搞懂就是节省时间。</p>
<h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><ul>
<li><a href="https://morvanzhou.github.io/tutorials/data-manipulation/plt/" target="_blank" rel="external">morvan：markdown + 视频</a></li>
<li><a href="https://matplotlib.org/tutorials/index.html" target="_blank" rel="external">官方文档</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;写在前面：这篇主要为了自己的学习，先理一下基础概念，然后记录下来，下次使用起来就方便了。学这个的主要目的是为了可视化机器学习的学习过程。网络上的资料太多了，每次写的时候去查算起来也是挺花费时间的。所以还是花点时间直接整理记录好了。这里推荐&lt;a href=&quot;https://morvanzhou.github.io/tutorials/data-manipulation/plt/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;morvan：markdown + 视频&lt;/a&gt; 和 &lt;a href=&quot;https://matplotlib.org/tutorials/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。当然，此文还参考了好多网上的其它文章，再此一并感谢，并且参考资料中给出链接。所有代码整理到&lt;a href=&quot;https://github.com/mk43/python-practice/tree/master/matplotlib&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Math" scheme="http://fitzeng.org/tags/Math/"/>
    
      <category term="MachineLearning" scheme="http://fitzeng.org/tags/MachineLearning/"/>
    
      <category term="Python" scheme="http://fitzeng.org/tags/Python/"/>
    
      <category term="NumPy" scheme="http://fitzeng.org/tags/NumPy/"/>
    
      <category term="Matplotlib" scheme="http://fitzeng.org/tags/Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>NumPy 官方快速入门教程(译)</title>
    <link href="http://fitzeng.org/2018/02/04/NumPyOfficialQuickstartTutorial/"/>
    <id>http://fitzeng.org/2018/02/04/NumPyOfficialQuickstartTutorial/</id>
    <published>2018-02-04T03:27:00.000Z</published>
    <updated>2018-02-04T09:26:08.312Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<blockquote>
<p>写在前面：本来是学习下 \( NumPy \)，看到官网的<a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="external">入门教程</a>想跟着实验一下，怕不常用，而我这人健忘，所以记录下来。索性就照着翻译一下，同样可以提升自己的阅读和写作能力，需要的可以存一下。当然，本人水平有限，有错误的地方欢迎大家指正。这里是基于 <a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="external">\( NumPy\ v1.13.dev0\ Manual \)</a> 翻译的。截止时间\( 2018/02/04 \)</p>
</blockquote>
<a id="more"></a>
<h2 id="快速入门教程"><a href="#快速入门教程" class="headerlink" title="快速入门教程"></a>快速入门教程</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h3><p>在你浏览这个指导之前，你应该懂一点 \( Python \) 。如果你想回顾一下可以看<a href="https://docs.python.org/3/tutorial/" target="_blank" rel="external">Python tutorial</a>。如果你想把教程的代码跑起来，必须安装一些软件，请参考<a href="http://scipy.org/install.html" target="_blank" rel="external">http://scipy.org/install.html</a></p>
<h3 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2 基础知识"></a>2 基础知识</h3><p>\( NumPy \) 的主要操作对象是同类型的多维数组。它是一个由正整数元组索引，元素类型相同的表（通常元素是数字）。在 \( NumPy \) 维度被称为 <code>axes</code>, <code>axes</code> 的数量称为 <code>rank</code>。</p>
<p>例如，在 \( 3D \) 空间的一个点 \( [1, 2, 1] \) 是一个 <code>rank = 1</code> 的数组，因为它只有一个 <code>axes</code>。这个 <code>axes</code> 的长度是 \( 3 \)。在下面这个例子中，数组 <code>rank = 2</code> （它是 \( 2  \)维的）。第一维（<code>axes</code>）长度是 \( 2 \)，第二位长度是 \( 3 \)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[ 1., 0., 0. ],</div><div class="line"> [ 0., 1., 2. ]]</div></pre></td></tr></table></figure>
<p>\( NumPy \) 的数组类是 <code>ndarray</code>。也可以叫做 <code>array</code>。说到这里，<code>numpy.array</code> 和标准 ( Python \) 库中的 <code>array.array</code> 是不一样的，它只能处理一维的数组和提供更少的功能。<code>ndarray</code> 对象的一些重要属性如下：</p>
<h5 id="ndarray-ndim"><a href="#ndarray-ndim" class="headerlink" title="ndarray.ndim"></a>ndarray.ndim</h5><blockquote>
<p>数组的 <code>axes</code> （维数）数值大小。在 \( Python \) 中维数的大小可以参考 <code>rank</code></p>
</blockquote>
<h5 id="ndarray-shape"><a href="#ndarray-shape" class="headerlink" title="ndarray.shape"></a>ndarray.shape</h5><blockquote>
<p>数组的维数，这是由每个维度的大小组成的一个元组。对于一个 \( n \) 行 \( m \) 列的矩阵。<code>shape</code> 是 <code>(n, m)</code>。由 <code>shape</code> 元组的长度得出 <code>rank</code> 或者维数 <code>ndim</code>。</p>
</blockquote>
<h5 id="ndarray-size"><a href="#ndarray-size" class="headerlink" title="ndarray.size"></a>ndarray.size</h5><blockquote>
<p>数组元素的个数总和，这等于 <code>shape</code> 元组数字的乘积。</p>
</blockquote>
<h5 id="ndarray-dtype"><a href="#ndarray-dtype" class="headerlink" title="ndarray.dtype"></a>ndarray.dtype</h5><blockquote>
<p>在数组中描述元素类型的一个对象。它是一种可以用标准的 \( Python \) 类型创建和指定的类型。另外，\( NumPy \)也提供了它自己的类型：<code>numpy.int32</code>，<code>numpy.int16</code>，<code>numpy.float64</code>……</p>
</blockquote>
<h5 id="ndarray-itemsize"><a href="#ndarray-itemsize" class="headerlink" title="ndarray.itemsize"></a>ndarray.itemsize</h5><blockquote>
<p>数组中每个元素所占字节数。例如，一个 <code>float64</code> 的 <code>itemsize</code> 是 \( 8 ( = 64/8bit) \)，<code>complex32</code> 的 <code>itemsize</code> 是 \( 4 ( = 32/8bit) \)。它和 <code>ndarray.dtype.itemsize</code> 是相等的。</p>
</blockquote>
<h5 id="ndarray-data"><a href="#ndarray-data" class="headerlink" title="ndarray.data"></a>ndarray.data</h5><blockquote>
<p>数组实际元素的缓存区。通常来说，我们不需要使用这个属性，因为我们会使用索引的方式访问数据。</p>
</blockquote>
<h3 id="2-1-例子"><a href="#2-1-例子" class="headerlink" title="2.1 例子"></a>2.1 例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import numpy as np</div><div class="line">&gt;&gt;&gt; a = np.arange(15).reshape(3, 5)</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0,  1,  2,  3,  4],</div><div class="line">       [ 5,  6,  7,  8,  9],</div><div class="line">       [10, 11, 12, 13, 14]])</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 5)</div><div class="line">&gt;&gt;&gt; a.ndim</div><div class="line">2</div><div class="line">&gt;&gt;&gt; a.dtype.name</div><div class="line">&apos;int64&apos;</div><div class="line">&gt;&gt;&gt; a.itemsize</div><div class="line">8</div><div class="line">&gt;&gt;&gt; a.size</div><div class="line">15</div><div class="line">&gt;&gt;&gt; type(a)</div><div class="line">&lt;type &apos;numpy.ndarray&apos;&gt;</div><div class="line">&gt;&gt;&gt; b = np.array([6, 7, 8])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([6, 7, 8])</div><div class="line">&gt;&gt;&gt; type(b)</div><div class="line">&lt;type &apos;numpy.ndarray&apos;&gt;</div></pre></td></tr></table></figure>
<h3 id="2-2-创建数组"><a href="#2-2-创建数组" class="headerlink" title="2.2 创建数组"></a>2.2 创建数组</h3><p>这里有几种方法创建数组。</p>
<p>例如，你可以使用 <code>array</code> 函数从一个常规的 \( Python \) 列表或元组创建一个数组。创建的数组类型是从原始序列中的元素推断出来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import numpy as np</div><div class="line">&gt;&gt;&gt; a = np.array([2,3,4])</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([2, 3, 4])</div><div class="line">&gt;&gt;&gt; a.dtype</div><div class="line">dtype(&apos;int64&apos;)</div><div class="line">&gt;&gt;&gt; b = np.array([1.2, 3.5, 5.1])</div><div class="line">&gt;&gt;&gt; b.dtype</div><div class="line">dtype(&apos;float64&apos;)</div></pre></td></tr></table></figure>
<p>一个常见错误是在调用 <code>array</code> 函数时，传递的参数是多个数值而不是一个单独的数字列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.array(1,2,3,4)    # WRONG</div><div class="line">&gt;&gt;&gt; a = np.array([1,2,3,4])  # RIGHT</div></pre></td></tr></table></figure>
<p><code>array</code> 将序列转化成高维数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = np.array([(1.5,2,3), (4,5,6)])</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 1.5,  2. ,  3. ],</div><div class="line">       [ 4. ,  5. ,  6. ]])</div></pre></td></tr></table></figure>
<p>数组的类型也能够在创建时具体指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = np.array( [ [1,2], [3,4] ], dtype=complex )</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([[ 1.+0.j,  2.+0.j],</div><div class="line">       [ 3.+0.j,  4.+0.j]])</div></pre></td></tr></table></figure>
<p>通常，我们都是知道数组的大小而不知道其中的原始数据。因此 \( NumPy \) 提供了几个用占位符的函数去创建数组。这样可以最小化增加数组的成本，增加数组是一项很耗费资源的操作。</p>
<p><code>zeros</code> 函数创建一个全是 \( 0 \) 的数组，<code>ones</code> 函数创建全是 \( 1 \) 的数组，<code>empty</code> 创建一个随机的数组。默认创建数组的类型是 <code>float64</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; np.zeros( (3,4) )</div><div class="line">array([[ 0.,  0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.,  0.],</div><div class="line">       [ 0.,  0.,  0.,  0.]])</div><div class="line">&gt;&gt;&gt; np.ones( (2,3,4), dtype=np.int16 )                # dtype can also be specified</div><div class="line">array([[[ 1, 1, 1, 1],</div><div class="line">        [ 1, 1, 1, 1],</div><div class="line">        [ 1, 1, 1, 1]],</div><div class="line">       [[ 1, 1, 1, 1],</div><div class="line">        [ 1, 1, 1, 1],</div><div class="line">        [ 1, 1, 1, 1]]], dtype=int16)</div><div class="line">&gt;&gt;&gt; np.empty( (2,3) )                                 # uninitialized, output may vary</div><div class="line">array([[  3.73603959e-262,   6.02658058e-154,   6.55490914e-260],</div><div class="line">       [  5.30498948e-313,   3.14673309e-307,   1.00000000e+000]])</div></pre></td></tr></table></figure>
<p>为了创建数字序列，\( NumPy \) 提供了一个和 <code>range</code> 相似的函数，可以返回一个数组而不是列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; np.arange( 10, 30, 5 )</div><div class="line">array([10, 15, 20, 25])</div><div class="line">&gt;&gt;&gt; np.arange( 0, 2, 0.3 )                 # it accepts float arguments</div><div class="line">array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])</div></pre></td></tr></table></figure>
<p>当 <code>arange</code> 的参数是浮点型的，由于有限的浮点精度，通常不太可能去预测获得元素的数量。出于这个原因，通常选择更好的函数 <code>linspace</code>，他接收我们想要的元素数量而不是步长作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from numpy import pi</div><div class="line">&gt;&gt;&gt; np.linspace( 0, 2, 9 )                 # 9 numbers from 0 to 2</div><div class="line">array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])</div><div class="line">&gt;&gt;&gt; x = np.linspace( 0, 2*pi, 100 )        # useful to evaluate function at lots of points</div><div class="line">&gt;&gt;&gt; f = np.sin(x)</div></pre></td></tr></table></figure>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.array.html#numpy.array" target="_blank" rel="external">array</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.zeros.html#numpy.zeros" target="_blank" rel="external">zeros</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.zeros_like.html#numpy.zeros_like" target="_blank" rel="external">zeros_like</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.ones.html#numpy.ones" target="_blank" rel="external">ones</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.ones_like.html#numpy.ones_like" target="_blank" rel="external">ones_like</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.empty.html#numpy.empty" target="_blank" rel="external">empty</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.empty_like.html#numpy.empty_like" target="_blank" rel="external">empty_like</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.arange.html#numpy.arange" target="_blank" rel="external">arange</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.linspace.html#numpy.linspace" target="_blank" rel="external">linspace</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.random.rand.html#numpy.random.rand" target="_blank" rel="external">numpy.random.rand</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.random.randn.html#numpy.random.randn" target="_blank" rel="external">numpy.random.randn</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.fromfunction.html#numpy.fromfunction" target="_blank" rel="external">fromfunction</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.fromfile.html#numpy.fromfile" target="_blank" rel="external">fromfile</a></p>
<h3 id="2-3-打印数组"><a href="#2-3-打印数组" class="headerlink" title="2.3 打印数组"></a>2.3 打印数组</h3><p>当你打印数组时，\( NumPy \) 显示出来和嵌套的列表相似，但是具有以下布局：</p>
<ul>
<li>最后一个 <code>axis</code> 从左到右打印，</li>
<li>第二到最后一个从上到下打印，</li>
<li>剩余的也是从上到下打印，每一片通过一个空行隔开。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(6)                         # 1d array</div><div class="line">&gt;&gt;&gt; print(a)</div><div class="line">[0 1 2 3 4 5]</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; b = np.arange(12).reshape(4,3)           # 2d array</div><div class="line">&gt;&gt;&gt; print(b)</div><div class="line">[[ 0  1  2]</div><div class="line"> [ 3  4  5]</div><div class="line"> [ 6  7  8]</div><div class="line"> [ 9 10 11]]</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; c = np.arange(24).reshape(2,3,4)         # 3d array</div><div class="line">&gt;&gt;&gt; print(c)</div><div class="line">[[[ 0  1  2  3]</div><div class="line">  [ 4  5  6  7]</div><div class="line">  [ 8  9 10 11]]</div><div class="line"> [[12 13 14 15]</div><div class="line">  [16 17 18 19]</div><div class="line">  [20 21 22 23]]]</div></pre></td></tr></table></figure>
<p>参考<a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#quickstart-shape-manipulation" target="_blank" rel="external">下文</a>来获取更多 <code>reshape</code> 的细节。</p>
<p>如果一个数组太大而不能被打印，那么 \( NumPy \) 会自动忽略中间的只打印角上的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(np.arange(10000))</div><div class="line">[   0    1    2 ..., 9997 9998 9999]</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; print(np.arange(10000).reshape(100,100))</div><div class="line">[[   0    1    2 ...,   97   98   99]</div><div class="line"> [ 100  101  102 ...,  197  198  199]</div><div class="line"> [ 200  201  202 ...,  297  298  299]</div><div class="line"> ...,</div><div class="line"> [9700 9701 9702 ..., 9797 9798 9799]</div><div class="line"> [9800 9801 9802 ..., 9897 9898 9899]</div><div class="line"> [9900 9901 9902 ..., 9997 9998 9999]]</div></pre></td></tr></table></figure>
<p>为了取消这种行为，强制 \( NumPy \) 去打印整个数组，你可以通过 <code>set_printoptions</code> 改变打印选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; np.set_printoptions(threshold=&apos;nan&apos;)</div></pre></td></tr></table></figure>
<h3 id="2-4-基本操作"><a href="#2-4-基本操作" class="headerlink" title="2.4 基本操作"></a>2.4 基本操作</h3><p>在数组上的算数运算应用于每个元素。并创建一个用结果填充的新的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.array( [20,30,40,50] )</div><div class="line">&gt;&gt;&gt; b = np.arange( 4 )</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([0, 1, 2, 3])</div><div class="line">&gt;&gt;&gt; c = a-b</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([20, 29, 38, 47])</div><div class="line">&gt;&gt;&gt; b**2</div><div class="line">array([0, 1, 4, 9])</div><div class="line">&gt;&gt;&gt; 10*np.sin(a)</div><div class="line">array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])</div><div class="line">&gt;&gt;&gt; a&lt;35</div><div class="line">array([ True, True, False, False], dtype=bool)</div></pre></td></tr></table></figure>
<p>在 \( NumPy \) 数组的 <code>*</code> 操作不像其他的矩阵语言。矩阵乘法通过 <code>dot</code> 函数进行模拟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; A = np.array( [[1,1],</div><div class="line">...             [0,1]] )</div><div class="line">&gt;&gt;&gt; B = np.array( [[2,0],</div><div class="line">...             [3,4]] )</div><div class="line">&gt;&gt;&gt; A*B                         # elementwise product</div><div class="line">array([[2, 0],</div><div class="line">       [0, 4]])</div><div class="line">&gt;&gt;&gt; A.dot(B)                    # matrix product</div><div class="line">array([[5, 4],</div><div class="line">       [3, 4]])</div><div class="line">&gt;&gt;&gt; np.dot(A, B)                # another matrix product</div><div class="line">array([[5, 4],</div><div class="line">       [3, 4]])</div></pre></td></tr></table></figure>
<p>想 <code>+=</code> 和 <code>*=</code> 操作之类的，直接在原数组上做修改，不会创建新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.ones((2,3), dtype=int)</div><div class="line">&gt;&gt;&gt; b = np.random.random((2,3))</div><div class="line">&gt;&gt;&gt; a *= 3</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[3, 3, 3],</div><div class="line">       [3, 3, 3]])</div><div class="line">&gt;&gt;&gt; b += a</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 3.417022  ,  3.72032449,  3.00011437],</div><div class="line">       [ 3.30233257,  3.14675589,  3.09233859]])</div><div class="line">&gt;&gt;&gt; a += b                  # b is not automatically converted to integer type</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">TypeError: Cannot cast ufunc add output from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) with casting rule &apos;same_kind&apos;</div></pre></td></tr></table></figure>
<p>在不同数组类型之间的操作，结果数组的类型趋于更普通或者更精确的一种（称为向上转型）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.ones(3, dtype=np.int32)</div><div class="line">&gt;&gt;&gt; b = np.linspace(0,pi,3)</div><div class="line">&gt;&gt;&gt; b.dtype.name</div><div class="line">&apos;float64&apos;</div><div class="line">&gt;&gt;&gt; c = a+b</div><div class="line">&gt;&gt;&gt; c</div><div class="line">array([ 1.        ,  2.57079633,  4.14159265])</div><div class="line">&gt;&gt;&gt; c.dtype.name</div><div class="line">&apos;float64&apos;</div><div class="line">&gt;&gt;&gt; d = np.exp(c*1j)</div><div class="line">&gt;&gt;&gt; d</div><div class="line">array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,</div><div class="line">       -0.54030231-0.84147098j])</div><div class="line">&gt;&gt;&gt; d.dtype.name</div><div class="line">&apos;complex128&apos;</div></pre></td></tr></table></figure>
<p>许多类似于求数组所有元素的和的一元操作都是作为 <code>ndarray</code> 类的方法实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.random.random((2,3))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0.18626021,  0.34556073,  0.39676747],</div><div class="line">       [ 0.53881673,  0.41919451,  0.6852195 ]])</div><div class="line">&gt;&gt;&gt; a.sum()</div><div class="line">2.5718191614547998</div><div class="line">&gt;&gt;&gt; a.min()</div><div class="line">0.1862602113776709</div><div class="line">&gt;&gt;&gt; a.max()</div><div class="line">0.6852195003967595</div></pre></td></tr></table></figure>
<p>默认情况下，尽管这些操作是应用于一个数字列表，可以无视它的形状。当时，通过指定 <code>axis</code> 参数可以将操作应用于数组的某一具体 <code>axis</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b = np.arange(12).reshape(3,4)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; b.sum(axis=0)                            # sum of each column</div><div class="line">array([12, 15, 18, 21])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; b.min(axis=1)                            # min of each row</div><div class="line">array([0, 4, 8])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; b.cumsum(axis=1)                         # cumulative sum along each row</div><div class="line">array([[ 0,  1,  3,  6],</div><div class="line">       [ 4,  9, 15, 22],</div><div class="line">       [ 8, 17, 27, 38]])</div></pre></td></tr></table></figure>
<h3 id="2-5-通用功能"><a href="#2-5-通用功能" class="headerlink" title="2.5 通用功能"></a>2.5 通用功能</h3><p>\( NumPy \) 提供了很多数学上的函数，例如 <code>sin</code>、<code>cos</code>、<code>exp</code>。这些被叫做 “universal functions” (<code>ufunc</code>)。在 \( NumPy \）中这些函数是操作数组数字，产生一个数组作为输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; B = np.arange(3)</div><div class="line">&gt;&gt;&gt; B</div><div class="line">array([0, 1, 2])</div><div class="line">&gt;&gt;&gt; np.exp(B)</div><div class="line">array([ 1.        ,  2.71828183,  7.3890561 ])</div><div class="line">&gt;&gt;&gt; np.sqrt(B)</div><div class="line">array([ 0.        ,  1.        ,  1.41421356])</div><div class="line">&gt;&gt;&gt; C = np.array([2., -1., 4.])</div><div class="line">&gt;&gt;&gt; np.add(B, C)</div><div class="line">array([ 2.,  0.,  6.])</div></pre></td></tr></table></figure>
<h5 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h5><p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#universal-functions" target="_blank" rel="external">all, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, std, sum, trace, transpose, var, vdot, vectorize, where</a></p>
<h3 id="2-6-索引，切片和迭代"><a href="#2-6-索引，切片和迭代" class="headerlink" title="2.6 索引，切片和迭代"></a>2.6 索引，切片和迭代</h3><p>一维数组可以被索引，切片和迭代，就像<a href="https://docs.python.org/tutorial/introduction.html#lists" target="_blank" rel="external">列表</a>和其他Python序列一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(10)**3</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])</div><div class="line">&gt;&gt;&gt; a[2]</div><div class="line">8</div><div class="line">&gt;&gt;&gt; a[2:5]</div><div class="line">array([ 8, 27, 64])</div><div class="line">&gt;&gt;&gt; a[:6:2] = -1000    # equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])</div><div class="line">&gt;&gt;&gt; a[ : :-1]                                 # reversed a</div><div class="line">array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])</div><div class="line">&gt;&gt;&gt; for i in a:</div><div class="line">...     print(i**(1/3.))</div><div class="line">...</div><div class="line">nan</div><div class="line">1.0</div><div class="line">nan</div><div class="line">3.0</div><div class="line">nan</div><div class="line">5.0</div><div class="line">6.0</div><div class="line">7.0</div><div class="line">8.0</div><div class="line">9.0</div></pre></td></tr></table></figure>
<p>多维数组对于每个 <code>axis</code> 都有一个索引，这些索引用逗号分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def f(x,y):</div><div class="line">...     return 10*x+y</div><div class="line">...</div><div class="line">&gt;&gt;&gt; b = np.fromfunction(f,(5,4),dtype=int)</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23],</div><div class="line">       [30, 31, 32, 33],</div><div class="line">       [40, 41, 42, 43]])</div><div class="line">&gt;&gt;&gt; b[2,3]</div><div class="line">23</div><div class="line">&gt;&gt;&gt; b[0:5, 1]                       # each row in the second column of b</div><div class="line">array([ 1, 11, 21, 31, 41])</div><div class="line">&gt;&gt;&gt; b[ : ,1]                        # equivalent to the previous example</div><div class="line">array([ 1, 11, 21, 31, 41])</div><div class="line">&gt;&gt;&gt; b[1:3, : ]                      # each column in the second and third row of b</div><div class="line">array([[10, 11, 12, 13],</div><div class="line">       [20, 21, 22, 23]])</div></pre></td></tr></table></figure>
<p>当提供的索引少于 <code>axis</code> 的数量时，缺失的索引按完全切片考虑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; b[-1]                                  # the last row. Equivalent to b[-1,:]</div><div class="line">array([40, 41, 42, 43])</div></pre></td></tr></table></figure>
<p><code>b[i]</code> 这种表达中括号中的 <code>i</code> 后面可以跟很多用 <code>:</code> 表示其它 <code>axis</code> 的实例。\( NumPy \) 也允许使用三个点代替 <code>b[i, ...]</code></p>
<p>这三个点(<code>...</code>)表示很多完整索引元组中的冒号。例如，<code>x</code> 的 <code>rank = 5</code> 有：</p>
<ul>
<li><code>x[1, 2, ...]</code> = <code>x[1, 2, :, :, :]</code></li>
<li><code>x[..., 3]</code> = <code>x[:, :, :, :, 3]</code></li>
<li><code>x[4, ..., 5, :]</code> = <code>x[4, :, :, 5, :]</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = np.array( [[[  0,  1,  2],               # a 3D array (two stacked 2D arrays)</div><div class="line">...                 [ 10, 12, 13]],</div><div class="line">...                [[100,101,102],</div><div class="line">...                 [110,112,113]]])</div><div class="line">&gt;&gt;&gt; c.shape</div><div class="line">(2, 2, 3)</div><div class="line">&gt;&gt;&gt; c[1,...]                                   # same as c[1,:,:] or c[1]</div><div class="line">array([[100, 101, 102],</div><div class="line">       [110, 112, 113]])</div><div class="line">&gt;&gt;&gt; c[...,2]                                   # same as c[:,:,2]</div><div class="line">array([[  2,  13],</div><div class="line">       [102, 113]])</div></pre></td></tr></table></figure>
<p>迭代多维数组是对第一 <code>axis</code> 进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for row in b:</div><div class="line">...     print(row)</div><div class="line">...</div><div class="line">[0 1 2 3]</div><div class="line">[10 11 12 13]</div><div class="line">[20 21 22 23]</div><div class="line">[30 31 32 33]</div><div class="line">[40 41 42 43]</div></pre></td></tr></table></figure>
<p>然而，如果你想模拟对数组中每一个元素的操作，你可以使用 <code>flat</code> 属性，它是一个 <a href="https://docs.python.org/2/tutorial/classes.html#iterators" target="_blank" rel="external">iterator</a>，能够遍历数组中每一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for element in b.flat:</div><div class="line">...     print(element)</div><div class="line">...</div><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td></tr></table></figure>
<h5 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h5><p><a href="https://docs.scipy.org/doc/numpy-dev/user/basics.indexing.html#basics-indexing" target="_blank" rel="external">Indexing</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/arrays.indexing.html#arrays-indexing" target="_blank" rel="external">Indexing</a> (reference), <a href="https://docs.scipy.org/doc/numpy-dev/reference/arrays.indexing.html#numpy.newaxis" target="_blank" rel="external">newaxis</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.ndenumerate.html#numpy.ndenumerate" target="_blank" rel="external">ndenumerate</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.indices.html#numpy.indices" target="_blank" rel="external">indices</a></p>
<h2 id="3-操控形状"><a href="#3-操控形状" class="headerlink" title="3 操控形状"></a>3 操控形状</h2><h3 id="3-1-改变数组的形状"><a href="#3-1-改变数组的形状" class="headerlink" title="3.1 改变数组的形状"></a>3.1 改变数组的形状</h3><p>每一个数组的形状通过每一个 <code>axis</code> 中的元素数量。（其实就是每一个维度的元素多少确定）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.floor(10*np.random.random((3,4)))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 2.,  8.,  0.,  6.],</div><div class="line">       [ 4.,  5.,  1.,  1.],</div><div class="line">       [ 8.,  9.,  3.,  6.]])</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div></pre></td></tr></table></figure>
<p>数组的形状可以通过很多命令来改变，提到这里，接下来的三个例子放回一个被修改的数组，原数组不会改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a.ravel()  # returns the array, flattened</div><div class="line">array([ 2.,  8.,  0.,  6.,  4.,  5.,  1.,  1.,  8.,  9.,  3.,  6.])</div><div class="line">&gt;&gt;&gt; a.reshape(6,2)  # returns the array with a modified shape</div><div class="line">array([[ 2.,  8.],</div><div class="line">       [ 0.,  6.],</div><div class="line">       [ 4.,  5.],</div><div class="line">       [ 1.,  1.],</div><div class="line">       [ 8.,  9.],</div><div class="line">       [ 3.,  6.]])</div><div class="line">&gt;&gt;&gt; a.T  # returns the array, transposed</div><div class="line">array([[ 2.,  4.,  8.],</div><div class="line">       [ 8.,  5.,  9.],</div><div class="line">       [ 0.,  1.,  3.],</div><div class="line">       [ 6.,  1.,  6.]])</div><div class="line">&gt;&gt;&gt; a.T.shape</div><div class="line">(4, 3)</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div></pre></td></tr></table></figure>
<p><code>ravel()</code> 函数中每个元素的位置通常是一种 “C-style” 的，也就是说，最右边的索引改变起来最快。所以元素 <code>a[0, 0]</code> 后面的元素是 <code>a[0, 1]</code>。如果这个数组被塑造成其它形状，这个数组也是作为 “C-style” 对待。\( NumPy \) 通常也是按照这个创建的数组，所以使用 <code>ravel()</code> 函数时不需要复制，但是如果这个数组是通过从另一个数组切片或者其它不同寻常的方式而来的话，它就需要进行复制了。函数 <code>ravel()</code> 和 <code>reshape()</code> 也可以通过可选参数被指定去用 <code>FORTRAN-style</code> 的数组，这这种风格中，最左的索引改变最快。</p>
<p><a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.reshape.html#numpy.reshape" target="_blank" rel="external">reshape</a> 函数返回修改的形状，而 <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.ndarray.resize.html#numpy.ndarray.resize" target="_blank" rel="external">ndarray.resize</a> 方法直接修改数组本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 2.,  8.,  0.,  6.],</div><div class="line">       [ 4.,  5.,  1.,  1.],</div><div class="line">       [ 8.,  9.,  3.,  6.]])</div><div class="line">&gt;&gt;&gt; a.resize((2,6))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 2.,  8.,  0.,  6.,  4.,  5.],</div><div class="line">       [ 1.,  1.,  8.,  9.,  3.,  6.]])</div></pre></td></tr></table></figure>
<p>如果一个维度给一个 \( -1 \) 作为参数，那么其他它维度将自动计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a.reshape(3,-1)</div><div class="line">array([[ 2.,  8.,  0.,  6.],</div><div class="line">       [ 4.,  5.,  1.,  1.],</div><div class="line">       [ 8.,  9.,  3.,  6.]])</div></pre></td></tr></table></figure>
<h5 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h5><p><a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape" target="_blank" rel="external">ndarray.shape</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.reshape.html#numpy.reshape" target="_blank" rel="external">reshape</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.resize.html#numpy.resize" target="_blank" rel="external">resize</a>, <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.ravel.html#numpy.ravel" target="_blank" rel="external">ravel</a></p>
<h3 id="3-2-不同数组的组合"><a href="#3-2-不同数组的组合" class="headerlink" title="3.2 不同数组的组合"></a>3.2 不同数组的组合</h3><p>数组可以通过不同的 <code>axes</code> 组合起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.floor(10*np.random.random((2,2)))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 8.,  8.],</div><div class="line">       [ 0.,  0.]])</div><div class="line">&gt;&gt;&gt; b = np.floor(10*np.random.random((2,2)))</div><div class="line">&gt;&gt;&gt; b</div><div class="line">array([[ 1.,  8.],</div><div class="line">       [ 0.,  4.]])</div><div class="line">&gt;&gt;&gt; np.vstack((a,b))</div><div class="line">array([[ 8.,  8.],</div><div class="line">       [ 0.,  0.],</div><div class="line">       [ 1.,  8.],</div><div class="line">       [ 0.,  4.]])</div><div class="line">&gt;&gt;&gt; np.hstack((a,b))</div><div class="line">array([[ 8.,  8.,  1.,  8.],</div><div class="line">       [ 0.,  0.,  0.,  4.]])</div></pre></td></tr></table></figure>
<p><a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.column_stack.html#numpy.column_stack" target="_blank" rel="external">column_stack</a> 函数可以将 \( 1D \) 数组作为 \( 2D \) 数组的列。当且仅当数组是 \( 1D \) 的时候它等于 <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.vstack.html#numpy.vstack" target="_blank" rel="external">vstack</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from numpy import newaxis</div><div class="line">&gt;&gt;&gt; np.column_stack((a,b))   # With 2D arrays</div><div class="line">array([[ 8.,  8.,  1.,  8.],</div><div class="line">       [ 0.,  0.,  0.,  4.]])</div><div class="line">&gt;&gt;&gt; a = np.array([4.,2.])</div><div class="line">&gt;&gt;&gt; b = np.array([2.,8.])</div><div class="line">&gt;&gt;&gt; a[:,newaxis]  # This allows to have a 2D columns vector</div><div class="line">array([[ 4.],</div><div class="line">       [ 2.]])</div><div class="line">&gt;&gt;&gt; np.column_stack((a[:,newaxis],b[:,newaxis]))</div><div class="line">array([[ 4.,  2.],</div><div class="line">       [ 2.,  8.]])</div><div class="line">&gt;&gt;&gt; np.vstack((a[:,newaxis],b[:,newaxis])) # The behavior of vstack is different</div><div class="line">array([[ 4.],</div><div class="line">       [ 2.],</div><div class="line">       [ 2.],</div><div class="line">       [ 8.]])</div></pre></td></tr></table></figure>
<p>对于超过两个维度的数组，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.hstack.html#numpy.hstack" target="_blank" rel="external">hstack</a> 会沿着第二个 <code>axis</code> 堆积，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.vstack.html#numpy.vstack" target="_blank" rel="external">vstack</a> 沿着第一个 <code>axes</code> 堆积，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.concatenate.html#numpy.concatenate" target="_blank" rel="external">concatenate</a> 允许一个可选参数选择哪一个 <code>axis</code> 发生连接操作。</p>
<h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>在复杂情况下，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.r_.html#numpy.r_" target="_blank" rel="external">r_</a> 和 <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.c_.html#numpy.c_" target="_blank" rel="external">c_</a> 对于通过沿一个 <code>axis</code> 堆积数字来创建数组很有用。它们允许使用范围表示符号（“:”）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; np.r_[1:4,0,4]</div><div class="line">array([1, 2, 3, 0, 4])</div></pre></td></tr></table></figure>
<p>当使用数组作为参数时，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.r_.html#numpy.r_" target="_blank" rel="external">r_</a> 与 <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.c_.html#numpy.c_" target="_blank" rel="external">c_</a> 在默认行为是和 <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.vstack.html#numpy.vstack" target="_blank" rel="external">vstack</a> 与 <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.hstack.html#numpy.hstack" target="_blank" rel="external">hstack</a> 相似的，但是它们允许可选参数给出 <code>axis</code> 来连接。</p>
<h5 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h5><p><a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.hstack.html#numpy.hstack" target="_blank" rel="external">hstack</a>，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.vstack.html#numpy.vstack" target="_blank" rel="external">vstack</a>，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.column_stack.html#numpy.column_stack" target="_blank" rel="external">column_stack</a>，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.concatenate.html#numpy.concatenate" target="_blank" rel="external">concatenate</a>，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.c_.html#numpy.c_" target="_blank" rel="external">c_</a>，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.r_.html#numpy.r_" target="_blank" rel="external">r_</a></p>
<h3 id="3-3-将数组分割成几个小数组"><a href="#3-3-将数组分割成几个小数组" class="headerlink" title="3.3 将数组分割成几个小数组"></a>3.3 将数组分割成几个小数组</h3><p>使用 <a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.hsplit.html#numpy.hsplit" target="_blank" rel="external">hsplit</a>，你能沿着它的水平 <code>axis</code> 分割，可以通过指定数组形状来返回，也可以指定哪个列应该拆分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.floor(10*np.random.random((2,12)))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 9.,  5.,  6.,  3.,  6.,  8.,  0.,  7.,  9.,  7.,  2.,  7.],</div><div class="line">       [ 1.,  4.,  9.,  2.,  2.,  1.,  0.,  6.,  2.,  2.,  4.,  0.]])</div><div class="line">&gt;&gt;&gt; np.hsplit(a,3)   # Split a into 3</div><div class="line">[array([[ 9.,  5.,  6.,  3.],</div><div class="line">       [ 1.,  4.,  9.,  2.]]), array([[ 6.,  8.,  0.,  7.],</div><div class="line">       [ 2.,  1.,  0.,  6.]]), array([[ 9.,  7.,  2.,  7.],</div><div class="line">       [ 2.,  2.,  4.,  0.]])]</div><div class="line">&gt;&gt;&gt; np.hsplit(a,(3,4))   # Split a after the third and the fourth column</div><div class="line">[array([[ 9.,  5.,  6.],</div><div class="line">       [ 1.,  4.,  9.]]), array([[ 3.],</div><div class="line">       [ 2.]]), array([[ 6.,  8.,  0.,  7.,  9.,  7.,  2.,  7.],</div><div class="line">       [ 2.,  1.,  0.,  6.,  2.,  2.,  4.,  0.]])]</div></pre></td></tr></table></figure>
<p><a href="">vplit</a> 沿着竖直的 <code>axis</code> 分割，<a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.array_split.html#numpy.array_split" target="_blank" rel="external">array_split</a> 允许通过指定哪个 <code>axis</code> 去分割。</p>
<h2 id="4-拷贝和-Views"><a href="#4-拷贝和-Views" class="headerlink" title="4 拷贝和 Views"></a>4 拷贝和 Views</h2><p>在操作数组的时候，它们的数据有时候拷贝进一个新的数组，有时候又不是。这经常是初学者感到困惑。下面有三种情况：</p>
<h3 id="4-1-不拷贝"><a href="#4-1-不拷贝" class="headerlink" title="4.1 不拷贝"></a>4.1 不拷贝</h3><p>简单的赋值不会拷贝任何数组对象和它们的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(12)</div><div class="line">&gt;&gt;&gt; b = a            # no new object is created</div><div class="line">&gt;&gt;&gt; b is a           # a and b are two names for the same ndarray object</div><div class="line">True</div><div class="line">&gt;&gt;&gt; b.shape = 3,4    # changes the shape of a</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div></pre></td></tr></table></figure>
<p>\( Python \) 将可变对象作为引用传递，所以函数调用不会产生拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def f(x):</div><div class="line">...     print(id(x))</div><div class="line">...</div><div class="line">&gt;&gt;&gt; id(a)                           # id is a unique identifier of an object</div><div class="line">148293216</div><div class="line">&gt;&gt;&gt; f(a)</div><div class="line">148293216</div></pre></td></tr></table></figure>
<h3 id="4-2-View-或者浅拷贝"><a href="#4-2-View-或者浅拷贝" class="headerlink" title="4.2 View 或者浅拷贝"></a>4.2 View 或者浅拷贝</h3><p>不同的数组对象可以分享相同的数据。<code>view</code> 方法创建了一个相同数据的新数组对象。<br>PS：这里 View（视图？） 不知道如何理解好，所以保留。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c = a.view()</div><div class="line">&gt;&gt;&gt; c is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; c.base is a                        # c is a view of the data owned by a</div><div class="line">True</div><div class="line">&gt;&gt;&gt; c.flags.owndata</div><div class="line">False</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; c.shape = 2,6                      # a&apos;s shape doesn&apos;t change</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(3, 4)</div><div class="line">&gt;&gt;&gt; c[0,4] = 1234                      # a&apos;s data changes</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[   0,    1,    2,    3],</div><div class="line">       [1234,    5,    6,    7],</div><div class="line">       [   8,    9,   10,   11]])</div></pre></td></tr></table></figure>
<p>切片数组返回一个 <code>view</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = a[ : , 1:3]     # spaces added for clarity; could also be written &quot;s = a[:,1:3]&quot;</div><div class="line">&gt;&gt;&gt; s[:] = 10           # s[:] is a view of s. Note the difference between s=10 and s[:]=10</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[   0,   10,   10,    3],</div><div class="line">       [1234,   10,   10,    7],</div><div class="line">       [   8,   10,   10,   11]])</div></pre></td></tr></table></figure>
<h3 id="4-3-深拷贝"><a href="#4-3-深拷贝" class="headerlink" title="4.3 深拷贝"></a>4.3 深拷贝</h3><p><code>copy</code> 方法完全拷贝数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = a.copy()                          # a new array object with new data is created</div><div class="line">&gt;&gt;&gt; d is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; d.base is a                           # d doesn&apos;t share anything with a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; d[0,0] = 9999</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[   0,   10,   10,    3],</div><div class="line">       [1234,   10,   10,    7],</div><div class="line">       [   8,   10,   10,   11]])</div></pre></td></tr></table></figure>
<h3 id="4-4-函数和方法综述"><a href="#4-4-函数和方法综述" class="headerlink" title="4.4 函数和方法综述"></a>4.4 函数和方法综述</h3><p>这里通过类别排序列举一些有用的 \( NumPy \) 函数和方法。拆看完整列表点击<a href="https://docs.scipy.org/doc/numpy-dev/reference/routines.html#routines" target="_blank" rel="external">Routines</a></p>
<h5 id="数组收集"><a href="#数组收集" class="headerlink" title="数组收集"></a>数组收集</h5><blockquote>
<p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#functions-and-methods-overview" target="_blank" rel="external">arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r, zeros, zeros_like</a></p>
</blockquote>
<h5 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h5><blockquote>
<p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#functions-and-methods-overview" target="_blank" rel="external">ndarray.astype, atleast_1d, atleast_2d, atleast_3d, mat</a></p>
</blockquote>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><blockquote>
<p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#functions-and-methods-overview" target="_blank" rel="external">array_split, column_stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, ndarray.item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</a></p>
</blockquote>
<h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><blockquote>
<p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#functions-and-methods-overview" target="_blank" rel="external">all, any, nonzero, where</a></p>
</blockquote>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><blockquote>
<p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#functions-and-methods-overview" target="_blank" rel="external">argmax, argmin, argsort, max, min, ptp, searchsorted, sort</a></p>
</blockquote>
<h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><blockquote>
<p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#functions-and-methods-overview" target="_blank" rel="external">choose, compress, cumprod, cumsum, inner, ndarray.fill, imag, prod, put, putmask, real, sum</a></p>
</blockquote>
<h5 id="基本统计"><a href="#基本统计" class="headerlink" title="基本统计"></a>基本统计</h5><blockquote>
<p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#functions-and-methods-overview" target="_blank" rel="external">cov, mean, std, var</a></p>
</blockquote>
<h5 id="基本线性代数"><a href="#基本线性代数" class="headerlink" title="基本线性代数"></a>基本线性代数</h5><blockquote>
<p><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html#functions-and-methods-overview" target="_blank" rel="external">cross, dot, outer, linalg.svd, vdot</a></p>
</blockquote>
<h2 id="5-Less-Basic"><a href="#5-Less-Basic" class="headerlink" title="5 Less Basic"></a>5 Less Basic</h2><h3 id="5-1-广播规则"><a href="#5-1-广播规则" class="headerlink" title="5.1 广播规则"></a>5.1 广播规则</h3><p>广播允许通用功能用一种有意义的方式去处理不完全相同的形状输入。<br>第一条广播规则是如果所有输入的数组都没有相同的维度数字，那么将会重复地用 \( 1 \) 去加在较小的数组形状上直到所有的数组有相同的维度数字。<br>第二条广播规则是确保沿着特定维度大小为 \( 1 \) 的数组就像沿着这个维度最大维数大小一样的，假设数组元素的值在广播数组的维度是相同的。<br>应用广播规则后，所有数组大小不必须匹配。更多细节可以在<a href="https://docs.scipy.org/doc/numpy-dev/user/basics.broadcasting.html" target="_blank" rel="external">Broadcasting</a>。</p>
<ul>
<li><a href="http://blog.csdn.net/yangnanhai93/article/details/50127747" target="_blank" rel="external">Numpy中的广播(Broadcasting)</a></li>
</ul>
<h2 id="6-花式索引和索引技巧"><a href="#6-花式索引和索引技巧" class="headerlink" title="6 花式索引和索引技巧"></a>6 花式索引和索引技巧</h2><p>\( NumPy \) 提供了比 \(  Python \) 序列更多的索引功能。除了我们之前看到的通过整数和切片索引之外，数组可以通过整数数组和布尔数组索引。</p>
<h3 id="6-1-用索引数组索引"><a href="#6-1-用索引数组索引" class="headerlink" title="6.1 用索引数组索引"></a>6.1 用索引数组索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(12)**2                       # the first 12 square numbers</div><div class="line">&gt;&gt;&gt; i = np.array( [ 1,1,3,8,5 ] )              # an array of indices</div><div class="line">&gt;&gt;&gt; a[i]                                       # the elements of a at the positions i</div><div class="line">array([ 1,  1,  9, 64, 25])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; j = np.array( [ [ 3, 4], [ 9, 7 ] ] )      # a bidimensional array of indices</div><div class="line">&gt;&gt;&gt; a[j]                                       # the same shape as j</div><div class="line">array([[ 9, 16],</div><div class="line">       [81, 49]])</div></pre></td></tr></table></figure>
<p>当数组 <code>a</code> 是多维的，单个数组指向数组 <code>a</code> 的第一维。以下示例通过使用调色板将标签图像转换为彩色图像来显示此行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; palette = np.array( [ [0,0,0],                # black</div><div class="line">...                       [255,0,0],              # red</div><div class="line">...                       [0,255,0],              # green</div><div class="line">...                       [0,0,255],              # blue</div><div class="line">...                       [255,255,255] ] )       # white</div><div class="line">&gt;&gt;&gt; image = np.array( [ [ 0, 1, 2, 0 ],           # each value corresponds to a color in the palette</div><div class="line">...                     [ 0, 3, 4, 0 ]  ] )</div><div class="line">&gt;&gt;&gt; palette[image]                            # the (2,4,3) color image</div><div class="line">array([[[  0,   0,   0],</div><div class="line">        [255,   0,   0],</div><div class="line">        [  0, 255,   0],</div><div class="line">        [  0,   0,   0]],</div><div class="line">       [[  0,   0,   0],</div><div class="line">        [  0,   0, 255],</div><div class="line">        [255, 255, 255],</div><div class="line">        [  0,   0,   0]]])</div></pre></td></tr></table></figure>
<p>我们可以给超过一维的索引。数组每个维度的索引形状必须一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(12).reshape(3,4)</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[ 0,  1,  2,  3],</div><div class="line">       [ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt; i = np.array( [ [0,1],                        # indices for the first dim of a</div><div class="line">...                 [1,2] ] )</div><div class="line">&gt;&gt;&gt; j = np.array( [ [2,1],                        # indices for the second dim</div><div class="line">...                 [3,3] ] )</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; a[i,j]                                     # i and j must have equal shape</div><div class="line">array([[ 2,  5],</div><div class="line">       [ 7, 11]])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; a[i,2]</div><div class="line">array([[ 2,  6],</div><div class="line">       [ 6, 10]])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; a[:,j]                                     # i.e., a[ : , j]</div><div class="line">array([[[ 2,  1],</div><div class="line">        [ 3,  3]],</div><div class="line">       [[ 6,  5],</div><div class="line">        [ 7,  7]],</div><div class="line">       [[10,  9],</div><div class="line">        [11, 11]]])</div></pre></td></tr></table></figure>
<p>当然，我们可以把 <code>i</code>, <code>j</code> 放进一个序列然后对这个列表进行索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; l = [i,j]</div><div class="line">&gt;&gt;&gt; a[l]                                       # equivalent to a[i,j]</div><div class="line">array([[ 2,  5],</div><div class="line">       [ 7, 11]])</div></pre></td></tr></table></figure>
<p>然而，我们可以直接把 <code>i</code>，<code>j</code> 放进数组中，因为这个数组将会被解释成 <code>a</code> 第一维的索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = np.array( [i,j] )</div><div class="line">&gt;&gt;&gt; a[s]                                       # not what we want</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</div><div class="line">IndexError: index (3) out of range (0&lt;=index&lt;=2) in dimension 0</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; a[tuple(s)]                                # same as a[i,j]</div><div class="line">array([[ 2,  5],</div><div class="line">       [ 7, 11]])</div></pre></td></tr></table></figure>
<p>另一个常用数组索引是查询时间相关系列的最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; time = np.linspace(20, 145, 5)                 # time scale</div><div class="line">&gt;&gt;&gt; data = np.sin(np.arange(20)).reshape(5,4)      # 4 time-dependent series</div><div class="line">&gt;&gt;&gt; time</div><div class="line">array([  20.  ,   51.25,   82.5 ,  113.75,  145.  ])</div><div class="line">&gt;&gt;&gt; data</div><div class="line">array([[ 0.        ,  0.84147098,  0.90929743,  0.14112001],</div><div class="line">       [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],</div><div class="line">       [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],</div><div class="line">       [-0.53657292,  0.42016704,  0.99060736,  0.65028784],</div><div class="line">       [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; ind = data.argmax(axis=0)                   # index of the maxima for each series</div><div class="line">&gt;&gt;&gt; ind</div><div class="line">array([2, 0, 3, 1])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; time_max = time[ ind]                       # times corresponding to the maxima</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; data_max = data[ind, xrange(data.shape[1])] # =&gt; data[ind[0],0], data[ind[1],1]...</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; time_max</div><div class="line">array([  82.5 ,   20.  ,  113.75,   51.25])</div><div class="line">&gt;&gt;&gt; data_max</div><div class="line">array([ 0.98935825,  0.84147098,  0.99060736,  0.6569866 ])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; np.all(data_max == data.max(axis=0))</div><div class="line">True</div></pre></td></tr></table></figure>
<p>你也可以使用数组索引对数组进行赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(5)</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 1, 2, 3, 4])</div><div class="line">&gt;&gt;&gt; a[[1,3,4]] = 0</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([0, 0, 2, 0, 0])</div></pre></td></tr></table></figure>
<p>然而，当你的列表索引包含重复，这个赋值会发生几次，保留最后一个数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(5)</div><div class="line">&gt;&gt;&gt; a[[0,0,2]]=[1,2,3]</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([2, 1, 3, 3, 4])</div></pre></td></tr></table></figure>
<p>这足够合理，但是如果你想使用 \( Python \) 的 <code>+=</code> 结构时要小心，它可能不像你期待的一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(5)</div><div class="line">&gt;&gt;&gt; a[[0,0,2]]+=1</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([1, 1, 3, 3, 4])</div></pre></td></tr></table></figure>
<p>即使 \( 0 \) 在列表中出现了两次，这第 \( 0 \) 个元素也只增加一次。这是因为  \( Python \) 把 “a+=1” 等价于 “a=a+1”。</p>
<h3 id="6-2-用布尔数组索引"><a href="#6-2-用布尔数组索引" class="headerlink" title="6.2 用布尔数组索引"></a>6.2 用布尔数组索引</h3><p>当我们用整数数组去索引数组时，我们提供了索引列表去挑选。用布尔索引的方法是不用的；我们明确的在数组中选择哪个我们想要哪个我们不想要。<br>最自然能想到的方法是用和原数组一样形状的布尔数组进行布尔索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(12).reshape(3,4)</div><div class="line">&gt;&gt;&gt; b = a &gt; 4</div><div class="line">&gt;&gt;&gt; b                                          # b is a boolean with a&apos;s shape</div><div class="line">array([[False, False, False, False],</div><div class="line">       [False,  True,  True,  True],</div><div class="line">       [ True,  True,  True,  True]], dtype=bool)</div><div class="line">&gt;&gt;&gt; a[b]                                       # 1d array with the selected elements</div><div class="line">array([ 5,  6,  7,  8,  9, 10, 11])</div></pre></td></tr></table></figure>
<p>这个属性在复制时非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a[b] = 0                                   # All elements of &apos;a&apos; higher than 4 become 0</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[0, 1, 2, 3],</div><div class="line">       [4, 0, 0, 0],</div><div class="line">       [0, 0, 0, 0]])</div></pre></td></tr></table></figure>
<p>你可以看接下来的例子去了解如何使用布尔索引去生成 <a href="http://en.wikipedia.org/wiki/Mandelbrot_set" target="_blank" rel="external">Mandelbrot set</a> 图像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import numpy as np</div><div class="line">&gt;&gt;&gt; import matplotlib.pyplot as plt</div><div class="line">&gt;&gt;&gt; def mandelbrot( h,w, maxit=20 ):</div><div class="line">...     &quot;&quot;&quot;Returns an image of the Mandelbrot fractal of size (h,w).&quot;&quot;&quot;</div><div class="line">...     y,x = np.ogrid[ -1.4:1.4:h*1j, -2:0.8:w*1j ]</div><div class="line">...     c = x+y*1j</div><div class="line">...     z = c</div><div class="line">...     divtime = maxit + np.zeros(z.shape, dtype=int)</div><div class="line">...</div><div class="line">...     for i in range(maxit):</div><div class="line">...         z = z**2 + c</div><div class="line">...         diverge = z*np.conj(z) &gt; 2**2            # who is diverging</div><div class="line">...         div_now = diverge &amp; (divtime==maxit)  # who is diverging now</div><div class="line">...         divtime[div_now] = i                  # note when</div><div class="line">...         z[diverge] = 2                        # avoid diverging too much</div><div class="line">...</div><div class="line">...     return divtime</div><div class="line">&gt;&gt;&gt; plt.imshow(mandelbrot(400,400))</div><div class="line">&gt;&gt;&gt; plt.show()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mandelbrot</span><span class="params">(h, w, maxit=<span class="number">20</span>)</span>:</span></div><div class="line">    y, x = np.ogrid[<span class="number">-1.4</span>:<span class="number">1.4</span>:h * <span class="number">1j</span>, <span class="number">-2</span>:<span class="number">0.8</span>:w * <span class="number">1j</span>]</div><div class="line">    c = x + y * <span class="number">1j</span></div><div class="line">    z = c</div><div class="line">    divtime = maxit + np.zeros(z.shape, dtype=int)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(maxit):</div><div class="line">        z = z ** <span class="number">2</span> + c</div><div class="line">        diverge = z * np.conj(z) &gt; <span class="number">2</span> ** <span class="number">2</span>  <span class="comment"># who is diverging</span></div><div class="line">        div_now = diverge &amp; (divtime == maxit)  <span class="comment"># who is diverging now</span></div><div class="line">        divtime[div_now] = i  <span class="comment"># note when</span></div><div class="line">        z[diverge] = <span class="number">2</span>  <span class="comment"># avoid diverging too much</span></div><div class="line">    <span class="keyword">return</span> divtime</div><div class="line"></div><div class="line">plt.imshow(mandelbrot(<span class="number">400</span>, <span class="number">400</span>))</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/04/NumPyOfficialQuickstartTutorial/6_2_01.png" alt=""></p>
<p>第二种用布尔索引方法更像是整数索引，对于每个数组的维度，我们给一个 \( 1D \) 的布尔数组去选择我们想要的切片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(12).reshape(3,4)</div><div class="line">&gt;&gt;&gt; b1 = np.array([False,True,True])             # first dim selection</div><div class="line">&gt;&gt;&gt; b2 = np.array([True,False,True,False])       # second dim selection</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; a[b1,:]                                   # selecting rows</div><div class="line">array([[ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; a[b1]                                     # same thing</div><div class="line">array([[ 4,  5,  6,  7],</div><div class="line">       [ 8,  9, 10, 11]])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; a[:,b2]                                   # selecting columns</div><div class="line">array([[ 0,  2],</div><div class="line">       [ 4,  6],</div><div class="line">       [ 8, 10]])</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; a[b1,b2]                                  # a weird thing to do</div><div class="line">array([ 4, 10])</div></pre></td></tr></table></figure>
<p>请注意，\( 1D \) 布尔数组的长度必须与你要切片的维度（或<code>axis</code>）的长度一致。在之前的例子中，<code>b1</code> 是一个长度为 \( 3 \)（<code>a</code> 的行数） 的 <code>1-rank</code> 数组，<code>b2</code> （长度为 \( 4 \)）是一个适合去索引 <code>a</code> 的第二 <code>rank</code> (列)。</p>
<h3 id="6-3-ix-函数"><a href="#6-3-ix-函数" class="headerlink" title="6.3 ix_() 函数"></a>6.3 ix_() 函数</h3><p><a href="https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.ix_.html#numpy.ix_" target="_blank" rel="external">ix_</a> 可以组合不同向量去获得对于每一个 <code>n-uplet</code> 的结果。例如，如果你想从每个 \( a, b, c \) 向量中取得三元组去计算所有的 \( a+b*c \) ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.array([2,3,4,5])</div><div class="line">&gt;&gt;&gt; b = np.array([8,5,4])</div><div class="line">&gt;&gt;&gt; c = np.array([5,4,6,8,3])</div><div class="line">&gt;&gt;&gt; ax,bx,cx = np.ix_(a,b,c)</div><div class="line">&gt;&gt;&gt; ax</div><div class="line">array([[[2]],</div><div class="line">       [[3]],</div><div class="line">       [[4]],</div><div class="line">       [[5]]])</div><div class="line">&gt;&gt;&gt; bx</div><div class="line">array([[[8],</div><div class="line">        [5],</div><div class="line">        [4]]])</div><div class="line">&gt;&gt;&gt; cx</div><div class="line">array([[[5, 4, 6, 8, 3]]])</div><div class="line">&gt;&gt;&gt; ax.shape, bx.shape, cx.shape</div><div class="line">((4, 1, 1), (1, 3, 1), (1, 1, 5))</div><div class="line">&gt;&gt;&gt; result = ax+bx*cx</div><div class="line">&gt;&gt;&gt; result</div><div class="line">array([[[42, 34, 50, 66, 26],</div><div class="line">        [27, 22, 32, 42, 17],</div><div class="line">        [22, 18, 26, 34, 14]],</div><div class="line">       [[43, 35, 51, 67, 27],</div><div class="line">        [28, 23, 33, 43, 18],</div><div class="line">        [23, 19, 27, 35, 15]],</div><div class="line">       [[44, 36, 52, 68, 28],</div><div class="line">        [29, 24, 34, 44, 19],</div><div class="line">        [24, 20, 28, 36, 16]],</div><div class="line">       [[45, 37, 53, 69, 29],</div><div class="line">        [30, 25, 35, 45, 20],</div><div class="line">        [25, 21, 29, 37, 17]]])</div><div class="line">&gt;&gt;&gt; result[3,2,4]</div><div class="line">17</div><div class="line">&gt;&gt;&gt; a[3]+b[2]*c[4]</div><div class="line">17</div></pre></td></tr></table></figure>
<p>你也可以按以下方式实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; def ufunc_reduce(ufct, *vectors):</div><div class="line">...    vs = np.ix_(*vectors)</div><div class="line">...    r = ufct.identity</div><div class="line">...    for v in vs:</div><div class="line">...        r = ufct(r,v)</div><div class="line">...    return r</div></pre></td></tr></table></figure>
<p>然后这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; ufunc_reduce(np.add,a,b,c)</div><div class="line">array([[[15, 14, 16, 18, 13],</div><div class="line">        [12, 11, 13, 15, 10],</div><div class="line">        [11, 10, 12, 14,  9]],</div><div class="line">       [[16, 15, 17, 19, 14],</div><div class="line">        [13, 12, 14, 16, 11],</div><div class="line">        [12, 11, 13, 15, 10]],</div><div class="line">       [[17, 16, 18, 20, 15],</div><div class="line">        [14, 13, 15, 17, 12],</div><div class="line">        [13, 12, 14, 16, 11]],</div><div class="line">       [[18, 17, 19, 21, 16],</div><div class="line">        [15, 14, 16, 18, 13],</div><div class="line">        [14, 13, 15, 17, 12]]])</div></pre></td></tr></table></figure>
<p>这个版本的比通常的 <code>ufunc.reduce</code> 好在它使用了<a href="https://docs.scipy.org/doc/numpy-dev/user/Tentative_NumPy_Tutorial.html#head-c43f3f81719d84f09ae2b33a22eaf50b26333db8" target="_blank" rel="external">Broadcasting Rules</a> 规则去避免创建一个大小是输出乘以矢量数量数组。</p>
<h3 id="6-4-使用字符串索引"><a href="#6-4-使用字符串索引" class="headerlink" title="6.4 使用字符串索引"></a>6.4 使用字符串索引</h3><p>参考<a href="https://docs.scipy.org/doc/numpy-dev/user/basics.rec.html#structured-arrays" target="_blank" rel="external">Structured arrays</a></p>
<h2 id="7-线性代数"><a href="#7-线性代数" class="headerlink" title="7 线性代数"></a>7 线性代数</h2><p>工作进行中，基本的线性代数包含在其中。</p>
<h3 id="7-1-简单的数组操作"><a href="#7-1-简单的数组操作" class="headerlink" title="7.1 简单的数组操作"></a>7.1 简单的数组操作</h3><p>看\( NumPy \) 文件夹下的 \( linalg.py \) 文件了解更多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import numpy as np</div><div class="line">&gt;&gt;&gt; a = np.array([[1.0, 2.0], [3.0, 4.0]])</div><div class="line">&gt;&gt;&gt; print(a)</div><div class="line">[[ 1.  2.]</div><div class="line"> [ 3.  4.]]</div><div class="line"></div><div class="line">&gt;&gt;&gt; a.transpose()</div><div class="line">array([[ 1.,  3.],</div><div class="line">       [ 2.,  4.]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; np.linalg.inv(a)</div><div class="line">array([[-2. ,  1. ],</div><div class="line">       [ 1.5, -0.5]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; u = np.eye(2) # unit 2x2 matrix; &quot;eye&quot; represents &quot;I&quot;</div><div class="line">&gt;&gt;&gt; u</div><div class="line">array([[ 1.,  0.],</div><div class="line">       [ 0.,  1.]])</div><div class="line">&gt;&gt;&gt; j = np.array([[0.0, -1.0], [1.0, 0.0]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; np.dot (j, j) # matrix product</div><div class="line">array([[-1.,  0.],</div><div class="line">       [ 0., -1.]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; np.trace(u)  # trace</div><div class="line">2.0</div><div class="line"></div><div class="line">&gt;&gt;&gt; y = np.array([[5.], [7.]])</div><div class="line">&gt;&gt;&gt; np.linalg.solve(a, y)</div><div class="line">array([[-3.],</div><div class="line">       [ 4.]])</div><div class="line"></div><div class="line">&gt;&gt;&gt; np.linalg.eig(j)</div><div class="line">(array([ 0.+1.j,  0.-1.j]), array([[ 0.70710678+0.j        ,  0.70710678-0.j        ],</div><div class="line">       [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]]))</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Parameters:</div><div class="line">    square matrix</div><div class="line">Returns</div><div class="line">    The eigenvalues, each repeated according to its multiplicity.</div><div class="line">    The normalized (unit &quot;length&quot;) eigenvectors, such that the</div><div class="line">    column ``v[:,i]`` is the eigenvector corresponding to the</div><div class="line">    eigenvalue ``w[i]`` .</div></pre></td></tr></table></figure>
<h2 id="8-技巧和提示"><a href="#8-技巧和提示" class="headerlink" title="8 技巧和提示"></a>8 技巧和提示</h2><p>这里我们给出一些有用的小技巧。</p>
<h3 id="8-1-“自动塑形”"><a href="#8-1-“自动塑形”" class="headerlink" title="8.1 “自动塑形”"></a>8.1 “自动塑形”</h3><p>为了改变数组的维度，你可以省略一个可以自动被推算出来的大小的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = np.arange(30)</div><div class="line">&gt;&gt;&gt; a.shape = 2,-1,3  # -1 means &quot;whatever is needed&quot;</div><div class="line">&gt;&gt;&gt; a.shape</div><div class="line">(2, 5, 3)</div><div class="line">&gt;&gt;&gt; a</div><div class="line">array([[[ 0,  1,  2],</div><div class="line">        [ 3,  4,  5],</div><div class="line">        [ 6,  7,  8],</div><div class="line">        [ 9, 10, 11],</div><div class="line">        [12, 13, 14]],</div><div class="line">       [[15, 16, 17],</div><div class="line">        [18, 19, 20],</div><div class="line">        [21, 22, 23],</div><div class="line">        [24, 25, 26],</div><div class="line">        [27, 28, 29]]])</div></pre></td></tr></table></figure>
<h3 id="8-2-矢量叠加"><a href="#8-2-矢量叠加" class="headerlink" title="8.2 矢量叠加"></a>8.2 矢量叠加</h3><p>我们怎么从一个相同大小的行向量构造出一个 \( 2D \) 数组？在 \( MATLAB \)中是相当简单的：如果 <code>x</code> 和 <code>y</code> 是两个相同长度的向量，你只需要把 <code>m=[x;y]</code>。在 \( NumPy \) 中，通过函数 <code>column_stack</code>，<code>dstack</code>，<code>hstack</code> 和 <code>vstack</code> 实现，这取决于所要叠加的维度。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = np.arange(0,10,2)                     # x=([0,2,4,6,8])</div><div class="line">y = np.arange(5)                          # y=([0,1,2,3,4])</div><div class="line">m = np.vstack([x,y])                      # m=([[0,2,4,6,8],</div><div class="line">                                          #     [0,1,2,3,4]])</div><div class="line">xy = np.hstack([x,y])                     # xy =([0,2,4,6,8,0,1,2,3,4])</div></pre></td></tr></table></figure>
<p>在超过两个维度时这些函数背后的逻辑是奇怪的。</p>
<h5 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h5><p><a href="https://docs.scipy.org/doc/numpy-dev/user/numpy-for-matlab-users.html" target="_blank" rel="external">NumPy for Matlab users</a></p>
<h3 id="8-3-柱状图"><a href="#8-3-柱状图" class="headerlink" title="8.3 柱状图"></a>8.3 柱状图</h3><p>\( NumPy \) 的 <code>histogram</code> 函数应用于数组，返回一对矢量：数组的柱状图和 <code>bins</code> 矢量。当心：<code>matplotlib</code> 也有一个函数去构建柱状图（叫做 <code>hist</code>，同样在 \( Matlab \) 中），这个和 \( NumPy \) 还是不一样的。主要的区别是 <code>pylab.hist</code> 自动绘制柱状图而 <code>matplotlib</code> 只是生成数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import numpy as np</div><div class="line">&gt;&gt;&gt; import matplotlib.pyplot as plt</div><div class="line">&gt;&gt;&gt; # Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2</div><div class="line">&gt;&gt;&gt; mu, sigma = 2, 0.5</div><div class="line">&gt;&gt;&gt; v = np.random.normal(mu,sigma,10000)</div><div class="line">&gt;&gt;&gt; # Plot a normalized histogram with 50 bins</div><div class="line">&gt;&gt;&gt; plt.hist(v, bins=50, normed=1)       # matplotlib version (plot)</div><div class="line">&gt;&gt;&gt; plt.show()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line"># Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2</div><div class="line">mu, sigma = 2, 0.5</div><div class="line">v = np.random.normal(mu, sigma, 10000)</div><div class="line"># Plot a normalized histogram with 50 bins</div><div class="line">plt.hist(v, bins=50, normed=1)  # matplotlib version (plot)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/04/NumPyOfficialQuickstartTutorial/8_3_01.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; # Compute the histogram with numpy and then plot it</div><div class="line">&gt;&gt;&gt; (n, bins) = np.histogram(v, bins=50, normed=True)  # NumPy version (no plot)</div><div class="line">&gt;&gt;&gt; plt.plot(.5*(bins[1:]+bins[:-1]), n)</div><div class="line">&gt;&gt;&gt; plt.show()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line"># Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2</div><div class="line">mu, sigma = 2, 0.5</div><div class="line">v = np.random.normal(mu, sigma, 10000)</div><div class="line"># Compute the histogram with numpy and then plot it</div><div class="line">(n, bins) = np.histogram(v, bins=50, normed=True)  # NumPy version (no plot)</div><div class="line">plt.plot(.5 * (bins[1:] + bins[:-1]), n)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2018/02/04/NumPyOfficialQuickstartTutorial/8_3_02.png" alt=""></p>
<h2 id="9-更多阅读"><a href="#9-更多阅读" class="headerlink" title="9 更多阅读"></a>9 更多阅读</h2><ul>
<li>The <a href="http://docs.python.org/tutorial/" target="_blank" rel="external">Python tutorial</a></li>
<li><a href="https://docs.scipy.org/doc/numpy-dev/reference/index.html#reference" target="_blank" rel="external">NumPy Reference</a></li>
<li><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/index.html" target="_blank" rel="external">SciPy Tutorial</a></li>
<li><a href="http://www.scipy-lectures.org/" target="_blank" rel="external">SciPy Lecture Notes</a></li>
<li>A <a href="http://mathesaurus.sf.net/" target="_blank" rel="external">matlab, R, IDL, NumPy/SciPy dictionary</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;写在前面：本来是学习下 \( NumPy \)，看到官网的&lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/user/quickstart.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;入门教程&lt;/a&gt;想跟着实验一下，怕不常用，而我这人健忘，所以记录下来。索性就照着翻译一下，同样可以提升自己的阅读和写作能力，需要的可以存一下。当然，本人水平有限，有错误的地方欢迎大家指正。这里是基于 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-dev/user/quickstart.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;\( NumPy\ v1.13.dev0\ Manual \)&lt;/a&gt; 翻译的。截止时间\( 2018/02/04 \)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Math" scheme="http://fitzeng.org/tags/Math/"/>
    
      <category term="MachineLearning" scheme="http://fitzeng.org/tags/MachineLearning/"/>
    
      <category term="Python" scheme="http://fitzeng.org/tags/Python/"/>
    
      <category term="NumPy" scheme="http://fitzeng.org/tags/NumPy/"/>
    
  </entry>
  
  <entry>
    <title>从 TensorFlow 入门机器学习</title>
    <link href="http://fitzeng.org/2018/02/03/TensorFlowIntroduction/"/>
    <id>http://fitzeng.org/2018/02/03/TensorFlowIntroduction/</id>
    <published>2018-02-03T03:27:00.000Z</published>
    <updated>2018-02-03T02:16:06.149Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<blockquote>
<p>写在前面：紧跟时代步伐，开始学习机器学习，抱着争取在毕业之前多看看各个方向是什么样子的心态，发现这是一个很有潜力也很有趣的领域（keng）。// 然后就开始补数学了……</p>
</blockquote>
<a id="more"></a>
<h2 id="0-TensorFlow-介绍"><a href="#0-TensorFlow-介绍" class="headerlink" title="0 TensorFlow 介绍"></a>0 TensorFlow 介绍</h2><p>刚刚入门的小白，理解不深，直接看官方的介绍吧</p>
<blockquote>
<p>GitHub Description: Computation using data flow graphs for scalable machine learning</p>
<p><a href="https://www.tensorflow.org/" target="_blank" rel="external">官网</a>: \( TensorFlow^{^{TM}} \)是一个使用数据流图进行数值计算的开源软件库。图中的节点代表数学运算， 而图中的边则代表在这些节点之间传递的多维数组（张量）。</p>
</blockquote>
<h3 id="0-1-什么是-TensorFlow"><a href="#0-1-什么是-TensorFlow" class="headerlink" title="0.1 什么是 TensorFlow ?"></a>0.1 什么是 TensorFlow ?</h3><p>\( Tensor \) 是张量的意思，\( Flow \) 是流的意思。所以可以直接看做利用张量组成的数据流图进行计算的一个开源库。</p>
<h3 id="0-2-TensorFlow-可以做什么"><a href="#0-2-TensorFlow-可以做什么" class="headerlink" title="0.2 TensorFlow 可以做什么 ?"></a>0.2 TensorFlow 可以做什么 ?</h3><p>目前主要是用于机器学习，这样说有点不亲民，笔者理解是可以将数据转化为向量描述并且构建相应的计算流图都是可以使用的。<br>举个例子吧，虽然不知道恰不恰当。<br>比如我们在计算 \( (1 + 2)*3-4 \) 时，可以构建一个二叉树</p>
<p><img src="/2018/02/03/TensorFlowIntroduction/0_2_01.png" alt=""></p>
<p>这棵二叉树的中序遍历就是上面的表达式，也就是说这个表达式可以转化成一个形如二叉树的图，而 \( TensorFlow \) 正好可以计算这个图。下面给出代码，看不懂没关系，只要理解代码流程是对图(二叉树)的计算就可以了，下一章会介绍如何使用\( TensorFlow \)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">a, b, c, d = tf.constant(<span class="number">1</span>), tf.constant(<span class="number">2</span>), tf.constant(<span class="number">3</span>),tf.constant(<span class="number">4</span>)</div><div class="line">add = tf.add(a,b)</div><div class="line">mul = tf.multiply(add, c)</div><div class="line">sub = tf.subtract(mul, d)</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    print(sess.run(sub))</div><div class="line"><span class="comment"># output: </span></div><div class="line"><span class="comment"># 5</span></div></pre></td></tr></table></figure>
<h3 id="0-3-TensorFlow-安装"><a href="#0-3-TensorFlow-安装" class="headerlink" title="0.3 TensorFlow 安装"></a>0.3 TensorFlow 安装</h3><p>这里就不做详细介绍了，相信点开这篇文章的你应该有了运行环境。如果没有这里推荐两个网站<a href="https://www.tensorflow.org/install/" target="_blank" rel="external">英文:官网</a> 和 <a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/get_started/os_setup.html" target="_blank" rel="external">中文:**学院翻译</a><br>然后介绍一下我的环境：\( Anaconda + PyCharm \)</p>
<p>注意 \( PyCharm:\ Project\ Interpreter \) 设置为 \( Conda\ Environment \) 才能跑 \( TensorFlow \)。如果不会可以多看看网上的教程，能对虚拟环境加深了解。</p>
<h2 id="1-初识-TensorFlow"><a href="#1-初识-TensorFlow" class="headerlink" title="1 初识 TensorFlow"></a>1 初识 TensorFlow</h2><p>好了，有前面的介绍，你应该有能够使用 \( TensorFlow \) 的环境了，下面开始介绍如何编码。</p>
<h3 id="1-1-基础语法"><a href="#1-1-基础语法" class="headerlink" title="1.1 基础语法"></a>1.1 基础语法</h3><blockquote>
<p>其实说语法是不准确的，语法就是 \( Python \) 的语法(这里使用 Python)，主要是介绍调用这个计算库来实现这个特殊的计算。同样摆上<a href="https://www.tensorflow.org/get_started/" target="_blank" rel="external">官网教程</a></p>
</blockquote>
<h4 id="1-1-1-计算单元介绍"><a href="#1-1-1-计算单元介绍" class="headerlink" title="1.1.1 计算单元介绍"></a>1.1.1 计算单元介绍</h4><p>可以看到在计算图中，有两个主要的内容是点(叶子和非叶子节点)和线。我的理解是点代表数据，线代表操作。不知道对不对，不过下面就按照这样思路介绍了。<br>下面开始介绍有哪些常用的“点”：</p>
<p><code>常量</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c = tf.constant(<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><code>变量</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">v = tf.Variable(<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><code>占位符</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p = tf.placeholder(tf.float32)</div></pre></td></tr></table></figure>
<p>以上代码都是以最小能用原则传的参，感兴趣的可以去看看源码，这里主要是往 \( Python \) 语法上拉，先使用起来再以后自己深究为什么要设计成这样的数据结构对计算图是必须的。</p>
<p>接下来就是有哪些“线”：</p>
<p><code>四则运算</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">add = tf.add(a, b)</div><div class="line">sub = tf.subtract(a, b)</div><div class="line">mul = tf.multiply(a, b)</div><div class="line">div = tf.divide(a, b)</div></pre></td></tr></table></figure>
<p>其他的就不再介绍了，详情可看 \( XXX\<em> ops.py \) 的源码。比如以上的操作定义在 \( math\</em> ops.py \)。</p>
<h4 id="1-1-2-计算流程介绍"><a href="#1-1-2-计算流程介绍" class="headerlink" title="1.1.2 计算流程介绍"></a>1.1.2 计算流程介绍</h4><p>知道了常见数据和计算方法下面介绍计算流程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="comment"># Step1: 创建数据</span></div><div class="line">a, b, c, d = tf.constant(<span class="number">1</span>), tf.constant(<span class="number">2</span>), tf.constant(<span class="number">3</span>),tf.constant(<span class="number">4</span>)</div><div class="line"></div><div class="line"><span class="comment"># Step2: 构造计算图</span></div><div class="line">add = tf.add(a,b)</div><div class="line">mul = tf.multiply(add, c)</div><div class="line">sub = tf.subtract(mul, d)</div><div class="line"></div><div class="line"><span class="comment"># Step3: 进行计算</span></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    print(sess.run(sub))</div></pre></td></tr></table></figure>
<p>上面这个例子是一个标准的常量计算过程，你可以试着 <code>print(a, add)</code> 看看你创建的是个什么东西，你会发现他是一个 \( Tensor \) 而且里面的值是 \( 0 \)。可以猜测，这里只打印不计算，看 \( Tensor \) 源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ops.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"&lt;tf.Tensor '%s' shape=%s dtype=%s&gt;"</span> % (self.name, self.get_shape(),self._dtype.name)</div><div class="line"></div><div class="line"><span class="meta">@property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""The string name of this tensor."""</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._op.name:</div><div class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Operation was not named: %s"</span> % self._op)</div><div class="line">    <span class="keyword">return</span> <span class="string">"%s:%d"</span> % (self._op.name, self._value_index)</div></pre></td></tr></table></figure>
<p>学会了计算常量，变量是不是也一样？如果你试过就知道是不一样的，变量需要初始化操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">v = tf.Variable(<span class="number">2</span>)</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    print(v, sess.run(v))</div></pre></td></tr></table></figure>
<p>到这里可能会疑问，那变量和常量有什么区别？从字面意思可以知道变量应该是可变的，方便我们在计算过程中随时调整参数，下面通过一段代码介绍如何使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">v = tf.Variable(<span class="number">2</span>)</div><div class="line"><span class="comment"># 将 v 的值自乘 2</span></div><div class="line">update = tf.assign(v, tf.multiply(v, tf.constant(<span class="number">2</span>)))</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">        print(<span class="string">"-----------------------"</span>)</div><div class="line">        <span class="keyword">print</span> <span class="string">"Before : "</span>, sess.run(v)</div><div class="line">        sess.run(update)</div><div class="line">        <span class="keyword">print</span> <span class="string">"After : "</span>, sess.run(v)</div><div class="line"></div><div class="line"><span class="comment"># output:</span></div><div class="line"><span class="comment"># -----------------------</span></div><div class="line"><span class="comment"># Before :  2</span></div><div class="line"><span class="comment"># After :  4</span></div><div class="line"><span class="comment"># -----------------------</span></div><div class="line"><span class="comment"># Before :  4</span></div><div class="line"><span class="comment"># After :  8</span></div><div class="line"><span class="comment"># -----------------------</span></div><div class="line"><span class="comment"># Before :  8</span></div><div class="line"><span class="comment"># After :  16</span></div><div class="line"><span class="comment"># -----------------------</span></div><div class="line"><span class="comment"># Before :  16</span></div><div class="line"><span class="comment"># After :  32</span></div></pre></td></tr></table></figure>
<p>但是如果我们不想每次都设置-更新-计算-更新-计算……而是直接把数据写入计算，那占位符就起作用了。同样举个小例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">c = tf.constant(<span class="number">2</span>)</div><div class="line"><span class="comment"># 注意类型一致，这里是 tf.int32</span></div><div class="line">p = tf.placeholder(tf.int32)</div><div class="line">mul = tf.multiply(c, p)</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="comment"># tmp = 2 相当于上一个例子变量的初始值是 2</span></div><div class="line">    tmp = <span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">        <span class="comment"># 直接填充 feed_dict</span></div><div class="line">        tmp = sess.run(mul, feed_dict=&#123;p:tmp&#125;)</div><div class="line">        <span class="keyword">print</span> tmp</div><div class="line"></div><div class="line"><span class="comment"># output:</span></div><div class="line"><span class="comment"># 4</span></div><div class="line"><span class="comment"># 8</span></div><div class="line"><span class="comment"># 16</span></div><div class="line"><span class="comment"># 32</span></div></pre></td></tr></table></figure>
<p>下面总结下计算过程：</p>
<ul>
<li>创建数据：可以创建常量、变量和占位符。</li>
<li>构建图：通过前面的数据构建一张图。</li>
<li>初始化：把变量初始化。</li>
<li>计算：必须通过开启一个 Session 来计算图</li>
</ul>
<h3 id="1-2-可视化"><a href="#1-2-可视化" class="headerlink" title="1.2 可视化"></a>1.2 可视化</h3><p>\( TensorFlow \)提供了一个可视化工具——\( TensorBoard \)，下面开始介绍如何使用。</p>
<p>这里对上面二叉树的例子进行可视化处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">a, b, c, d = tf.constant(<span class="number">1</span>), tf.constant(<span class="number">2</span>), tf.constant(<span class="number">3</span>),tf.constant(<span class="number">4</span>)</div><div class="line">add = tf.add(a,b)</div><div class="line">mul = tf.multiply(add, c)</div><div class="line">sub = tf.subtract(mul, d)</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    writer = tf.summary.FileWriter(<span class="string">'./graphs'</span>, sess.graph)</div><div class="line">    print(sess.run(sub))</div><div class="line">writer.close()</div></pre></td></tr></table></figure>
<p>然后使用命令行到存储 <code>graphs</code> 的文件夹下执行 <code>tensorboard --logdir=&quot;./graphs&quot;</code> 命令，然后按照提示在浏览器中打开 <code>http://localhost:6006</code> 如果成功显示 \( TensorBoard \) 界面就说明成功了。</p>
<p><img src="/2018/02/03/TensorFlowIntroduction/1_2_01.png" alt=""></p>
<h2 id="2-利用-TensorFlow-进行机器学习"><a href="#2-利用-TensorFlow-进行机器学习" class="headerlink" title="2 利用 TensorFlow 进行机器学习"></a>2 利用 TensorFlow 进行机器学习</h2><p>这里也算是机器学习的入门介绍吧。直接介绍机器学习相关知识可能不太现实，而且笔者也是在学习阶段，所以举一些小例子来体会机器学习的过程吧。</p>
<h3 id="2-1-线性回归"><a href="#2-1-线性回归" class="headerlink" title="2.1 线性回归"></a>2.1 线性回归</h3><p>这里我们使用最熟悉的线性回归来体会一下机器学习的过程：</p>
<h4 id="2-1-1-准备数据"><a href="#2-1-1-准备数据" class="headerlink" title="2.1.1 准备数据"></a>2.1.1 准备数据</h4><p>这里很简单，就是模拟一个线性回归，所以我们直接自己拟定一些数据好预测结果和自己设想的是否一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">train_X = numpy.asarray([<span class="number">1.1</span>, <span class="number">1.8</span>, <span class="number">3.2</span>, <span class="number">4.7</span>, <span class="number">5.9</span>, <span class="number">6.7</span>])</div><div class="line">train_Y = numpy.asarray([<span class="number">1.2</span>, <span class="number">2.1</span>, <span class="number">3.1</span>, <span class="number">4.6</span>, <span class="number">5.5</span>, <span class="number">6.9</span>])</div></pre></td></tr></table></figure>
<h4 id="2-1-2-构建模型"><a href="#2-1-2-构建模型" class="headerlink" title="2.1.2 构建模型"></a>2.1.2 构建模型</h4><p>我们采用占位符的形式进行计算，在运算时直接导入数据便可。<br>这里因为我们采用线性回归，所以目标函数是形如 \( Y = XW + b \) 的形式的一次函数。也就是说，我们通过给出的点去拟合一条比较符合这些点分布的直线。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">X = tf.placeholder(tf.float32)</div><div class="line">Y = tf.placeholder(tf.float32)</div><div class="line"></div><div class="line">W = tf.Variable(<span class="number">-1.</span>, name=<span class="string">"weight"</span>)</div><div class="line">b = tf.Variable(<span class="number">-1.</span>, name=<span class="string">"bias"</span>)</div><div class="line"></div><div class="line"><span class="comment"># linear model </span></div><div class="line"><span class="comment"># activation = X*W + b</span></div><div class="line">activation = tf.add(tf.multiply(X, W), b)</div></pre></td></tr></table></figure>
<h4 id="2-1-3-参数评估"><a href="#2-1-3-参数评估" class="headerlink" title="2.1.3 参数评估"></a>2.1.3 参数评估</h4><p>我们采用每个点给出的纵坐标和线性模型算出的纵坐标的差\( (activation - Y) \)的平方和\( (tf.reduce\_ sum(tf.pow(activation - Y, 2))) \)作为损失函数，在训练中采用梯度下降算法尽量使和最小，学利率选择 \( 0.01 \)。其中的数学原理这里就不介绍了，以后会写关于机器学习算法的相关文章。<br>一般选取损失函数和通过某些最优化手段更新权重是这里的一大难点，如果要知道原理，需要学习大量数学基础知识（概率论，线性代数，微积分……）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">learning_rate = <span class="number">0.01</span></div><div class="line"></div><div class="line">cost = tf.reduce_sum(tf.pow(activation - Y, <span class="number">2</span>))</div><div class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)</div></pre></td></tr></table></figure>
<h4 id="2-1-4-训练数据"><a href="#2-1-4-训练数据" class="headerlink" title="2.1.4 训练数据"></a>2.1.4 训练数据</h4><p>这里就是取数据，喂给图中的输入节点，然后模型会自己进行优化，可以将数据多次迭代使得拟合函数能够更好的适应这些数据点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">training_epochs = <span class="number">2000</span></div><div class="line">display_step = <span class="number">100</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(training_epochs):</div><div class="line">        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> zip(train_X, train_Y):</div><div class="line">            sess.run(optimizer, feed_dict=&#123;X: x, Y: y&#125;)</div><div class="line">        <span class="keyword">if</span> epoch % display_step == <span class="number">0</span>:</div><div class="line">            print(<span class="string">"Epoch:"</span>, <span class="string">'%04d'</span> % (epoch + <span class="number">1</span>), <span class="string">"cost="</span>,</div><div class="line">                  <span class="string">"&#123;:.9f&#125;"</span>.format(sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;)), <span class="string">"W="</span>, sess.run(W), <span class="string">"b="</span>,</div><div class="line">                  sess.run(b))</div><div class="line">    print(<span class="string">"Optimization Finished!"</span>)</div><div class="line">    print(<span class="string">"cost="</span>, sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;), <span class="string">"W="</span>, sess.run(W), <span class="string">"b="</span>, sess.run(b))</div><div class="line">```     </div><div class="line"></div><div class="line"><span class="comment">#### 2.1.5 可视化</span></div><div class="line">可以直接绘制二维图形看结果。不熟悉的可以参考[Matplotlib 教程](https://liam0205.me/<span class="number">2014</span>/<span class="number">09</span>/<span class="number">11</span>/matplotlib-tutorial-zh-cn/)</div><div class="line"></div><div class="line">```python</div><div class="line">    writer = tf.summary.FileWriter(<span class="string">'./graphs'</span>, sess.graph)</div><div class="line"></div><div class="line">    plt.scatter(train_X, train_Y, color=<span class="string">'red'</span>, label=<span class="string">'Original data'</span>)</div><div class="line">    plt.plot(train_X, sess.run(W) * train_X + sess.run(b), color=<span class="string">'blue'</span>, label=<span class="string">'Fitted line'</span>)</div><div class="line">    plt.show()</div><div class="line">writer.close()</div></pre></td></tr></table></figure>
<p>二维图：<br><img src="/2018/02/03/TensorFlowIntroduction/2_1_5_01.png" alt=""><br>数据流图：<br><img src="/2018/02/03/TensorFlowIntroduction/2_1_5_02.png" alt=""></p>
<h4 id="2-1-6-小结"><a href="#2-1-6-小结" class="headerlink" title="2.1.6 小结"></a>2.1.6 小结</h4><p>其实整个过程如果不深究其中的原理，还是很好理解的，无非就是<code>提供数据-选取拟合函数-构建图-选取损失函数-最优化-训练数据（更新权重）-得出结论</code>。这个过程符合我们对线性回归这个问题解决的基本思路的预期。当然，笔者认为这只是开始，要想深入，学习必要的数学知识是机器学习的必经之路。</p>
<p>这里可以参考<a href="https://juejin.im/entry/5904542c570c350058168c76" target="_blank" rel="external">TensorFlow 入门</a><br>整体代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> numpy</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">train_X = numpy.asarray([<span class="number">1.1</span>, <span class="number">1.8</span>, <span class="number">3.2</span>, <span class="number">4.7</span>, <span class="number">5.9</span>, <span class="number">6.7</span>])</div><div class="line">train_Y = numpy.asarray([<span class="number">1.2</span>, <span class="number">2.1</span>, <span class="number">3.1</span>, <span class="number">4.6</span>, <span class="number">5.5</span>, <span class="number">6.9</span>])</div><div class="line"></div><div class="line">X = tf.placeholder(tf.float32)</div><div class="line">Y = tf.placeholder(tf.float32)</div><div class="line"></div><div class="line">W = tf.Variable(<span class="number">-1.</span>, name=<span class="string">"weight"</span>)</div><div class="line">b = tf.Variable(<span class="number">-1.</span>, name=<span class="string">"bias"</span>)</div><div class="line"></div><div class="line">activation = tf.add(tf.multiply(X, W), b)</div><div class="line"></div><div class="line">learning_rate = <span class="number">0.01</span></div><div class="line"></div><div class="line">cost = tf.reduce_sum(tf.pow(activation - Y, <span class="number">2</span>))</div><div class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost)</div><div class="line"></div><div class="line">training_epochs = <span class="number">2000</span></div><div class="line">display_step = <span class="number">100</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(training_epochs):</div><div class="line">        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> zip(train_X, train_Y):</div><div class="line">            sess.run(optimizer, feed_dict=&#123;X: x, Y: y&#125;)</div><div class="line">        <span class="keyword">if</span> epoch % display_step == <span class="number">0</span>:</div><div class="line">            print(<span class="string">"Epoch:"</span>, <span class="string">'%04d'</span> % (epoch + <span class="number">1</span>), <span class="string">"cost="</span>,</div><div class="line">                  <span class="string">"&#123;:.9f&#125;"</span>.format(sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;)), <span class="string">"W="</span>, sess.run(W), <span class="string">"b="</span>,</div><div class="line">                  sess.run(b))</div><div class="line">    print(<span class="string">"Optimization Finished!"</span>)</div><div class="line">    print(<span class="string">"cost="</span>, sess.run(cost, feed_dict=&#123;X: train_X, Y: train_Y&#125;), <span class="string">"W="</span>, sess.run(W), <span class="string">"b="</span>, sess.run(b))</div><div class="line">    </div><div class="line">    writer = tf.summary.FileWriter(<span class="string">'./graphs'</span>, sess.graph)</div><div class="line"></div><div class="line">    plt.scatter(train_X, train_Y, color=<span class="string">'red'</span>, label=<span class="string">'Original data'</span>)</div><div class="line">    plt.plot(train_X, sess.run(W) * train_X + sess.run(b), color=<span class="string">'blue'</span>, label=<span class="string">'Fitted line'</span>)</div><div class="line">    plt.show()</div><div class="line">writer.close()</div><div class="line"></div><div class="line"><span class="comment"># output:</span></div><div class="line"><span class="comment"># Epoch: 0001 cost= 0.785177052 W= 1.07263 b= -0.448403</span></div><div class="line"><span class="comment"># Epoch: 0101 cost= 0.440001398 W= 1.02555 b= -0.0137608</span></div><div class="line"><span class="comment"># Epoch: 0201 cost= 0.437495589 W= 1.02078 b= 0.0176154</span></div><div class="line"><span class="comment"># Epoch: 0301 cost= 0.437433660 W= 1.02043 b= 0.0199056</span></div><div class="line"><span class="comment"># Epoch: 0401 cost= 0.437430561 W= 1.02041 b= 0.0200727</span></div><div class="line"><span class="comment"># Epoch: 0501 cost= 0.437429130 W= 1.0204 b= 0.0200851</span></div><div class="line"><span class="comment"># Epoch: 0601 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 0701 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 0801 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 0901 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1001 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1101 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1201 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1301 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1401 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1501 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1601 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1701 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1801 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Epoch: 1901 cost= 0.437429696 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># Optimization Finished!</span></div><div class="line"><span class="comment"># cost= 0.43743 W= 1.0204 b= 0.0200854</span></div><div class="line"><span class="comment"># 可以看到迭代次数到 500 次左右数据就稳定了。</span></div></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>其实这只是一个开始，还有好多好多东西要去学习。越来越觉得基础的重要性，不仅仅是计算机基础，数学基础也是同等重要，特别是未来的物联网趋势，可能编码这种专业越来越淡化，只是作为某些专业人员的一种工具/技能使用。马上面临毕业，只能自己慢慢啃这些东西了……</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h2><ul>
<li><a href="https://www.tensorflow.org/" target="_blank" rel="external">0. 官网</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/get_started/os_setup.html" target="_blank" rel="external">1. 中文:**学院翻译</a></li>
<li><a href="https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/" target="_blank" rel="external">2. Matplotlib 教程</a></li>
<li><a href="https://juejin.im/entry/5904542c570c350058168c76" target="_blank" rel="external">3. TensorFlow 入门</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;写在前面：紧跟时代步伐，开始学习机器学习，抱着争取在毕业之前多看看各个方向是什么样子的心态，发现这是一个很有潜力也很有趣的领域（keng）。// 然后就开始补数学了……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Math" scheme="http://fitzeng.org/tags/Math/"/>
    
      <category term="MachineLearning" scheme="http://fitzeng.org/tags/MachineLearning/"/>
    
      <category term="Python" scheme="http://fitzeng.org/tags/Python/"/>
    
      <category term="TensorFlow" scheme="http://fitzeng.org/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之重拾概率论</title>
    <link href="http://fitzeng.org/2018/01/26/reProbabilityTheory/"/>
    <id>http://fitzeng.org/2018/01/26/reProbabilityTheory/</id>
    <published>2018-01-26T03:27:00.000Z</published>
    <updated>2018-01-26T08:12:37.271Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><blockquote>
<p>这里主要是围绕浙大的《概率论与数理统计》第四版的内容进行总结, 其中截取了一些图片作为内容有助于对公式的理解。笔者把这篇文章作为自己的读书笔记, 为以后系统回顾概率论提供便捷。同时会继续更新, 保证自己读懂之后再来书写。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-事件关系"><a href="#1-1-事件关系" class="headerlink" title="1.1 事件关系"></a>1.1 事件关系</h3><ol>
<li><code>包含事件</code> \( A \subset B \) : 事件 \( B \) 包含事件 \( A \)，事件  \( A \) 发生必然导致事件  \( B \) 的发生。</li>
<li><code>和事件</code> \( A \cup B = \{ x|x \in A\ or\ x \in B \} \) : \( A \) \( B \) 中至少有一个事件发生。</li>
<li>\( \bigcup\limits_{k=1}\limits^{n} A_k \) : \( n \) 个事件 \( A_1, A_2, \ldots , A_n \) 的和事件。</li>
<li>\( \bigcup\limits_{k=1}\limits^{\infty} A_k \) : 可列个事件 \( A_1, A_2, \ldots \) 的和事件。</li>
<li><code>积事件</code> \( A \cap B = \{ x|x \in A\ and\ x \in B \} \) : \( A \) \( B \) 事件同时发生。</li>
<li>\( \bigcap\limits_{k=1}\limits^{n} A_k \) : \( n \) 个事件 \( A_1, A_2, \ldots , A_n \) 的积事件。</li>
<li>\( \bigcap\limits_{k=1}\limits^{\infty} A_k \) : 可列个事件 \( A_1, A_2, \ldots \) 的积事件。</li>
<li><code>差事件</code> \( A - B = \{x|x=\in A\ and\ \notin B \} \) : 当且仅当 \( A \) 发生， \( B \) 不发生。</li>
<li><code>互斥事件</code> \( A \cap B = \emptyset \) : \( A \) 与 \( B \) 事件不相容，不能同时发生。</li>
<li><code>对立事件</code> \( A \cup B = S\ and\ A \cap B = \emptyset \) : \( A \) \( B \)事件互逆，每次实验 \( A, B \) 必有一个发生且只有一个发生。\( A \) 的对立事件记为 \( \overline{A}.\ \overline{A} = S - A \)。</li>
</ol>
<p><img src="/2018/01/26/reProbabilityTheory/1_1_01.png" alt="事件关系图示"></p>
<h3 id="1-2-基本运算"><a href="#1-2-基本运算" class="headerlink" title="1.2 基本运算"></a>1.2 基本运算</h3><ol>
<li><code>交换律</code> $$ A \cup B = B \cup A;\ A \cap B = B \cap A $$</li>
<li><code>结合律</code> $$ A \cup (B \cup C) = (A \cup B) \cup C \\ A \cap (B \cap C) = (A \cap B) \cap C $$</li>
<li><code>分配率</code> $$ A \cup (B \cap C) = (A \cup B) \cap (A \cup C) \\ A \cap (B \cup C) = (A \cap B) \cup (A \cap C) $$</li>
<li><code>德摩根率</code> $$ \overline{A \cap B} = \overline{A} \cap \overline{B};\ \overline{A \cap B} = \overline{A} \cup \overline{B} $$</li>
</ol>
<h3 id="1-3-概率"><a href="#1-3-概率" class="headerlink" title="1.3 概率"></a>1.3 概率</h3><ol>
<li><code>非负性</code> : 对于每一个事件 \( A \), 有 \( P(A) \geq 0 \);</li>
<li><code>规范性</code> : 对于必然事件 \( S \), 有 \( P(S) = 1 \);</li>
<li><code>可列可加性</code> : 设 \( A_1, A_2, \ldots \) 是两两不相容的事件，即对于 \( A_iA_j = \emptyset,\ i \neq j, i, j = 1, 2, \ldots \), 有 \( P(A_1 \cup A_2 \cup \ldots) = P(A_1) + P(A_2) + \ldots \)。</li>
</ol>
<p>Tips : \( n \to \infty \Longrightarrow f_n(A) = P(A) \)</p>
<h4 id="1-3-1-基本性质"><a href="#1-3-1-基本性质" class="headerlink" title="1.3.1 基本性质"></a>1.3.1 基本性质</h4><ol>
<li>\( P(\emptyset) = 0\ and\ P(A) \leq 1  \)</li>
<li><code>有限可加性</code> : \( A_1, A_2, \ldots, A_n \) 为互斥事件, 则 $$ P(A_1 \cup A_2 \cup \ldots \cup A_n) = P(A_1) + P(A_2) + \ldots + P(A_n) $$</li>
<li>若 \( A \in B \), 则 $$ P(B - A) = P(B) - P(A) \\ P(B) \geq P(A) $$ 证明提示 : \( B = A \cup (B - A)\ and\ A(B - A) = \emptyset \)</li>
<li>\( P(\overline{A}) = 1 - P(A) \)</li>
<li><code>加法公式</code> : 任意 \( A, B \) 事件, 有 $$ P(A \cup B) = P(A) + P(B) - P(AB) $$ 证明提示 : \( A \cup B = A \cup (B - AB) \)</li>
<li><code>加法公式推广</code><br>$$ P(A_1 \cup A_2 \cup A_3) = P(A_1) + P(A_2) + P(A_3) - P(A_1A_2) - P(A_1A_3) - P(A_2A_3) + P(A_1A_2A_3) $$ 一般的有<br>$$<br>\begin{aligned} P(A_1 \cup A_2 \cup \ldots \cup A_n) = {}<br>&amp; \sum_{i = 1}^{n}P(A_i) - \sum_{1 \leq i &lt; j \leq n}P(A_iA_j) {} \\<br>&amp; + \sum_{1 \leq i &lt; j &lt; k \leq n}P(A_iA_jA_k) + \ldots + (-1)^{n-1}P(A_1A_2 \ldots A_n) \end{aligned}<br>$$</li>
</ol>
<h3 id="1-4-古典概型"><a href="#1-4-古典概型" class="headerlink" title="1.4 古典概型"></a>1.4 古典概型</h3><blockquote>
<p>也称等可能事件, 样本空间包含有限个元素, 每个基本事件发生的可能性相同。</p>
</blockquote>
<h4 id="1-4-1-基本性质"><a href="#1-4-1-基本性质" class="headerlink" title="1.4.1 基本性质"></a>1.4.1 基本性质</h4><ol>
<li><code>等可能性</code> : 在样本空间 \( S = \{ e_1, e_2, \ldots, e_n \} \) 则 $$ P(\{e_1\}) = P(\{e_2\}) = \ldots = P(\{e_n\}) $$</li>
<li><code>两两不相容</code> : 有<br>$$<br>\begin{aligned}<br>1 {}<br>&amp; = P(S) = P(\{e_1\} \cup \{e_2\} \cup \ldots \cup \{e_n\}) {} \\<br>&amp; = P(\{e_1\}) + P(\{e_2\}) + \ldots + P(\{e_n\}) {} \\<br>&amp; = nP(\{e_i\}) \\<br>&amp; P(\{e_i\}) = \frac{1}{n}, i = 1, 2, \ldots, n.<br>\end{aligned}<br>$$</li>
<li>若事件 \( A \) 包含 \( k \) 个基本事件, 即 \( A = \{e_{i_1}\} \cup \{e_{i_2}\} \cup \dots \cup \{e_{i_k}\} \) 这里 \( i_1, i_2, \ldots, i_k \) 是 \( 1, 2, \ldots, n \) 中某 \( k \)个不同的数。则有 $$ P(A) = \sum<em>{j = 1}^{k} P(\{ e\</em>{i_j} \}) = \frac{k}{n} = \frac{the\ number\ of\ event\ A}{the\ number\ of\ event\ S} $$</li>
</ol>
<h3 id="1-5-条件概率"><a href="#1-5-条件概率" class="headerlink" title="1.5 条件概率"></a>1.5 条件概率</h3><blockquote>
<p>主要理解就是在事件 \( A \) 发生了的情况下, 事件 \( B \) 发生的概率 \( P(B|A) \)。可理解样本空间为事件 \( A \) 发生之后的。</p>
</blockquote>
<h4 id="1-5-1-定义"><a href="#1-5-1-定义" class="headerlink" title="1.5.1 定义"></a>1.5.1 定义</h4><p>事件 \( A \) 发生的条件下发生事件 \( B \) 的条件概率 : $$ P(B|A) = \frac{P(AB)}{P(A)} $$ 如果不太好理解可以换成 \( P(AB) = P(A)P(B|A) \), 事件 \( AB \) 发生的过程是事件 \( A \) 发生后, 再发生事件 \( B \), 这样就可以得出事件 \( AB \) 的概率 \( P(AB) \) 与 事件 \( A \) 发生的概率 \( P(A) \) 以及事件 \( A \) 后发生的事件 \( B \) 的概率 \( P(B|A) \) 的乘积相等。 </p>
<p>同理, 概率的<code>非负性</code>、<code>规范性</code>、<code>可列可加性</code>条件概率同样具备, 下面解释第三条。</p>
<ol>
<li><code>可列可加性</code> : 设 \( B_1, B_2, \ldots \) 是两两不相容的事件, 则 $$ P(\bigcup\limits_{i=1}\limits^{\infty} B_i | A) = \sum\limits_{i = 1}\limits^{\infty} P(B_i | A) $$ 理解 : 体会基于事件 \( A \) 后发生的事件 \( B_i \) 的样本空间是事件 \( A \) 发生后的样本空间, 典型例子是在一个黑盒中不放回的取球, 求多次取出某种组合球的概率。</li>
<li><code>乘法定理</code> : 设 \( P(A) &gt; 0 \) 则$$ P(AB) = P(B|A)P(A) $$</li>
<li><code>乘法定理推广</code> : 设 \( P(AB) &gt; 0 \) 则$$ P(ABC) = P(C|AB)P(B|A)P(A) $$ Tips : \( P(A) \geq P(AB) &gt; 0 \) 是隐藏条件。<br>一般化, 设 \( A_1, A_2, \ldots, A_n \ and\  n \geq 2 \ and \ P(A_1A_2\ldots A_{n-1}) &gt; 0\), 则有 $$ P(A_1A_2\ldots A_{n}) = P(A_n|A_1A_2\ldots A_{n-1})P(A_{n-1}A_1A_2\ldots A_{n-2}) \ldots P(A_2|A_1)P(A_1)$$ 很好理解, 从后到前, 一个一个事件发生去思考。</li>
</ol>
<h4 id="1-5-2-重要公式"><a href="#1-5-2-重要公式" class="headerlink" title="1.5.2 重要公式"></a>1.5.2 重要公式</h4><ol>
<li><p><code>全概率公式</code> : 设实验 \( E \) 的样本空间为 \( S \), \( A \) 为 \( E \) 的事件, \( B_1, B_2, \ldots, B_n \) 为 \( S \) 的一个划分, 且 \( P(B_i) &gt; 0 (i = 0, 1, \dots, n) \), 则 $$ P(A) = P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + \ldots + P(A|B_n)P(B_n) $$ 照前面样本空间来理解就好了, \( P(A|B_i) \) 代表 \( A \) 事件在 \( B_i \) 样本空间的概率, 乘以 \( P(B_i) \) 代表在样本空间 \( S \) 中, \( B_i \) 中的样本触发事件 \( A \) 的概率。当所有划分样本的概率加起来时, 就是事件 \( A \) 在 \( S \) 中发生的概率了。<br>证明：假设 \( P(B_i) &gt; 0 \ (i = 1, 2, \ldots, n) \ and \ (AB_i)(AB_j) = \emptyset, i \neq j, i, j = 1, 2, \ldots, n \)<br>$$<br>A = AS = A(B_1 \cup B_2 \cup \ldots \cup B_n) = AB_1 \cup AB_2 \cup \ldots \cup AB_n, \\<br>\begin{aligned}<br>P(A) {} &amp; = P(AB_1) + P(AB_2) + \ldots + P(AB_n)  {} \\<br>&amp; = P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + \ldots + P(A|B_n)P(B_n)<br>\end{aligned}<br>$$</p>
</li>
<li><p><code>贝叶斯公式</code> : 设实验 \( E \) 的样本空间为 \( S \), \( A \) 为 \( E \) 的事件, \( B_1, B_2, \ldots, B_n \) 为 \( S \) 的一个划分, 且 \( P(A) &gt; 0,P(B_i) &gt; 0 (i = 0, 1, \dots, n) \), 则 $$ P(B_i|A) = \frac{P(A|B_i)P(B_i)}{\sum\limits_{j = 1}\limits^{n}P(A|B_j)P(B_j)}, i= 1,2, \ldots, n.$$ 当 \( n = 2 \) 时, 这两个公式分别为 : $$ P(A) = P(A|B)P(B) + P(A|\overline{B})P(\overline{B}) = P(AB) + P(A\overline{B}) \\ P(B|A) = \frac{P(AB)}{P(A)} = \frac{P(A|B)P(B)}{P(A|B)P(B) + P(A|\overline{B})P(\overline{B})} = \frac{P(A|B)P(B)}{P(AB) + P(A\overline{B})} $$</p>
</li>
</ol>
<p>这两个公式比较重要, 这里截取一个例子供加深理解:<br><img src="/2018/01/26/reProbabilityTheory/1_5_2_01.png" alt="全概率和贝叶斯公式应用1"><br><img src="/2018/01/26/reProbabilityTheory/1_5_2_02.png" alt="全概率和贝叶斯公式应用2"><br><img src="/2018/01/26/reProbabilityTheory/1_5_2_03.png" alt="全概率和贝叶斯公式应用3"></p>
<h3 id="1-6-独立性"><a href="#1-6-独立性" class="headerlink" title="1.6 独立性"></a>1.6 独立性</h3><blockquote>
<p>理解事件 \( A, B \) 有 \( P(A|B) = P(A) \) 条件成立时, \( A, B \) 相互独立。</p>
</blockquote>
<h4 id="1-6-1-定义"><a href="#1-6-1-定义" class="headerlink" title="1.6.1 定义"></a>1.6.1 定义</h4><p>设事件 \( A, B \) 满足 $$ P(AB) = P(A)P(B) $$ 则称事件 \( A, B \) 互相独立。</p>
<h4 id="1-6-2-性质"><a href="#1-6-2-性质" class="headerlink" title="1.6.2 性质"></a>1.6.2 性质</h4><p>若 \( A, B \) 互相独立, 则 \( (A,\overline{B})\ (\overline{A}, B)\ (\overline{A}, \overline{B}) \) 也相互独立。</p>
<p><code>多事件独立</code> : \( A, B, C \) 独立条件 $$ \begin{aligned} &amp; P(AB) = P(A)P(B) \\ &amp; P(AC) = P(A)P(C) \\ &amp; P(BC) = P(B)P(C) \\ &amp; P(ABC) = P(A)P(B)P(C) \end{aligned}$$ 一般, 设事件 \( A_1, A_2, \ldots, A_n \) 是 \( n \ (n \geq 2) \) 个事件, 如果对于其中任意 \( 2, 3, \ldots, n \)个事件的积事件的概率都等于各事件概率之积, 则称事件 \( A_1, A_2, \ldots, A_n \) 相互独立。</p>
<p>Tips : 通过关键词自己一一回顾这一章的内容吧。<br><code>随机试验</code>, <code>样本空间</code>, <code>随机事件</code>, <code>基本事件</code>, <code>频率</code>, <code>概率</code>, <code>古典概型</code>, \( A \) 的对立事件 \( \overline{A} \) 及其概率, <code>两互不相容事件的和事件的概率</code>, <code>概率的加法定理</code>, <code>条件概率</code>, <code>概率的乘法公式</code>, <code>全概率公式</code>, <code>贝叶斯公式</code>, <code>事件的独立性</code>, <code>实际推断原理</code></p>
<h2 id="2-随机变量及其分布"><a href="#2-随机变量及其分布" class="headerlink" title="2. 随机变量及其分布"></a>2. 随机变量及其分布</h2><h3 id="2-1-随机变量"><a href="#2-1-随机变量" class="headerlink" title="2.1 随机变量"></a>2.1 随机变量</h3><blockquote>
<p>在前面随机试验中, 结果可以用数来表示, 但是有些描述起来不方便, 为了处理方便, 将 \( S \) 中的每一个元素 \( e \) 与实数 \( x \) 对应起来, 随机变量就这样引入了。</p>
</blockquote>
<h3 id="2-2-离散型随机变量及其分布"><a href="#2-2-离散型随机变量及其分布" class="headerlink" title="2.2 离散型随机变量及其分布"></a>2.2 离散型随机变量及其分布</h3><blockquote>
<p>随机变量 \( X \) 的取值是离散的, 如 \( 0, 1, 2, 3 \)</p>
</blockquote>
<h4 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h4><p>设离散型随机变量 \( X \) 所有可能的取值为 \( x_k(k = 1, 2, \ldots) , X \) 取各个可能值的概率, 及时间 \( \{ X = x_k\} \) 的概率为 : $$ P\{X = x_k\} = p_k, k = 1, 2, \ldots . $$ 同理, 概率的<code>非负性</code>、<code>规范性</code>、<code>可列可加性</code>离散型随机变量概率同样具备。<br>用表格表示 \( X \) 的分布律:<br>$$<br>\begin{array}{c|ccccc}<br>X &amp; x_1 &amp; x_2 &amp; \ldots &amp; x_n &amp; \ldots \\<br>\hline<br>p_k &amp; p_1 &amp; p_2 &amp; \ldots &amp; p_n &amp; \dots<br>\end{array}<br>$$</p>
<h4 id="2-2-2-几种典型的离散分布"><a href="#2-2-2-几种典型的离散分布" class="headerlink" title="2.2.2 几种典型的离散分布"></a>2.2.2 几种典型的离散分布</h4><ol>
<li><code>0-1 分布</code> : 随机变量 \( X \) 只能取值 \( 0, 1 \) 分布律是 $$ P\{X = k\} = p^k(1 - p)^{1 - k}, k = 0, 1 \ (0 &lt; p &lt; 1) $$<br>对于随机试验 \( S = \{ e_1, e_2 \}\), 我们总能在 \( S \) 上定义一个服从 （0 — 1）分布的随机变量 \( X \) : $$ X = X(e) = \begin{cases} 0,\ when\ e = e_1 \\ 1,\ when\ e = e_2 \end{cases} $$ 来描述。</li>
<li><code>伯努利试验、二项分布</code> : 试验 \( E \) 只有两个可能的结果 \( \{ A, \overline{A} \} \), 则称 \( E \) 为伯努利试验。将 \( E \) 重复地进行 \( n \) 次, 称这一串重复的独立实试验为重复伯努利试验。<br>设 \( P(A) = p \) 则在 \( n \) 次试验中 \( A \) 发生 \( k \) 次的概率为 : $$ P\{X = k\} = \left( \begin{array}{c} n \\ k \end{array} \right) p^k{(1 - p)}^{n - k}, k = 0, 1, 2, \ldots, n.$$ 显然 $$ \sum\limits_{k = 0}\limits^{n}P\{X = k\} = \sum\limits_{k = 0}\limits^{n} \left( \begin{array}{c} n \\ k \end{array} \right) p^k{(1 - p)}^{n - k} = {(p + (1 - p))}^n = 1 $$ 二项式 \( {(p + (1 - p))}^n \) 的第 \( k \) 项展开 \( \left( \begin{array}{c} n \\ k \end{array} \right) p^k{(1 - p)}^{n - k} \)。 所以, 我们称 \( X \) 服从参数为 \( n, p \) 的二项分布, 记作 : $$ X \sim b(n, p) $$ 特别的, 当 \( n = 1 \)时为二项分布 : $$ P\{X = k\} = p^k{(1 - p)}^{1 - k}, k = 0, 1.$$ </li>
<li><code>泊松分布</code> : 随机变量 \( X = \{0, 1, 2, \ldots \} \), 而各个概率的取值为 $$ P\{X = k\} = \frac{\lambda^k e^{-\lambda}}{k!}, k = 0, 1, 2, \ldots, \lambda &gt; 0 $$ 则称 \( X \)服从参数为 \( \lambda \) 的泊松分布, 记作 : $$ X \sim \pi(\lambda) $$ 显然 $$ \sum\limits_{k = 0}^{\infty}P\{X = k\} = \sum\limits_{k = 0}^{\infty} \frac{\lambda^k e^{-\lambda}}{k!} = e^{-\lambda} \sum\limits_{k = 0}^{\infty}\frac{\lambda^k}{k!} = e^{-\lambda}e^\lambda = 1 $$ 具体使用后面会慢慢介绍。</li>
<li><code>泊松定理</code> : 设 \( \lambda &gt; 0, np_n = \lambda \ n \)为任意正整数, 则对于任意一个固定的非负整数 \( k \), 有 $$ \lim_{n \rightarrow \infty} \left( \begin{array}{c} n \\ k \end{array} \right) p_n^k{(1 - p_n)}^{n - k} = \frac{\lambda^k e^{-\lambda}}{k!} $$ 这就是用泊松分布逼近二项分布的泊松定理。证明截图如下 :<br><img src="/2018/01/26/reProbabilityTheory/2_2_2_01.png" alt="泊松定理证明"><br>上面的证明说明了, 当 \( n \rightarrow \infty\) 时, 以 \( n, p \) 为参数的二项分布概率值可以由参数为 \( \lambda = np \) 的泊松分布的概率值近似。<br>举个栗子<br><img src="/2018/01/26/reProbabilityTheory/2_2_2_02.png" alt="泊松定理举个栗子"></li>
</ol>
<h3 id="2-3-随机变量的分布函数"><a href="#2-3-随机变量的分布函数" class="headerlink" title="2.3 随机变量的分布函数"></a>2.3 随机变量的分布函数</h3><blockquote>
<p>对于非离散的随机变量 \( X \) 指定某一实数值得概率都为 \( 0 \)。所以这里就改为研究随机变量所落区间的概率 : $$ P\{x_1 &lt; X \leq x_2\} = P(X \leq x_2) - P(X \leq x_1) $$ 画个数轴就很好理解了。</p>
</blockquote>
<h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><p>设 \( X \) 是一个随机变量, \( x \) 是任意实数, 函数 : $$ F(x) = P\{ X \leq x\}, -\infty &lt; x &lt; \infty $$ 称为 \( X \) 的<code>分布函数</code>。<br>对任意实数 \( x_1, x_2 (x_1 &lt; x_2) \), 有 $$ P\{x_1 &lt; X \leq x_2\} = P(X \leq x_2) - P(X \leq x_1) = F(x_2) - F(x_1) $$</p>
<h4 id="2-3-2-基本性质"><a href="#2-3-2-基本性质" class="headerlink" title="2.3.2 基本性质"></a>2.3.2 基本性质</h4><ol>
<li>\( F(x) \) 是一个不减函数。</li>
<li>\( 0 \leq F(x) \leq 1 \ and\ F(-\infty) = \lim\limits_{x\rightarrow-\infty}F(x) = 0 \ F(\infty) = \lim\limits_{x\rightarrow\infty}F(x) = 1 \)</li>
</ol>
<h3 id="2-4-连续型随机变量及其概率密度"><a href="#2-4-连续型随机变量及其概率密度" class="headerlink" title="2.4 连续型随机变量及其概率密度"></a>2.4 连续型随机变量及其概率密度</h3><blockquote>
<p>如上一节分析, 随机变量 \( X \) 的分布函数 \( F(x) \)存在非负函数 \( f(x) \), 使得任意实数 \( x \)有 $$ F(x) = \int_{-\infty}^{x}f(x)dt $$ 则称 \( X \)为<code>连续型随机变量</code>, 其中函数 \( f(x) \) 称为 \( X \) 的<code>概率密度函数</code>, 简称<code>概率密度</code>。</p>
</blockquote>
<ol>
<li>\( f(x) \geq 0 \)</li>
<li>\( \int_{-\infty}^{\infty} f(x)dx = 1 \)</li>
<li>对于任意实数 \( x_1, x_2 (x_1 \leq x_2) \) $$ P(x_1 &lt; X \leq x_2) = F(x_2)   - F(x_1) = \int_{x_1}^{x_2}f(x)dx $$</li>
<li>若 \( f(x) \) 在 \( x \)出连续, 则 \( F^{‘}(x) = f(x) \)</li>
</ol>
<h4 id="2-4-1-几种典型的连续型随机变量"><a href="#2-4-1-几种典型的连续型随机变量" class="headerlink" title="2.4.1 几种典型的连续型随机变量"></a>2.4.1 几种典型的连续型随机变量</h4><ol>
<li><code>均匀分布</code> : 若连续型随机变量 \( X \) 的概率密度为 $$ f(x) = \begin{cases} \frac{1}{b - a},\ a &lt; x &lt; b \\ 0,\ others \end{cases} $$ 则称 \( X \) 在区间 \( (a, b) \) 上服从均匀分布。记为 \( X \sim U(a, b) \)。分布函数为 $$ F(x) = \begin{cases} 0,\ x &lt; a \\ \frac{x - a}{b - a},\ a \leq x &lt; b \\ 1,\ x \geq b  \end{cases} $$<br><img src="/2018/01/26/reProbabilityTheory/2_4_1_01.png" alt="均匀分布例子"></li>
<li><code>指数分布</code> : 若连续型随机变量 \( X \) 的概率密度为 $$ f(x) = \begin{cases} \frac{1}{\theta}e^{-x/\theta},\  x &gt; 0 \\ 0,\ others \end{cases} $$ 其中 \( \theta &gt; 0 \) 为常数, 则称 \( X \) 服从参数为 \( \theta \) 的指数分布。分布函数为 $$ f(x) = \begin{cases} 1 - e^{-x/\theta},\  x &gt; 0 \\ 0,\ others \end{cases} $$<br><code>指数分布的无记忆性</code> : 对于任意 \( s, t &gt; 0 \), 有 $$ P\{ X &gt; s + t | X &gt; s\} = P\{ X &gt; t \} $$ 证明 : <img src="/2018/01/26/reProbabilityTheory/2_4_1_02.png" alt="指数分布的无记忆性的证明"> </li>
<li><code>正态分布</code> : 若连续型随机变量 \( X \) 的概率密度为 $$ f(x) = \frac{1}{\sqrt{2\pi}\sigma} e ^{- \frac{(x - \mu)^2}{2\sigma^2}}, \ -\infty &lt; x &lt; \infty $$ 其中 \( \mu, \sigma (\sigma &gt; 0) \) 为常数, 则称 \( X \) 服从参数为 \( \mu, \sigma \) 的正态分布或高斯分布, 记为 \( X \sim N(\mu, \sigma^2) \)。证明 : <img src="/2018/01/26/reProbabilityTheory/2_4_1_03.png" alt=""><br>曲线关于 \(  x = \mu \) 对称, 这表明对于任意 \( h &gt; 0 \) 有 $$ P\{ \mu - h &lt; X \leq \mu \} = P\{ \mu &lt; X \leq \mu + h \} $$ 当 \( x = \mu \) 时取最大值 $$ f(\mu) = \frac{1}{\sqrt{2\pi}\sigma} $$ 在 \( x = \mu \pm \sigma \) 处曲线有拐点。特别, 当 \( \mu = 0, \sigma = 1 \) 时, 称随机变量 \( X \) 服从标准正态分布。其概率密度和分布函数分别用 \( \varphi (x), \Phi (x) \) 表示, 即有 $$ \varphi (x) = \frac{1}{\sqrt{2\pi}}e^{-t^2/2} \\ \Phi (x) = \frac{1}{\sqrt{2\pi}} \int_{-\infty}^{x}e^{-t^2/2}dt \\ \Phi (-x) = 1 - \Phi (x) $$ <img src="/2018/01/26/reProbabilityTheory/2_4_1_04.png" alt=""></li>
</ol>
<h3 id="2-5-随机变量的函数的分布"><a href="#2-5-随机变量的函数的分布" class="headerlink" title="2.5 随机变量的函数的分布"></a>2.5 随机变量的函数的分布</h3><blockquote>
<p>这里主要介绍在已知随机变量 \( X \) 的概率求 \( Y = g(X) \ g(\cdot) \) 是已知连续函数。</p>
</blockquote>
<p>举个栗子<br><img src="/2018/01/26/reProbabilityTheory/2_5_01.png" alt=""></p>
<p>设随机变量 \( X \) 具有概率密度 \( f_X(x), \ -\infty &lt; x &lt; \infty \), 又设函数 \( g(x) \) 处处可导, 恒有 \( g(x)^{‘} &gt; 0 \ or \  g(x)^{‘} &lt; 0 \), 则 \( Y = g(X) \) 是连续型随机变量, 其概率密度为 $$ f_Y(y) = \begin{cases} f_X[h(y)]|h^{‘}(y)|, \ \alpha &lt; y &lt; \beta \\ 0, \ others \end{cases} $$ 其中 \( \alpha = min\{ g(-\infty), g(\infty) \} \ \beta = max\{ g(-\infty), g(\infty) \} \ h(x) \) 是 \( g(x) \) 的反函数。<br>证明提示 : 见上一个🌰</p>
<p><img src="/2018/01/26/reProbabilityTheory/2_5_02.png" alt=""></p>
<p>小结 :<br><img src="/2018/01/26/reProbabilityTheory/2_5_03.png" alt=""><br><img src="/2018/01/26/reProbabilityTheory/2_5_04.png" alt=""><br><img src="/2018/01/26/reProbabilityTheory/2_5_05.png" alt=""></p>
<p><img src="/2018/01/26/reProbabilityTheory/summary.jpg" alt=""></p>
<h2 id="3-TODO"><a href="#3-TODO" class="headerlink" title="3. TODO"></a>3. TODO</h2><p>未完待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这里主要是围绕浙大的《概率论与数理统计》第四版的内容进行总结, 其中截取了一些图片作为内容有助于对公式的理解。笔者把这篇文章作为自己的读书笔记, 为以后系统回顾概率论提供便捷。同时会继续更新, 保证自己读懂之后再来书写。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Math" scheme="http://fitzeng.org/tags/Math/"/>
    
      <category term="MachineLearning" scheme="http://fitzeng.org/tags/MachineLearning/"/>
    
      <category term="ProbabilityTheory" scheme="http://fitzeng.org/tags/ProbabilityTheory/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown 插入数学公式实验大集合</title>
    <link href="http://fitzeng.org/2018/01/23/LaTexFormula/"/>
    <id>http://fitzeng.org/2018/01/23/LaTexFormula/</id>
    <published>2018-01-23T03:27:00.000Z</published>
    <updated>2018-01-23T14:47:46.407Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><blockquote>
<p>最近在学习一些机器学习相关的知识，想把自己学习的东西通过 MD 的形式在线记录下来，但是之前一直没有开始行动，因为里面的公式什么的感觉实在是麻烦。于是今天打算花点时间了解一下<a href="http://blog.csdn.net/xiahouzuoxin/article/details/26478179" target="_blank" rel="external"><code>如何在 markdown 中插入数学公式</code></a>，发现其实很简单，大概花一个小时左右就能知道如何编写了。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-基础认识"><a href="#1-基础认识" class="headerlink" title="1. 基础认识"></a>1. 基础认识</h2><blockquote>
<p>笔者认为所谓插入数学公式其实就是引入一种规则，然后通过<code>模板？</code>渲染成公式，不知道这个理解对不对，不对望指正。其实你以前可能就看到过有的博客本该出现公式的时候不显示，点击后会链接到一个 new tab 然后显示一张公式的图片，有时却出现一大堆的代码。这里就是通过这段代码解析成公式然后显示的。</p>
</blockquote>
<p>这里我们选取 MathJax 引擎。<br>引入脚本，把下面代码插入 MD 文件里面，如果你怕这份在线文件源别人访问不到的话，可以把这个下下来自己做一个源，这样比较稳定缺点是要自己手动更新源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>好了到这里就可以插入公式了，如果你懂 LaTeX 的话那看一两个例子就知道了，不懂也没关系，自己写一写代码就知道了，可以找一个可以预览 MD 的工具一直尝试。</p>
<h3 id="1-1-插入方式"><a href="#1-1-插入方式" class="headerlink" title="1.1 插入方式"></a>1.1 插入方式</h3><blockquote>
<p>这里分两种，一种是行间插入，另一种是另取一行</p>
</blockquote>
<h4 id="1-1-1-行间插入"><a href="#1-1-1-行间插入" class="headerlink" title="1.1.1 行间插入"></a>1.1.1 行间插入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\\(a + b\\)</div></pre></td></tr></table></figure>
<p>这里是行间插入公式 a + b : \(a + b\)，特点就是通过<code>(</code> 和 <code>)</code> 包含公式，然后为了模板引擎能够区分该 <code>(</code> 不是普通文本的 <code>(</code> 而是公式的 <code>(</code>，通过 <code>\\</code> 转义一下。这样应该就很好理解这个语法构成了。注意这里方式不唯一，这是笔者喜欢的方式，其他的使用方式自行搜索。下面的介绍同样是这样。</p>
<h4 id="1-1-2-另取一行"><a href="#1-1-2-另取一行" class="headerlink" title="1.1.2 另取一行"></a>1.1.2 另取一行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$a + b$$</div></pre></td></tr></table></figure>
<p>这里是另取一行$$a + b$$ 特点就是通过<code>$$</code>包含公式。</p>
<p>笔者认为第二种方式更好，以下没看 JS 源码纯属猜测：行间的需要考虑到当前行的行高并对公式进行处理，而另取一行就更简单一些，可能解析起来更快。最最最最最最主要是看起来漂亮 ^_^ 不太要考虑空间不够换行。</p>
<h3 id="1-2-基本类型的插入"><a href="#1-2-基本类型的插入" class="headerlink" title="1.2 基本类型的插入"></a>1.2 基本类型的插入</h3><blockquote>
<p>这里对 <a href="http://www.cnblogs.com/houkai/p/3399646.html" target="_blank" rel="external">@houkai ：LATEX数学公式基本语法</a> 的思路稍加修改，然后进行介绍。</p>
</blockquote>
<h4 id="1-2-1-上、下标"><a href="#1-2-1-上、下标" class="headerlink" title="1.2.1 上、下标"></a>1.2.1 上、下标</h4><p>先看结果再总结语法吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$$x_1$$</div><div class="line"></div><div class="line">$$x_1^2$$</div><div class="line"></div><div class="line">$$x^2_1$$</div><div class="line"></div><div class="line">$$x_&#123;22&#125;^&#123;(n)&#125;$$</div><div class="line"></div><div class="line">$$&#123;&#125;^*x^*$$</div><div class="line"></div><div class="line">$$x_&#123;balabala&#125;^&#123;bala&#125;&amp;&amp;</div></pre></td></tr></table></figure>
<p>$$x_1$$</p>
<p>$$x_1^2$$</p>
<p>$$x^2_1$$</p>
<p>$$x_{22}^{(n)}$$</p>
<p>$${}^*x^*$$</p>
<p>$$x_{balabala}^{bala}$$</p>
<p>可以看到 <code>x</code> 元素的上标通过 <code>^</code> 符号后接的内容体现，下表通过 <code>_</code> 符号后接的内容体现，多于一位是要加 <code>{}</code> 包裹的。<br>笔者习惯先下标后上标的写法，和我的书写习惯一致：<code>x_{balabala}^{bala}</code>，不管你使用哪一种风格，最好自己注意统一，不要混用。</p>
<h4 id="1-2-2-分式"><a href="#1-2-2-分式" class="headerlink" title="1.2.2 分式"></a>1.2.2 分式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$$\frac&#123;x+y&#125;&#123;2&#125;$$</div><div class="line"></div><div class="line">$$\frac&#123;1&#125;&#123;1+\frac&#123;1&#125;&#123;2&#125;&#125;$$</div></pre></td></tr></table></figure>
<p>$$\frac{x+y}{2}$$</p>
<p>$$\frac{1}{1+\frac{1}{2}}$$</p>
<p>这里就出现了一个 <code>frac{}{}</code> 函数的东西，同样，为了区分这是函数不是几个字母，通过 <code>\frac</code> 转义，于是 <code>frac</code> 被解析成函数，然后第一个 <code>{}</code> 里面的被解析成分子，第二个 <code>{}</code> 被解析成分母。这里可以试试分数的行间解析\(\frac{1}{1+\frac{1}{2}}\)。我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果我要看行间填充效果。</p>
<h4 id="1-2-3-根式"><a href="#1-2-3-根式" class="headerlink" title="1.2.3 根式"></a>1.2.3 根式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$$\sqrt&#123;2&#125;&lt;\sqrt[3]&#123;3&#125;$$</div><div class="line"></div><div class="line">$$\sqrt&#123;1+\sqrt[p]&#123;1+a^2&#125;&#125;$$</div><div class="line"></div><div class="line">$$\sqrt&#123;1+\sqrt[^p\!]&#123;1+a^2&#125;&#125;$$</div></pre></td></tr></table></figure>
<p>$$\sqrt{2}&lt;\sqrt[3]{3}$$</p>
<p>$$\sqrt{1+\sqrt[p]{1+a^2}}$$</p>
<p>$$\sqrt{1+\sqrt[^p]{1+a^2}}$$</p>
<p>读到这里你已经了解了函数的概念，那么这历久很简单了，语法就是 <code>sqrt[]{}</code> 。<code>[]</code> 中代表是几次根式，<code>{}</code> 代表根号下的表达式。第二和第三个的区别在于为了美观微调位置 ^_^。</p>
<h4 id="1-2-4-求和、积分"><a href="#1-2-4-求和、积分" class="headerlink" title="1.2.4 求和、积分"></a>1.2.4 求和、积分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$$\sum_&#123;k=1&#125;^&#123;n&#125;\frac&#123;1&#125;&#123;k&#125;$$</div><div class="line"></div><div class="line">\\(\sum_&#123;k=1&#125;^n\frac&#123;1&#125;&#123;k&#125;\\)</div><div class="line"></div><div class="line">$$\int_a^b f(x)dx$$</div><div class="line"></div><div class="line">\\(\int_a^b f(x)dx\\)</div></pre></td></tr></table></figure>
<p>$$\sum_{k=1}^{n}\frac{1}{k}$$</p>
<p>\(\sum_{k=1}^n\frac{1}{k}\)</p>
<p>$$\int_{a}^b f(x)dx$$</p>
<p>\(\int_a^b f(x)dx\)</p>
<p>这里很容易看出求和函数表达式 <code>sum_{起点}^{终点}表达式</code>，积分函数表达式 <code>int_下限^上限 被积函数d被积量</code>。还有一个有趣的是行间的公式都被压缩了。</p>
<h4 id="1-2-5-空格"><a href="#1-2-5-空格" class="headerlink" title="1.2.5 空格"></a>1.2.5 空格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">紧贴 $a\\!b$</div><div class="line">没有空格 $ab$</div><div class="line">小空格 a\,b</div><div class="line">中等空格 a\;b</div><div class="line">大空格 a\ b</div><div class="line">quad空格 $a\quad b$</div><div class="line">两个quad空格 $a\qquad b$</div></pre></td></tr></table></figure>
<p>$$a\!b$$<br>$$ab$$<br>$$a\,b$$<br>$$a\;b$$<br>$$a\ b$$<br>$$a\quad b$$<br>$$a\qquad b$$</p>
<p>这个直接看上面的文字，介绍很清楚，主要指微调距离，使得公式更加漂亮。请比较下面的积分公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$$\int_a^b f(x)\mathrm&#123;d&#125;x$$</div><div class="line"></div><div class="line">$$\int_a^b f(x)\,\mathrm&#123;d&#125;x$$</div></pre></td></tr></table></figure>
<p>$$\int_a^b f(x)\mathrm{d}x$$</p>
<p>$$\int_a^b f(x)\,\mathrm{d}x$$</p>
<h4 id="1-2-6-公式界定符"><a href="#1-2-6-公式界定符" class="headerlink" title="1.2.6 公式界定符"></a>1.2.6 公式界定符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">\\( ( \\)</div><div class="line">\\( ) \\)</div><div class="line">\\( [ \\)</div><div class="line">\\( ] \\)</div><div class="line">\\( \\&#123; \\)</div><div class="line">\\( \\&#125; \\)</div><div class="line">\\( | \\)</div><div class="line">\\( \\| \\)</div></pre></td></tr></table></figure>
<p>主要符号有<br>\( ( \)<br>\( ) \)<br>\( [ \)<br>\( ] \)<br>\( \{ \)<br>\( \} \)<br>\( | \)<br>\( \| \)<br>那么如何使用呢？<br>通过 <code>\left</code> 和 <code>\right</code> 后面跟界定符来对同时进行界定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$\left(\sum_&#123;k=\frac&#123;1&#125;&#123;2&#125;&#125;^&#123;N^2&#125;\frac&#123;1&#125;&#123;k&#125;\right)$$</div></pre></td></tr></table></figure>
<p>$$\left(\sum_{k=\frac{1}{2}}^{N^2}\frac{1}{k}\right)$$</p>
<h4 id="1-2-7-矩阵"><a href="#1-2-7-矩阵" class="headerlink" title="1.2.7 矩阵"></a>1.2.7 矩阵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$$\begin&#123;matrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;matrix&#125;$$</div><div class="line"></div><div class="line">$$\begin&#123;pmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;pmatrix&#125;$$</div><div class="line"></div><div class="line">$$\begin&#123;bmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;bmatrix&#125;$$</div><div class="line"></div><div class="line">$$\begin&#123;Bmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;Bmatrix&#125;$$</div><div class="line"></div><div class="line">$$\begin&#123;vmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;vmatrix&#125;$$</div><div class="line"></div><div class="line">$$\left|\begin&#123;matrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;matrix&#125;\right|$$</div><div class="line"></div><div class="line">$$\begin&#123;Vmatrix&#125;1 &amp; 2\\\\3 &amp;4\end&#123;Vmatrix&#125;$$</div></pre></td></tr></table></figure>
<p>$$\begin{matrix}1 &amp; 2\\3 &amp;4\end{matrix}$$</p>
<p>$$\begin{pmatrix}1 &amp; 2\\3 &amp;4\end{pmatrix}$$</p>
<p>$$\begin{bmatrix}1 &amp; 2\\3 &amp;4\end{bmatrix}$$</p>
<p>$$\begin{Bmatrix}1 &amp; 2\\3 &amp;4\end{Bmatrix}$$</p>
<p>$$\begin{vmatrix}1 &amp; 2\\3 &amp;4\end{vmatrix}$$</p>
<p>$$\left|\begin{matrix}1 &amp; 2\\3 &amp;4\end{matrix}\right|$$</p>
<p>$$\begin{Vmatrix}1 &amp; 2\\3 &amp;4\end{Vmatrix}$$</p>
<p>类似于 left right，这里是 begin 和 end。而且里面有具体的矩阵语法，<code>&amp;</code> 区分行间元素，<code>\\\\</code> 代表换行。可以理解为 HTML 的标签之类的。</p>
<h4 id="1-2-8-排版数组"><a href="#1-2-8-排版数组" class="headerlink" title="1.2.8 排版数组"></a>1.2.8 排版数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">\mathbf&#123;X&#125; =</div><div class="line">\left( \begin&#123;array&#125;&#123;ccc&#125;</div><div class="line">x\_&#123;11&#125; &amp; x\_&#123;12&#125; &amp; \ldots \\\\</div><div class="line">x\_&#123;21&#125; &amp; x\_&#123;22&#125; &amp; \ldots \\\\</div><div class="line">\vdots &amp; \vdots &amp; \ddots</div><div class="line">\end&#123;array&#125; \right)</div></pre></td></tr></table></figure>
<p>$$<br>\mathbf{X} =<br>\left( \begin{array}{ccc}<br>x_{11} &amp; x_{12} &amp; \ldots \\<br>x_{21} &amp; x_{22} &amp; \ldots \\<br>\vdots &amp; \vdots &amp; \ddots<br>\end{array} \right)<br>$$</p>
<h2 id="2-常用公式举例"><a href="#2-常用公式举例" class="headerlink" title="2. 常用公式举例"></a>2. 常用公式举例</h2><blockquote>
<p>持续更新……</p>
</blockquote>
<h3 id="2-1-多行公式"><a href="#2-1-多行公式" class="headerlink" title="2.1 多行公式"></a>2.1 多行公式</h3><blockquote>
<p>主要是各种方程的表达</p>
</blockquote>
<h4 id="2-1-1-长公式"><a href="#2-1-1-长公式" class="headerlink" title="2.1.1 长公式"></a>2.1.1 长公式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">\begin&#123;multline&#125;</div><div class="line">x = a+b+c+&#123;&#125; \\\\</div><div class="line">d+e+f+g</div><div class="line">\end&#123;multline&#125;</div><div class="line">$$</div><div class="line"></div><div class="line">$$</div><div class="line">\begin&#123;aligned&#125;</div><div class="line">x =&#123;&#125;&amp; a+b+c+&#123;&#125; \\\\</div><div class="line">&amp;d+e+f+g</div><div class="line">\end&#123;aligned&#125;</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>不对齐</p>
<p>$$<br>\left| \begin{multline}<br>x = a+b+c+{} \\<br>d+e+f+g<br>\end{multline} \right|<br>$$</p>
<p>对齐</p>
<p>$$<br>\left| \begin{aligned}<br>x ={}&amp; a+b+c+{} \\<br>&amp;d+e+f+g<br>\end{aligned} \right|<br>$$</p>
<h4 id="2-1-2-公式组"><a href="#2-1-2-公式组" class="headerlink" title="2.1.2 公式组"></a>2.1.2 公式组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">\begin&#123;gather&#125;</div><div class="line">a = b+c+d \\\\</div><div class="line">x = y+z</div><div class="line">\end&#123;gather&#125;</div><div class="line">$$</div><div class="line"></div><div class="line">$$</div><div class="line">\begin&#123;align&#125;</div><div class="line">a &amp;= b+c+d \\\\</div><div class="line">x &amp;= y+z</div><div class="line">\end&#123;align&#125;</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>\begin{gather}<br>a = b+c+d \\<br>x = y+z<br>\end{gather}<br>$$</p>
<p>$$<br>\begin{align}<br>a &amp;= b+c+d \\<br>x &amp;= y+z<br>\end{align}<br>$$</p>
<h4 id="2-1-3-分段函数"><a href="#2-1-3-分段函数" class="headerlink" title="2.1.3 分段函数"></a>2.1.3 分段函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">y=\begin&#123;cases&#125;</div><div class="line">-x,\quad x\leq 0 \\\\</div><div class="line">x,\quad x&gt;0</div><div class="line">\end&#123;cases&#125;</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>y=\begin{cases}<br>-x,\quad x\leq 0 \\<br>x,\quad x&gt;0<br>\end{cases}<br>$$</p>
<p>里面用到了 \(\leq\) 符号，下一章会介绍常用数学符号。</p>
<h3 id="2-2-数组的其他使用"><a href="#2-2-数组的其他使用" class="headerlink" title="2.2 数组的其他使用"></a>2.2 数组的其他使用</h3><h4 id="2-2-1-划线"><a href="#2-2-1-划线" class="headerlink" title="2.2.1 划线"></a>2.2.1 划线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">\left(\begin&#123;array&#125;&#123;|c|c|&#125;</div><div class="line">1 &amp; 2 \\\\</div><div class="line">\\hline</div><div class="line">3 &amp; 4</div><div class="line">\end&#123;array&#125;\right)</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>\left( \begin{array}{|c|c|}<br>1 &amp; \ldots \\<br>\hline<br>\vdots &amp; \ddots<br>\end{array} \right)<br>$$</p>
<h4 id="2-2-2-制表"><a href="#2-2-2-制表" class="headerlink" title="2.2.2 制表"></a>2.2.2 制表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">\begin&#123;array&#125;&#123;|c|c|&#125;</div><div class="line">\hline</div><div class="line">&#123;1111111111&#125; &amp; 2 \\\\</div><div class="line">\hline</div><div class="line">3 &amp; 4 \\\\</div><div class="line">\hline</div><div class="line">\end&#123;array&#125;</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>\begin{array}{|c|c|}<br>\hline<br>{1111111111} &amp; 2 \\<br>\hline<br>{balabala} &amp; 你好啊 {}^\land\_{}^\land \\<br>\hline<br>\end{array}<br>$$</p>
<p>可以看到，其实其他很多东西都可以很灵活的表达出来。碰到其他有趣的我会继续写出来的。</p>
<h2 id="3-常用数学符号"><a href="#3-常用数学符号" class="headerlink" title="3. 常用数学符号"></a>3. 常用数学符号</h2><blockquote>
<p>这里提供一个<a href="http://files.cnblogs.com/houkai/LATEX%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8.rar" target="_blank" rel="external">文档下载</a>，如果上面的链接失效，也可以到我的 <a href="https://github.com/mk43/BlogResource/blob/master/LaTex/LATEX%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8.pdf" target="_blank" rel="external">GitHub 下载 pdf 版</a>。下面举几个例子。</p>
</blockquote>
<h3 id="3-1-希腊字母"><a href="#3-1-希腊字母" class="headerlink" title="3.1 希腊字母"></a>3.1 希腊字母</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">\begin&#123;array&#125;&#123;|c|c|c|c|c|c|c|c|&#125;</div><div class="line">\hline</div><div class="line">&#123;\alpha&#125; &amp; &#123;\backslash alpha&#125; &amp; &#123;\theta&#125; &amp; &#123;\backslash theta&#125; &amp; &#123;o&#125; &amp; &#123;o&#125; &amp; &#123;\upsilon&#125; &amp; &#123;\backslash upsilon&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\beta&#125; &amp; &#123;\backslash beta&#125; &amp; &#123;\vartheta&#125; &amp; &#123;\backslash vartheta&#125; &amp; &#123;\pi&#125; &amp; &#123;\backslash pi&#125; &amp; &#123;\phi&#125; &amp; &#123;\backslash phi&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\gamma&#125; &amp; &#123;\backslash gamma&#125; &amp; &#123;\iota&#125; &amp; &#123;\backslash iota&#125; &amp; &#123;\varpi&#125; &amp; &#123;\backslash varpi&#125; &amp; &#123;\varphi&#125; &amp; &#123;\backslash varphi&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\delta&#125; &amp; &#123;\backslash delta&#125; &amp; &#123;\kappa&#125; &amp; &#123;\backslash kappa&#125; &amp; &#123;\rho&#125; &amp; &#123;\backslash rho&#125; &amp; &#123;\chi&#125; &amp; &#123;\backslash chi&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\epsilon&#125; &amp; &#123;\backslash epsilon&#125; &amp; &#123;\lambda&#125; &amp; &#123;\backslash lambda&#125; &amp; &#123;\varrho&#125; &amp; &#123;\backslash varrho&#125; &amp; &#123;\psi&#125; &amp; &#123;\backslash psi&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\varepsilon&#125; &amp; &#123;\backslash varepsilon&#125; &amp; &#123;\mu&#125; &amp; &#123;\backslash mu&#125; &amp; &#123;\sigma&#125; &amp; &#123;\backslash sigma&#125; &amp; &#123;\omega&#125; &amp; &#123;\backslash omega&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\zeta&#125; &amp; &#123;\backslash zeta&#125; &amp; &#123;\nu&#125; &amp; &#123;\backslash nu&#125; &amp; &#123;\varsigma&#125; &amp; &#123;\backslash varsigma&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\eta&#125; &amp; &#123;\backslash eta&#125; &amp; &#123;\xi&#125; &amp; &#123;\backslash xi&#125; &amp; &#123;\tau&#125; &amp; &#123;\backslash tau&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\Gamma&#125; &amp; &#123;\backslash Gamma&#125; &amp; &#123;\Lambda&#125; &amp; &#123;\backslash Lambda&#125; &amp; &#123;\Sigma&#125; &amp; &#123;\backslash Sigma&#125; &amp; &#123;\Psi&#125; &amp; &#123;\backslash Psi&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\Delta&#125; &amp; &#123;\backslash Delta&#125; &amp; &#123;\Xi&#125; &amp; &#123;\backslash Xi&#125; &amp; &#123;\Upsilon&#125; &amp; &#123;\backslash Upsilon&#125; &amp; &#123;\Omega&#125; &amp; &#123;\backslash Omega&#125; \\\\</div><div class="line">\hline</div><div class="line">&#123;\Omega&#125; &amp; &#123;\backslash Omega&#125; &amp; &#123;\Pi&#125; &amp; &#123;\backslash Pi&#125; &amp; &#123;\Phi&#125; &amp; &#123;\backslash Phi&#125; &amp; &#123;&#125; &amp; &#123;&#125; \\\\</div><div class="line">\hline</div><div class="line">\end&#123;array&#125;</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>\begin{array}{|c|c|c|c|c|c|c|c|}<br>\hline<br>{\alpha} &amp; {\backslash alpha} &amp; {\theta} &amp; {\backslash theta} &amp; {o} &amp; {o} &amp; {\upsilon} &amp; {\backslash upsilon} \\<br>\hline<br>{\beta} &amp; {\backslash beta} &amp; {\vartheta} &amp; {\backslash vartheta} &amp; {\pi} &amp; {\backslash pi} &amp; {\phi} &amp; {\backslash phi} \\<br>\hline<br>{\gamma} &amp; {\backslash gamma} &amp; {\iota} &amp; {\backslash iota} &amp; {\varpi} &amp; {\backslash varpi} &amp; {\varphi} &amp; {\backslash varphi} \\<br>\hline<br>{\delta} &amp; {\backslash delta} &amp; {\kappa} &amp; {\backslash kappa} &amp; {\rho} &amp; {\backslash rho} &amp; {\chi} &amp; {\backslash chi} \\<br>\hline<br>{\epsilon} &amp; {\backslash epsilon} &amp; {\lambda} &amp; {\backslash lambda} &amp; {\varrho} &amp; {\backslash varrho} &amp; {\psi} &amp; {\backslash psi} \\<br>\hline<br>{\varepsilon} &amp; {\backslash varepsilon} &amp; {\mu} &amp; {\backslash mu} &amp; {\sigma} &amp; {\backslash sigma} &amp; {\omega} &amp; {\backslash omega} \\<br>\hline<br>{\zeta} &amp; {\backslash zeta} &amp; {\nu} &amp; {\backslash nu} &amp; {\varsigma} &amp; {\backslash varsigma} &amp; {} &amp; {} \\<br>\hline<br>{\eta} &amp; {\backslash eta} &amp; {\xi} &amp; {\backslash xi} &amp; {\tau} &amp; {\backslash tau} &amp; {} &amp; {} \\<br>\hline<br>{\Gamma} &amp; {\backslash Gamma} &amp; {\Lambda} &amp; {\backslash Lambda} &amp; {\Sigma} &amp; {\backslash Sigma} &amp; {\Psi} &amp; {\backslash Psi} \\<br>\hline<br>{\Delta} &amp; {\backslash Delta} &amp; {\Xi} &amp; {\backslash Xi} &amp; {\Upsilon} &amp; {\backslash Upsilon} &amp; {\Omega} &amp; {\backslash Omega} \\<br>\hline<br>{\Omega} &amp; {\backslash Omega} &amp; {\Pi} &amp; {\backslash Pi} &amp; {\Phi} &amp; {\backslash Phi} &amp; {} &amp; {} \\<br>\hline<br>\end{array}<br>$$</p>
<p>写太累了😂😂😂。。。其他的详见 <a href="https://github.com/mk43/BlogResource/blob/master/LaTex/LATEX%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8.pdf" target="_blank" rel="external">PDF</a>。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><blockquote>
<p>通过这样梳理一下基本的公式都能插入了，而且也会如何查资料。对于自己日后学习 LaTeX 写论文有很大帮助。以下建议带有很强的主观性，仅供参考。</p>
</blockquote>
<ul>
<li>公式一律使用另取一行，并且上下都空一行</li>
<li>一个公式一个语句，不要写在一个 <code>$$***$$</code> 里，保证<code>独立性</code>，一个公式错误不影响另一个公式。</li>
<li>风格统一，不要混用。比如上下标的写法：<code>x_{balabala}^{bala}</code></li>
<li>行间字母可以使用 <code>\\(a\\)</code> 代替 <code>a</code> ，养成自己的写作风格。</li>
</ul>
<p>最后：我的 <a href="http://fitzeng.org/">Blog</a> 和 <a href="https://github.com/mk43" target="_blank" rel="external">GitHub</a>，感谢阅读。</p>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><blockquote>
<p>十分感谢以下作者的无私分享。</p>
</blockquote>
<ol>
<li><a href="http://blog.csdn.net/xiahouzuoxin/article/details/26478179" target="_blank" rel="external">Markdown中插入数学公式的方法</a></li>
<li><a href="http://www.cnblogs.com/houkai/p/3399646.html" target="_blank" rel="external">LATEX数学公式基本语法</a></li>
<li><a href="https://liam0205.me/2014/09/08/latex-introduction/" target="_blank" rel="external">一份其实很短的 LaTeX 入门文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近在学习一些机器学习相关的知识，想把自己学习的东西通过 MD 的形式在线记录下来，但是之前一直没有开始行动，因为里面的公式什么的感觉实在是麻烦。于是今天打算花点时间了解一下&lt;a href=&quot;http://blog.csdn.net/xiahouzuoxin/article/details/26478179&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;如何在 markdown 中插入数学公式&lt;/code&gt;&lt;/a&gt;，发现其实很简单，大概花一个小时左右就能知道如何编写了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Math" scheme="http://fitzeng.org/tags/Math/"/>
    
      <category term="MarkDown" scheme="http://fitzeng.org/tags/MarkDown/"/>
    
      <category term="Formula" scheme="http://fitzeng.org/tags/Formula/"/>
    
      <category term="LaTeX" scheme="http://fitzeng.org/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>GitNote</title>
    <link href="http://fitzeng.org/2017/12/16/GitNote/"/>
    <id>http://fitzeng.org/2017/12/16/GitNote/</id>
    <published>2017-12-16T03:27:00.000Z</published>
    <updated>2017-12-17T06:36:06.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><blockquote>
<p>在使用 Git 时有一种感觉就是只会 <code>add | commit | push</code> 三个命令。因为这三个命令似乎足以把代码提交到 GitHub 上，即使是碰到某个问题，也可以直接 Google。但是对于其中的逻辑和版本管理的精髓没有体会到，而只是作为一个在线代码仓库在使用，这样做也没有什么不可以，但是如果能系统的了解为什么要有版本管理工具，以及版本管理工具能够给我们提供怎么样的管理服务，对于使用工具的我们来说有很大帮助。不用记住命令，只是以后遇到问题时知道这个工具有实现的方式就足够了。</p>
<p>现在我系统的看了一下官方的 Git 入门教程 <a href="https://www.nowcoder.com/courses/2#chapter-14" target="_blank" rel="external">Git 官方教程（中字）</a> 里面通过描述对命令的使用情景进而选择命令进行操作的方式，使得命令很容易理解也容易加深记忆。比起单一的命令用文字解释这种方式，对于不熟悉 Git 的人来说是十分友好的。但是，看完容易忘，所以写了这篇整理笔记用作辅助查询。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><h3 id="1-1-了解帮助命令"><a href="#1-1-了解帮助命令" class="headerlink" title="1.1 了解帮助命令"></a>1.1 了解帮助命令</h3><ul>
<li><code>git help</code> : 查看命令</li>
<li><code>git help add</code> : 查看 <code>git add</code> 命令的具体解释</li>
</ul>
<h3 id="1-2-仓库初始化"><a href="#1-2-仓库初始化" class="headerlink" title="1.2 仓库初始化"></a>1.2 仓库初始化</h3><ul>
<li><code>git init</code> : 创建 <code>.git</code>, 适合在已存在项目追加版本控制</li>
<li><code>git init projectname</code> : 创建 <code>projectname/.git</code>, 适合项目开始时加入版本控制</li>
</ul>
<h3 id="1-3-文件基本操作"><a href="#1-3-文件基本操作" class="headerlink" title="1.3 文件基本操作"></a>1.3 文件基本操作</h3><ul>
<li><code>git add filename/*</code> : 添加文件[产生暂存文件]</li>
<li><code>git commmit -m &quot;message&quot;</code> : 将添加的文件提交到本地仓库[产生提交文件]</li>
<li><code>git rm filename</code> : 移除文件，使用 <code>rm filename</code> 的有暂存</li>
<li><code>git add -u .</code> : 如果之前使用非 git 命令删除文件，可以使用这个命令把当前目录的文件重新遍历清除</li>
<li><code>git rm --cache filename</code> : 暂存但是不参与跟踪</li>
<li><code>git mv filepath newfilepath</code> : 移动文件</li>
<li><code>git rm filepath &amp;&amp; git add newfilepath</code> : 移动文件，之前使用非 git 命令移动文件</li>
<li><code>git add -A .</code> : 如果之前使用非 git 命令移动文件，可以使用这个命令把当前目录的文件重新遍历移动，和 <code>rm</code> 命令类似</li>
<li><code>git reset etc...</code> : 历史提交管理(回退，合并…)，checkout 更关注文件</li>
</ul>
<h3 id="1-4-查看文件修改"><a href="#1-4-查看文件修改" class="headerlink" title="1.4 查看文件修改"></a>1.4 查看文件修改</h3><ul>
<li><code>git status</code> : 查看文件信息</li>
<li><code>git diff</code> : 查看修改[工作树和暂存文件]</li>
<li><code>git diff --staged</code> : 查看修改[暂存文件和最近提交文件]</li>
<li><code>git diff HEAD</code> : 查看修改[工作树和最近提交文件]</li>
<li><code>git diff --word-diff</code> : 查看修改的单词用颜色标出</li>
<li><code>git diff --stat</code> : 查看修改的文件名</li>
</ul>
<blockquote>
<p>参考资料 <a href="http://www.cnblogs.com/feeland/p/4500721.html" target="_blank" rel="external">0. Git 学习（三）本地仓库操作——git add &amp; commit</a> 了解 git 版本库实现</p>
</blockquote>
<h3 id="1-5-查看提交-Log"><a href="#1-5-查看提交-Log" class="headerlink" title="1.5 查看提交 Log"></a>1.5 查看提交 Log</h3><ul>
<li><code>git log</code> : 显示提交信息</li>
<li><code>git log --oneline</code> : 显示提交 Message</li>
<li><code>git log --stat</code> : 显示提交文件名级详细修改信息</li>
<li><code>git log --patch</code> : 显示提交文件内容级详细修改信息 </li>
<li><code>git log --graph</code> : 用图显示提交记录</li>
<li><code>git log --graph --all --decorate --oneline</code> : 去除冗余信息，更加直观显示每条分支每次提交</li>
<li><code>git log --stat -- filename</code> : 文件提交记录（不记录路径移动）</li>
<li><code>git log --stat -M --follow -- filename</code> : 看到完整的文件操作过程</li>
</ul>
<h3 id="1-6-忽略文件"><a href="#1-6-忽略文件" class="headerlink" title="1.6 忽略文件"></a>1.6 忽略文件</h3><ul>
<li><code>touch .gitignore</code> : 创建文件(次级目录也可以创建)</li>
<li><code>vim .gitignore</code> : 编辑文件添加 ignore 文件。<code>*.log | tmp/ | .sass-cache etc...</code></li>
<li><code>git ls-files --others --ignored --exclude-standard</code> : 查看被 ignore 的文件</li>
<li><code>git reflog</code> : 详细修改日志</li>
</ul>
<h3 id="1-7-分支操作"><a href="#1-7-分支操作" class="headerlink" title="1.7 分支操作"></a>1.7 分支操作</h3><ul>
<li><code>git branch branchname</code> : 创建分支</li>
<li><code>git branch</code> : 显示分支</li>
<li><code>git branch -d branchname</code> : 删除分支</li>
<li><code>git branch -D branchname</code> : 删除未合并分支</li>
<li><code>git checkout branchname</code> : 切换分支</li>
<li><code>git checkout commitID</code> : 工作树切换到 commitID 时</li>
<li><code>git checkout -- filename</code> : 清理掉最后一次提交内容</li>
<li><code>git checkout -b branchname</code> : 创建新分支并且进入该分支</li>
<li><code>git merge branchname</code> : 和并 branchname 分支到目前所在分支(合并时文件冲突要手动解决)</li>
<li><code>git merge --abort</code> : 清除工作目录和暂存区</li>
<li><code>git merge squash branchname</code> : 将合并的分支改变变成一个 commit</li>
<li><code>git rebase branchname</code> : 将当前分支历史提交合并到 branchname 分支</li>
</ul>
<blockquote>
<p>参考资料 <a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9" target="_blank" rel="external">2. 代码合并：Merge、Rebase 的选择</a></p>
</blockquote>
<h3 id="1-8-远程操作"><a href="#1-8-远程操作" class="headerlink" title="1.8 远程操作"></a>1.8 远程操作</h3><ul>
<li><code>git remote add origin  https://github.com/accountname/projectname</code></li>
<li><code>git remote set-url origin newUrl</code> : 改变 URL</li>
<li><code>git remote rm origin</code> : 删除</li>
<li><code>git remote -v</code> : 查看 URL</li>
<li><code>git fetch origin</code> : 抓取远程分支，本地会有一个 <code>remotehostname/branchname</code> 的分支，一般用于查看伙伴代码</li>
<li><code>git pull origin</code> : 和 fetch 类似，但是是取回远程更新和本地合并。相当于先 fetch 再 merge。</li>
<li><code>git push origin</code> : push 到远程仓库</li>
</ul>
<blockquote>
<p>参考资料 <a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">1. Git远程操作详解</a></p>
</blockquote>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><blockquote>
<p>其实在开始把 Git 整个命令流程学习下来之前，对 Git 理解十分浅显，使用命令也是抱着试试看的心态，错了搜索解决方法重试，对了就不追究原因了。这种方式感觉更加浪费时间，而且很可能多次遇到重复问题。觉得以后学习某个东西还是得大概了解整个系统才好，想快速入门未尝不可，但是闲下来的时候要去多问问为什么，这样有了宏观的概念，出了问题说不定能自己摸索着解决。还有一点，实践确实是比单一的阅读或看视频更加记忆深刻，对命令的理解也是同理，所以最好都敲一遍。</p>
</blockquote>
<ul>
<li><a href="https://github.com/mk43" target="_blank" rel="external">GitHub</a></li>
<li><a href="http://fitzeng.org">Blog</a></li>
<li><a href="https://juejin.im/user/5791a7a30a2b580061a0e352" target="_blank" rel="external">掘金</a></li>
</ul>
<p>多谢阅读 ^_^</p>
<h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><ul>
<li><a href="https://www.nowcoder.com/courses/2#chapter-14" target="_blank" rel="external">-1. GitHub&amp;Git入门基础</a></li>
<li><a href="http://www.cnblogs.com/feeland/p/4500721.html" target="_blank" rel="external">0. Git 学习（三）本地仓库操作——git add &amp; commit</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">1. Git远程操作详解</a></li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9" target="_blank" rel="external">2. 代码合并：Merge、Rebase 的选择</a></li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes" target="_blank" rel="external">3. GitHub 高质量的Git中文教程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在使用 Git 时有一种感觉就是只会 &lt;code&gt;add | commit | push&lt;/code&gt; 三个命令。因为这三个命令似乎足以把代码提交到 GitHub 上，即使是碰到某个问题，也可以直接 Google。但是对于其中的逻辑和版本管理的精髓没有体会到，而只是作为一个在线代码仓库在使用，这样做也没有什么不可以，但是如果能系统的了解为什么要有版本管理工具，以及版本管理工具能够给我们提供怎么样的管理服务，对于使用工具的我们来说有很大帮助。不用记住命令，只是以后遇到问题时知道这个工具有实现的方式就足够了。&lt;/p&gt;
&lt;p&gt;现在我系统的看了一下官方的 Git 入门教程 &lt;a href=&quot;https://www.nowcoder.com/courses/2#chapter-14&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git 官方教程（中字）&lt;/a&gt; 里面通过描述对命令的使用情景进而选择命令进行操作的方式，使得命令很容易理解也容易加深记忆。比起单一的命令用文字解释这种方式，对于不熟悉 Git 的人来说是十分友好的。但是，看完容易忘，所以写了这篇整理笔记用作辅助查询。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://fitzeng.org/tags/Git/"/>
    
      <category term="GitHub" scheme="http://fitzeng.org/tags/GitHub/"/>
    
      <category term="Tool" scheme="http://fitzeng.org/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>完美解决 Linux 的【dpkg： warning： files list file for package &#39;XXXXXXX&#39; missing, assuming package has no files currently installed】Bug</title>
    <link href="http://fitzeng.org/2017/11/04/linuxDpkgBug/"/>
    <id>http://fitzeng.org/2017/11/04/linuxDpkgBug/</id>
    <published>2017-11-04T03:27:00.000Z</published>
    <updated>2017-11-04T15:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><blockquote>
<p>估计是之前动了或者损坏了 <code>/var/lib/dpkg/info</code> 里面的文件，每次执行 apt 类的命令总是输出一大段东西，在网上找了很多资料，有解决方案，但是不全。。。很多都是失败的。最后我发现 reinstall 可以解决，所以打算写个脚本执行文件。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-解决方法"><a href="#1-解决方法" class="headerlink" title="1.解决方法"></a>1.解决方法</h2><h3 id="1-1-创建一下三个文件"><a href="#1-1-创建一下三个文件" class="headerlink" title="1.1 创建一下三个文件"></a>1.1 创建一下三个文件</h3><ul>
<li>fixit.py</li>
<li>fix.sh</li>
<li>txt</li>
</ul>
<h3 id="1-2-填写内容"><a href="#1-2-填写内容" class="headerlink" title="1.2 填写内容"></a>1.2 填写内容</h3><p>先来最简单的 <code>fix.sh</code>，不用填写内容，是空文件。</p>
<p>接着就写 <code>txt</code>，直接把错误日志复制进去，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dpkg: warning: files list file for package &apos;libodbc1:amd64&apos; missing; assuming package has no files currently installed</div><div class="line">dpkg: warning: files list file for package &apos;dh-autoreconf&apos; missing; assuming package has no files currently installed</div><div class="line">dpkg: warning: files list file for package &apos;erlang-webtool&apos; missing; assuming package has no files currently installed</div><div class="line">dpkg: warning: files list file for package &apos;libhtml-template-perl&apos; missing; assuming package has no files currently installed</div><div class="line">.......</div><div class="line">dpkg: warning: files list file for package &apos;libvirt-dev:amd64&apos; missing; assuming package has no files currently installed</div><div class="line">dpkg: warning: files list file for package &apos;autopoint&apos; missing; assuming package has no files currently installed</div><div class="line">dpkg: warning: files list file for package &apos;libconfig-general-perl&apos; missing; assuming package has no files currently installed</div><div class="line">dpkg: warning: files list file for package &apos;ubuntu-cloud-keyring&apos; missing; assuming package has no files currently installed</div><div class="line">dpkg: warning: files list file for package &apos;tgt&apos; missing; assuming package has no files currently installed</div><div class="line">dpkg: warning: files list file for package &apos;libfdt1:amd64&apos; missing; assuming package has no files currently installed</div></pre></td></tr></table></figure>
<p>下面写 <code>fixit.py</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding: utf-8 -*-</div><div class="line"></div><div class="line">__author__ = &apos;Fitzeng&apos;</div><div class="line"></div><div class="line">import re</div><div class="line"></div><div class="line">def main():</div><div class="line">    fix = open(&apos;fix.sh&apos;, &apos;w+&apos;)</div><div class="line">    for line in open(&quot;txt&quot;):</div><div class="line">        pkg = re.match(re.compile(&apos;&apos;&apos;dpkg: warning: files list file for package &apos;(.+)&apos; &apos;&apos;&apos;), line)</div><div class="line">        if pkg:</div><div class="line">            cmd = &quot;sudo apt-get install --reinstall &quot; + pkg.group(1)</div><div class="line">            fix.write(cmd + &apos;\n&apos;)</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h3 id="1-3-执行命令"><a href="#1-3-执行命令" class="headerlink" title="1.3 执行命令"></a>1.3 执行命令</h3><p>如果权限不够可以直接先 <code>chmod 777 *</code>，然后执行 <code>python fixit.py</code>，这时 <code>fix.sh</code> 就变成下面的样子了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install --reinstall libodbc1:amd64</div><div class="line">sudo apt-get install --reinstall dh-autoreconf</div><div class="line">sudo apt-get install --reinstall erlang-webtool</div><div class="line">sudo apt-get install --reinstall libhtml-template-perl</div><div class="line">sudo apt-get install --reinstall erlang-base</div><div class="line"></div><div class="line">.......</div><div class="line"></div><div class="line">sudo apt-get install --reinstall qemu-system-misc</div><div class="line">sudo apt-get install --reinstall libvirt-dev:amd64</div><div class="line">sudo apt-get install --reinstall autopoint</div><div class="line">sudo apt-get install --reinstall libconfig-general-perl</div><div class="line">sudo apt-get install --reinstall ubuntu-cloud-keyring</div><div class="line">sudo apt-get install --reinstall tgt</div><div class="line">sudo apt-get install --reinstall libfdt1:amd64</div></pre></td></tr></table></figure>
<p>最后执行 <code>./fix.sh</code>。</p>
<p>然后就是等待执行结束了。</p>
<p>效果如下，一行一行 <code>dpkg: warning:</code> 在减少。<br><img src="/2017/11/04/linuxDpkgBug/debuging.png" alt=""><br><img src="/2017/11/04/linuxDpkgBug/debuging1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;估计是之前动了或者损坏了 &lt;code&gt;/var/lib/dpkg/info&lt;/code&gt; 里面的文件，每次执行 apt 类的命令总是输出一大段东西，在网上找了很多资料，有解决方案，但是不全。。。很多都是失败的。最后我发现 reinstall 可以解决，所以打算写个脚本执行文件。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://fitzeng.org/tags/linux/"/>
    
      <category term="dpkg" scheme="http://fitzeng.org/tags/dpkg/"/>
    
  </entry>
  
  <entry>
    <title>一个小白使用 devstack 部署 openstack 的心路历程</title>
    <link href="http://fitzeng.org/2017/11/04/deployOpenstackByDevstack/"/>
    <id>http://fitzeng.org/2017/11/04/deployOpenstackByDevstack/</id>
    <published>2017-11-04T03:27:00.000Z</published>
    <updated>2017-11-04T04:57:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><blockquote>
<p>作为一个想要入门云计算的人来说，大多数人的第一步就是学习 openstack，而学习 openstack 的人面临的第一步就是第一个‘难题’，使用自动化部署工具 devstack 部署 openstack 环境。第一次接触这个东西，花了两天多时间在 Ubuntu Server 和 Ubuntu Desktop 的 16.04 版本上成功部署。有很多人说 Desktop 版有很多坑，亲测问题确实比 Server 版多，但都是可解决的。其中最对初学者不友好的就是网络问题，下面会介绍为什么。所以如果你自己买了国外的 VPS 那就好办了，因为有个骚操作要用到，如果你网速好可能你遇不到这些问题就可以忽略。</p>
<p>下面会分两个部分介绍，都会将 Server 和 Desktop 上的部署过程描述一遍。<br>教程推荐 <a href="https://docs.openstack.org/devstack/latest/" target="_blank" rel="external">官方的 Doc</a>和<a href="https://zhuanlan.zhihu.com/p/28996062" target="_blank" rel="external">避坑指南</a><br>教程这个东西对于初学者不宜太多，容易乱，只要有一个正确的执行框架就好。碰到其他 bug 直接 Google 就好。</p>
</blockquote>
<a id="more"></a>
<p>然后介绍下我的环境吧</p>
<ul>
<li>Mac 10.12.6</li>
<li>VirtualBox 5.1.28</li>
<li>Ubuntu Server 16.04 4G+20G (临时测试 devstack，听说坑少)</li>
<li>Ubuntu Desktop 16.04 4G+80G (平时使用)</li>
<li>VPS(最好有) (由于是乞丐版，不适合直接部署和平时学习)</li>
</ul>
<h2 id="1-Ubuntu-Server-版"><a href="#1-Ubuntu-Server-版" class="headerlink" title="1.Ubuntu Server 版"></a>1.Ubuntu Server 版</h2><h3 id="安装-Ubuntu-Server"><a href="#安装-Ubuntu-Server" class="headerlink" title="安装 Ubuntu Server"></a>安装 Ubuntu Server</h3><p>首先肯定是要在 Virtual Box 安装 Ubuntu Server 了，这一步略过。相信你已经是接触过一段时间虚拟机的人了，但是一点注意，竟可能分多一点内存和硬盘。由于我不打算日后再这 Server 版使用，所以我的配置是 4G + 20G</p>
<h3 id="SSH-登录虚拟机"><a href="#SSH-登录虚拟机" class="headerlink" title="SSH 登录虚拟机"></a>SSH 登录虚拟机</h3><p>当你创建完成之后面临的一个问题就是那个界面太丑了。。。所以如果可以在宿主机上操作就好了，SSH 正好满足你。<br>至于 SSH 不通使用不了的自己查查资料吧，这里我主要介绍网卡配置，我使用了两个网卡：<br>第一个：<br><img src="/2017/11/04/deployOpenstackByDevstack/wk1.png" alt=""><br><img src="/2017/11/04/deployOpenstackByDevstack/wk1port.png" alt=""><br>做端口映射，将主机的 2222 映射到虚拟机的 22，这条是为了以后使用 SSH。<br>第二个：<br><img src="/2017/11/04/deployOpenstackByDevstack/wk2.png" alt=""><br>配完之后再在全局配置中设置你所选中的网卡启用 DHCP。对于网卡各种连接模式不熟的可以查查资料了解一下。</p>
<p>然后连接就是直接在主机下使用  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -p 2222 fitzeng@127.0.0.1</div></pre></td></tr></table></figure>
<p>fitzeng 改成你的用户名。<br>如果你出现各种问题连不上可以注意一下两点：<br>1.防火墙<br>2.把 <code>~/.ssh</code> 文件夹下的 <code>known_hosts</code> 文件删了再重连</p>
<h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><blockquote>
<p>这里的主教程以官方提供的为准，并且那些注意点我会更新。</p>
</blockquote>
<p>部署的脚本要求是拥有 root 权限的非 root 用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo useradd -s /bin/bash -d /opt/stack -m stack</div><div class="line"></div><div class="line">echo &quot;stack ALL=(ALL) NOPASSWD: ALL&quot; | sudo tee /etc/sudoers.d/stack</div><div class="line">sudo su - stack</div><div class="line"></div><div class="line">cd /opt/stack</div><div class="line">git clone https://git.openstack.org/openstack-dev/devstack</div><div class="line">cd devstack</div></pre></td></tr></table></figure>
<p>如果上面 clone 太慢或者 clone 不下来的话可以试试 github 的源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/openstack-dev/devstack.git</div></pre></td></tr></table></figure>
<p>然后就是添加配置了，如果不懂推荐直接使用官方页面介绍的。或者使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp samples/local.conf ./</div><div class="line">vim local.conf</div></pre></td></tr></table></figure>
<p>如果你幸运，讲道理最后执行 <code>./stack.sh</code> 直接一路到底。。。但是还有很多坑正在等待着我们。<br>但但是有一个很好的是他的 Log 和报错十分清新，很快可以定位问题所在，有时候直接搜 Log 都会出现解决方法。<br>如果脚本直接退出提示没有 HOST_IP。那么直接在 <code>local.conf</code> 后面添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HOST_IP=x.x.x.x</div><div class="line">GIT_BASE=https://github.com</div></pre></td></tr></table></figure>
<p>HOST_IP具体是什么在你的虚拟机上 ifconfig 查看。然后推荐把 git 源换成 github 的。<br>这里你可以检测一下你的源有没有问题 <code>apt-get update</code> 有的话直接把有问题的源在 <code>/etc/apt/sources.list.d/</code> 目录下移除，移除前建议备份一下。然后推荐 <code>apt-get upgrade</code> 一下，Python 版本保持默认的 2.7.X 就好，如果出现什么和 Python 3.4 不匹配的 Log 直接忽略。如果你换成 3.4 很多库会出问题。如果你是 Python 3.X，可以把 <code>/user/bin/</code> 下的 Python2.X 链接到该目录下的 Python 文件。这时执行 <code>python -V</code> 就能看到结果了。</p>
<p>但但但是，上面只是解决了有形的 Bug，还有就是无形的 Bug，你将面临网络问题，如果你想顺畅点可以直接更换源。<br>修改 pip 源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mkdir ~/.pip</div><div class="line">vim ~/.pip/pip.conf</div><div class="line"></div><div class="line">填入：</div><div class="line">[global]</div><div class="line">trusted-host=mirrors.aliyun.com</div><div class="line">index-url=http://mirrors.aliyun.com/pypi/simple</div></pre></td></tr></table></figure>
<p>修改 sources.list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</div><div class="line">sudo vim /etc/apt/sources.list</div><div class="line"></div><div class="line">填入：</div><div class="line"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</div><div class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</div><div class="line">deb http://archive.canonical.com/ubuntu xenial partner</div><div class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</div></pre></td></tr></table></figure>
<p>都改成 aliyun 的。到这时候如果你的网络没什么问题，可能会出点环境小问题，dkpg 和各种包等之类的问题，一搜网上基本都有解决方案。</p>
<p>但但但是，如果你的网速下载某些包不超 10Kb/s 那就要用骚操作了。。。因为会一直卡着，网一断又得重新开始，先 unstack，clean 再 stack，十分不友好。出现问题大多是在下载某个 git 仓库和某些包的时候。尤其是 <code>nova</code> <code>horizon</code> 之类的，大小到了 300+M。</p>
<p>这里介绍一个方法：<br>思路是先 SSH 上你的国外 VPS，下载你的 git 仓库或其他文件。然后再 SCP 到你的虚拟机上。主要是这样不会中断，而且无形中就可以是多线程操作，开几个终端 SCP 好几个文件。<br>看看速度对比效果吧，<br>虚拟机上下载：<br><img src="/2017/11/04/deployOpenstackByDevstack/horizon2.png" alt=""><br>VPS 上下载：<br><img src="/2017/11/04/deployOpenstackByDevstack/horizon.png" alt=""><br>之后自己 SCP 就好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo scp -P 10800 -r root@xx.xx.xx.xx:/fitzeng/horizon /etc/stack/</div></pre></td></tr></table></figure>
<p>-r 是 cp 文件夹，然后端口，IP 填你自己的后面跟目录。这里可能也有点慢，但是比之前的好而且稳定。</p>
<p><img src="/2017/11/04/deployOpenstackByDevstack/nova.png" alt=""><br><img src="/2017/11/04/deployOpenstackByDevstack/cirros.png" alt=""><br>这一切操作都源于友好的 log 机制，看上面的图片我们可以知道下载地址和存放目录，所以，知道这些手段就多了起来。<br>网速够快也可以直接在本地 clone。<br><img src="/2017/11/04/deployOpenstackByDevstack/nova2.png" alt=""></p>
<p>有了这些操作基本就意味着你解决了网络问题，借助 google 基本可以解决其他库和环境的问题。<br>成功图上传一波：<br><img src="/2017/11/04/deployOpenstackByDevstack/finish.png" alt=""></p>
<h2 id="2-Ubuntu-Desktop-版"><a href="#2-Ubuntu-Desktop-版" class="headerlink" title="2.Ubuntu Desktop 版"></a>2.Ubuntu Desktop 版</h2><p>基本步骤是和前面一致的，出的问题可能就是你之前在 Ubuntu 上装过各种软件(我装的 Sogou 输入法，里面的 fcitx 源影响了速度，甚至有时候直接卡这不动)，更改了软件源或者做过其它的工具更改，按照前面的配置亲测可行。如果你之前在 Ubuntu Server 版上装过，直接把文件 SCP 过来，如果虚拟机之间不能通讯，可以先 SCP 到宿主机，再从宿主机通过文件共享的方式共享到 Ubuntu Desktop。<br>然后运行就可以了，有了前面的基础就很简单了。</p>
<p>那就看直接看结果吧：<br><img src="/2017/11/04/deployOpenstackByDevstack/d1.png" alt=""><br><img src="/2017/11/04/deployOpenstackByDevstack/d2.png" alt=""><br><img src="/2017/11/04/deployOpenstackByDevstack/d3.png" alt=""><br><img src="/2017/11/04/deployOpenstackByDevstack/d4.png" alt=""></p>
<h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3.后记"></a>3.后记</h2><p>说实话，这不太算技术文章，纯属个人记录。本来不太想写，但是感觉国内环境对开发者有点不友好，如果这篇文章能对初学者有部分帮助我就满意了，能够使初学者继续学习下去。然后这是部署完之后写的，部署的过程远不如写的这么轻松，但是我现在有信心去解决部署过程中碰到的问题，这才是重点。希望你也是。每个人的环境都不一样，出现的问题也不可能一样，所以如果你照上面做了还没有解决可以留言大家一起讨论。</p>
<p>最后：<br>多谢阅读<br>祝大家一遍过 ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0.前言&quot;&gt;&lt;/a&gt;0.前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作为一个想要入门云计算的人来说，大多数人的第一步就是学习 openstack，而学习 openstack 的人面临的第一步就是第一个‘难题’，使用自动化部署工具 devstack 部署 openstack 环境。第一次接触这个东西，花了两天多时间在 Ubuntu Server 和 Ubuntu Desktop 的 16.04 版本上成功部署。有很多人说 Desktop 版有很多坑，亲测问题确实比 Server 版多，但都是可解决的。其中最对初学者不友好的就是网络问题，下面会介绍为什么。所以如果你自己买了国外的 VPS 那就好办了，因为有个骚操作要用到，如果你网速好可能你遇不到这些问题就可以忽略。&lt;/p&gt;
&lt;p&gt;下面会分两个部分介绍，都会将 Server 和 Desktop 上的部署过程描述一遍。&lt;br&gt;教程推荐 &lt;a href=&quot;https://docs.openstack.org/devstack/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方的 Doc&lt;/a&gt;和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28996062&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;避坑指南&lt;/a&gt;&lt;br&gt;教程这个东西对于初学者不宜太多，容易乱，只要有一个正确的执行框架就好。碰到其他 bug 直接 Google 就好。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="devstack" scheme="http://fitzeng.org/tags/devstack/"/>
    
      <category term="openstack" scheme="http://fitzeng.org/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>Restart</title>
    <link href="http://fitzeng.org/2017/09/22/restart/"/>
    <id>http://fitzeng.org/2017/09/22/restart/</id>
    <published>2017-09-22T03:27:00.000Z</published>
    <updated>2017-09-23T14:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><blockquote>
<p>我的求职生活是从今年的 04-16 找实习开始到 09-22 拿到优招(秋招) Offer结束，中间共经历过了三家公司面试，面试经验不足，而且最近的面试已距现在两个多月了，细节记不清了，所以这不太算是面经，只是我个人对我自己找工作这小半年的总结以及我对找工作这件事的认识。首先说明我不是大神，只能从平静叙述整个找工作的过程，希望你能从中体会到一点什么就很满意了，在此先祝大家找工作顺利！</p>
</blockquote>
<a id="more"></a>
<h2 id="1-面试过程"><a href="#1-面试过程" class="headerlink" title="1. 面试过程"></a>1. 面试过程</h2><blockquote>
<p>自己要介绍自己在三家公司的面试过程，不涉及面试题目什么的，纯属叙述整个心理过程。不过后面我会补充一些资料和我参考的一些其他面试者的面经。</p>
</blockquote>
<p>下面我根据邮件理一下时间线：</p>
<h4 id="第一家公司（腾讯）实习-跪"><a href="#第一家公司（腾讯）实习-跪" class="headerlink" title="第一家公司（腾讯）实习-跪"></a>第一家公司（腾讯）实习-跪</h4><p><code>一面：04-16</code><br>大概记忆就是啥都问，读过我以前文章的都知道，我以前是写 Android 的，但是他问了 Linux，C/C++，操作系统，JVM，设计模式，算法，Andriod，还有一些小智力测试题。目前我只能记清这些知识点，这个过程是一开始问了十多分钟项目，再问问 Android 基础(答得很烂)，再问 JVM(也很烂😭)，接着就给我一张纸上面两道题手写代码，面试官就喝水去了，然后我没意识到有两面题，只做了第一面的两道告诉面试官我做好了，他过来了，我跟他讲解代码（因为字迹实在难看清😂），在他的引导下慢慢把第二题进行优化。接着就是问问计算机基础的一些知识。面了有将近一个小时，这是我第一次面试，流了一身的汗。<br>我对面试结果是很不乐观的，因为我是在 04-1X 才知道这是已经接近实习招聘尾声。基本上大多数公司的内推什么的都弄完了，而我也是后知后觉，04-14 晚上做简历，因为听说腾讯 04-15 截止投递实习简历，到 04-15 早上，我做完简历就投了。可能是里面有一些学长学姐吧，当天下午就收到内推通知并告知完善简历，接着晚上就收到通知明天去面试。整个感觉很惊喜，但是其实后来跪了之后想想其实是自己没有做好准备，根本不知道准备实习人家从三月份就开始找了，所以有信息来源很重要。本来以为一面要挂的结果第二天晚上就通知过了并且过一天第二面。</p>
<p><code>二面：04-18</code><br>这一面很崩，后来才知道可能是压力面。说实话，第一面能过之后我已经放松了很多。二面内容和 Android 一毛钱关系都没有。同样一开始聊聊项目，然后桌子上有一堆大概十厘米厚的 A4 纸，拿一张，口述一道题然后写代码，这里提醒下大家如果遇到这种情况，最好在动笔前问清楚问题条件，比如我一动笔写了一点然后问他字符串是以什么形式存储的，然后他回答了 char *，接着给我感觉有点不太舒服，气氛很严肃，但是我又问了一个问题：是写伪代码还是？结果崩了，他立马说，都这时候了还写什么伪代码！好，我默默的划掉，又写了一段代码，由于混在一起，我就把代码又抄了一遍，但是有些语句一开始抄漏所以出现了两句代码在一行的情况。。。他看了边叹气边说：“这些的什么，乱七八糟的，缩进XXXXXXXXX”，然后我弱弱地说要不我再抄一遍把格式调调？结果他说还调什么调，浪费我时间！😂😂😂😂😂😂把我吓坏了，然后弱弱的给他讲解了代码，由于代码写的还不错，这里他没揪我的小辫子。然后他又说给你来一道博弈题？？？我黑人问号，我面的是 Android 吗？口述完题目后，他看到了我有点高兴，问我是不是看过类似的题目？我诚实的回答是。结果他说给你出道简单一点的题？？？？？念完题目之后我一脸懵逼，结果最后我对题目的看法和面试官不符，然后挂了。总结就是：抱歉，我不会演戏。。。当时想如果我稍微冷静一点，把博弈题拿下应该这面能过吧，但是没有如果。。。</p>
<h4 id="第二家公司（华为）1-实习-跪"><a href="#第二家公司（华为）1-实习-跪" class="headerlink" title="第二家公司（华为）1. 实习-跪"></a>第二家公司（华为）1. 实习-跪</h4><p><code>技术面：05-13</code><br>由于面试官不是做 Android，给我感觉连 Java 相关都不是，所以全程在聊天，什么你家在哪里？为什么不读研？你能接受加班吗？之类的。。。。大概二十多分钟，结束得很轻松。</p>
<p><code>综合面：05-13</code><br>由于技术面没问技术，所以这面大概就是和前面问的问题差多，时间也是差不多，感觉很水。。。</p>
<p>补充：前面都是同一天面完，感觉很诡异，不太像面试。。。回到学校后，过几天面试状态就是录用排序中。算是面试过了，然后一两周过后有同班的同学收到实习 offer，而我没消息。直到听说实习 offer 都发完了我才知道我挂了。所以说华为的面试通过和 offer 还有一段资源池的距离。后来一个学长 hr 来到学校找同学谈话，这时我被告知技术面给了个 B+。。。这个对我后面影响挺大的，然后综合面是 OK 的。所以面试时算过，本来也可以给 offer 但是没有岗位，只招一个 Android 实习的 🙂。但是这时候我还可以用这个安慰自己，不是你差，是市场需求，这是没办法的事。后续的是就是学长跟我谈了谈人生规划啊，然后推荐我参加优招。后面就是优招的故事了；</p>
<h4 id="第三家公司（阿里）实习-跪"><a href="#第三家公司（阿里）实习-跪" class="headerlink" title="第三家公司（阿里）实习-跪"></a>第三家公司（阿里）实习-跪</h4><p><code>一面：05-20</code><br>阿里是在线面试，给我的感觉是面过最难的，问得我无从回答，因为我基本没有项目经验，什么说说你在开发中碰到印象最深刻的问题是什么？遇到网上怎么也查不到答案的问题怎么办？还有你对 RN（当时只知道有个 RN 开发，并不清楚是什么） 开发怎么看？反正我答不上来，所以直接毙了。后面他问我有什么问题问他，我问他他对我面试感觉怎么样？他说我基础不行，然后我又问了要怎么学习？他说 Java 要学好，反射注解什么的。总之就是基础要扎实。。。</p>
<h4 id="第二家公司（华为）2-优招-过"><a href="#第二家公司（华为）2-优招-过" class="headerlink" title="第二家公司（华为）2. 优招-过"></a>第二家公司（华为）2. 优招-过</h4><p><code>补技术面：07-14</code><br>由于前面的实习面试给了个 B+，所以这次要补一个技术面。面试官也不是做 Android 的，不过是和 Java 相关的，所以基本就是问我 Java 了。也是开始聊聊项目和生活，然后问问 Java 内存泄漏，GC，接着考考算法，一道迷宫的题目，说下用深度优先和广度优先遍历的实现思想，进而问如果要找出一条最少步骤的路走出迷宫怎么办？基本都答上来了，最后他说我问你一个 Java 问题，我以为会很难。结果他说被 final 关键字修饰的类会怎么样？我迟疑了一下，说了答案。。。然后面试就结束了。给我的感觉应该是能过的。</p>
<p><code>BOSS 面：07-14</code><br>等了好久，最后排队排不上上午的了，然后发了餐券去吃了个饭回来面试。面试过程和实习面试时差不多，但是那个面试官的级别感觉挺高的，白头发特别多，估计 50+ 吧，最后加了个群，面试结束了。感觉没什么感觉，当时面试的研究生特别多，所以我感觉可能要 GG。</p>
<p>等了两个多月后，等到 09-21 发来的签约短信，09-22 以白菜价签了三方。是自己满意的城市加上整个暑假都在学校，09 月份投了十多家公司和做了 7-8份笔试题，心太累实在是不想等了。。。签的过程中有个更改城市的小插曲，hr 很好，忙到晚上 7 点多才结束，在这表示感谢。还有一个小插曲是当天有一个腾讯的面试，这是我的收到的第一个秋招面试，由于签了华为的三方，所以也没有去面了，准确说，其实我没有秋招，除了投了十几分简历和做了几次笔试。</p>
<h2 id="2-面试准备"><a href="#2-面试准备" class="headerlink" title="2. 面试准备"></a>2. 面试准备</h2><blockquote>
<p>这里主要叙述我的暑假和九月上旬这个面试准备过程和自己对面是准备的看法。</p>
</blockquote>
<p>说实话，没有实习 offer 对我算是有点打击的。所以我就打算暑假不回家好好复习基础知识，我觉得对于一个本科生来说，基础扎实才是你的优势，对于这里可能每个人看法不一，对于每个方向可能有差距吧，这里我只是平静地表达我的观点。</p>
<p>所以我基本放下 Android 了，只是挑热点面试问题过过。说下我做过的努力：</p>
<p>1.<a href="https://juejin.im/post/598454dcf265da3e26095dca" target="_blank" rel="external">重拾数据结构</a><br>2.<a href="https://juejin.im/post/59a7b8c9f265da24777a07da" target="_blank" rel="external">重拾操作系统</a><br>3.<a href="https://juejin.im/post/59ad4cd56fb9a02477075780" target="_blank" rel="external">重读 JVM</a><br>4.<a href="http://fitzeng.org/2017/07/08/AndroidBlogCollection/">Android Blog Collection</a><br>5.<a href="http://fitzeng.org/2017/09/11/handler/">Handler 机制再了解</a></p>
<p>以上是以 Blog 形式进行了总结的，还有部分书籍没有总结的。</p>
<p><img src="/2017/09/22/restart/books.png" alt=""></p>
<p>里面的看了有 30% 吧，都是采取不重要的粗读重要的精读模式。电子版下载 <a href="http://pan.baidu.com/s/1o7LcZCe" target="_blank" rel="external">链接 : http://pan.baidu.com/s/1o7LcZCe</a> 密码 : 0p0c 。希望大家有条件去支持纸质书吧，我对知识创造者还是很尊重的，因为自己发现写 Blog 每个礼拜一篇都写不来，但是对于部分学习计算机的人来说，书确实有点多，也要花很多钱，所以取舍之下就是有条件的现在支持原作者，没条件的以后有条件了再支持。好像偏题了。。。</p>
<p>期间看过 Android 开发艺术探索，Android 群英传，Android 进阶之光。之前还看过 编程之美，编程珠玑，编程之法，都没有自己敲代码实现，所以处于有思路但不能写代码实现的状态。然后就是一些专业课课本了。对于读书这件事我觉得没有必要为一个知识点死磕，我一般就是往后翻，基本两天跳着‘看’完一本书。时间固定的情况下宁愿跳着多看几遍，也不追求一遍仔细看完。因为你面临的结果就是记不住，没有重点的重复刺激下知识网络建立不起来。往往阅读到后面，前面的疑问就会迎刃而解。</p>
<p>然后说说岗位吧，以后我可能就不会再写和 Android 相关的文章了，签的工作是云计算所以打算学学 Python 和 OpenStack 之类的，从新开始接触一个新的领域。所以如果你不是对一个岗位持有非做不可的态度，其实我觉得那就不要太在意那些花哨的东西，注重基础的积累。比如之前面试有问我学过什么框架吗？我说没学过，然后这个话题就跳过了。当然学过加分，没学过我觉得不减分吧，毕竟应届生。但是一个 Java 基础的语言特性答不上来那就有点说不过去了。而且框架的精髓在读源码之后转化为自己的理解从而应用在自己代码中，而不是会使用框架，这种价值不大。如果你是大神，基础扎实，那这些就是你的进阶，你的加分项，本质不一样。就像试卷的必答题答完了肯定是去答选做题，但是有些人连必答题都没做完就跟着别人翻卷子是不是有点。。。总之就是注重语言本身，而不是语言衍生品。</p>
<p>接着说说面经，这是很好的东西，但是也是很不好的东西，看你的认知。有人对面经的态度是题库，觉得看完记着我面试就能过了，同一个问题，不同的人说相同的答案面试官也能知道哪个厉害哪个水。大家可以试试对一个自己不理解的技术问题尝试解释会怎样？你一迟疑，面试官就会反问你，最后只有一个字崩！而且那些面经提供的答案往往是符合作者的思考思路，不一定对你适用。所以我对面经的态度是类似于考纲，至于考纲和题库的区别留给读者思考吧。</p>
<p>然后我面试准备过程中参考的好的‘考纲’</p>
<ol>
<li><a href="http://www.jianshu.com/p/f661953ba032" target="_blank" rel="external">[干货，阅后进BAT不是梦] 面试心得与总结—BAT、网易、蘑菇街</a></li>
<li>自己动手丰衣足食，前面一篇是我认为的好面经，可以作为查找参考。</li>
</ol>
<h2 id="3-最后"><a href="#3-最后" class="headerlink" title="3. 最后"></a>3. 最后</h2><p>如果你觉得对你有帮助就点下赞吧，让更多的人看到，希望能帮到更多的人。这是我第一篇求赞的文章，因为确实想和大家分享我的想法。谢谢。</p>
<p>再如果你有相同或者不同的意见，欢迎评论区留言大家互相讨论呀~</p>
<p>然后国际惯例：<a href="http://fitzeng.org/">GitHub </a> &amp;&amp; <a href="https://github.com/mk43" target="_blank" rel="external"> Blog</a> 欢迎来观光 ^_^</p>
<p>多谢阅读！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我的求职生活是从今年的 04-16 找实习开始到 09-22 拿到优招(秋招) Offer结束，中间共经历过了三家公司面试，面试经验不足，而且最近的面试已距现在两个多月了，细节记不清了，所以这不太算是面经，只是我个人对我自己找工作这小半年的总结以及我对找工作这件事的认识。首先说明我不是大神，只能从平静叙述整个找工作的过程，希望你能从中体会到一点什么就很满意了，在此先祝大家找工作顺利！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Life" scheme="http://fitzeng.org/tags/Life/"/>
    
      <category term="Job" scheme="http://fitzeng.org/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>重识 Android</title>
    <link href="http://fitzeng.org/2017/09/19/reAndroid/"/>
    <id>http://fitzeng.org/2017/09/19/reAndroid/</id>
    <published>2017-09-19T03:27:00.000Z</published>
    <updated>2017-09-19T11:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Android 基础知识整理。</p>
</blockquote>
<a id="more"></a>
<h3 id="1-Activity"><a href="#1-Activity" class="headerlink" title="1. Activity"></a>1. Activity</h3><h4 id="1-1-Activity-生命周期"><a href="#1-1-Activity-生命周期" class="headerlink" title="1.1 Activity 生命周期"></a>1.1 Activity 生命周期</h4><p>状态：<code>running</code> <code>paused</code> <code>stopped</code> <code>killed</code></p>
<p>启动：onCreate() -&gt; onStart() -&gt; onResume()</p>
<p>点击 Home ：-&gt; onPause() -&gt; onStop()</p>
<p>重现：-&gt; onRestart() -&gt; onStart() -&gt; onResume()</p>
<p>退出：-&gt; onPause() -&gt; onStop() -&gt; onDestory()</p>
<p>进程优先级：<code>前台</code>(可交互) <code>可见</code>(失去焦点) <code>服务</code> <code>后台</code>(不可见) <code>空</code>(缓存用)</p>
<h4 id="1-2-Activity-任务栈"><a href="#1-2-Activity-任务栈" class="headerlink" title="1.2 Activity 任务栈"></a>1.2 Activity 任务栈</h4><p>standard：标准模式(每次都创建)</p>
<p>singleTop：栈顶复用模式(栈顶检测)</p>
<p>singleTask：栈内复用模式(栈内检测)</p>
<p>singleInstance：单实例模式(独立的任务栈)</p>
<h4 id="1-3-Activity-启动模式"><a href="#1-3-Activity-启动模式" class="headerlink" title="1.3 Activity 启动模式"></a>1.3 Activity 启动模式</h4><h4 id="1-4-Scheme-跳转协议"><a href="#1-4-Scheme-跳转协议" class="headerlink" title="1.4 Scheme 跳转协议"></a>1.4 Scheme 跳转协议</h4><h4 id="1-5-参考"><a href="#1-5-参考" class="headerlink" title="1.5 参考"></a>1.5 参考</h4><h3 id="2-Fragment"><a href="#2-Fragment" class="headerlink" title="2. Fragment"></a>2. Fragment</h3><h4 id="2-1-生命周期"><a href="#2-1-生命周期" class="headerlink" title="2.1 生命周期"></a>2.1 生命周期</h4><p>Create: 准备视图</p>
<p><code>onAttach</code>: Fragment 与 Activity 关联</p>
<p><code>onCreate</code>: 创建 Fragment 对象</p>
<p><code>onCreateView</code>: 创建视图</p>
<p><code>onActivityCreated</code>: Activity 对象创建完成</p>
<p>Start: 加载视图</p>
<p><code>onStart</code>: Fragment 可见</p>
<p>Resume: 获取焦点</p>
<p><code>onResume</code>: Fragment 可交互 </p>
<p>Pause 失去焦点</p>
<p><code>onPause</code>: Fragment 失去焦点</p>
<p>Stop 视图不可见</p>
<p><code>onStop</code>: Fragment 不可见</p>
<p>Destory 销毁对象</p>
<p><code>onDestoryView</code>: Fragment 视图销毁</p>
<p><code>onDestory</code>: 对象销毁</p>
<p><code>onDetach</code>: 解绑 Fragment 并销毁对象</p>
<blockquote>
<p>以上为个人理解，不是完整的视图加载过程，只是属于一个理解分析的过程。</p>
</blockquote>
<h4 id="2-2-Fragment-添加到-Activity-中"><a href="#2-2-Fragment-添加到-Activity-中" class="headerlink" title="2.2 Fragment 添加到 Activity 中"></a>2.2 Fragment 添加到 Activity 中</h4><p>静态加载：XML</p>
<p>动态加载： FragmentManager</p>
<ul>
<li><p>FragmentPagerAdapter(detach)</p>
<blockquote>
<p>适用于页面较少的情况，不销毁 Fragment 只与 Activity 脱离。</p>
</blockquote>
</li>
<li><p>FragmentStatePagerAdapter(remove)</p>
<blockquote>
<p>适用于页面较多的情况，直接移除 Fragment。</p>
</blockquote>
</li>
</ul>
<h4 id="2-3-Fragment-通信"><a href="#2-3-Fragment-通信" class="headerlink" title="2.3 Fragment 通信"></a>2.3 Fragment 通信</h4><ol>
<li>Fragment 中调用 Activity : 调用 getActivity()</li>
<li>Activity 中调用 Fragment : Fragment 回调函数</li>
<li>Fragment 中调用 Fragment : findFragmentById()</li>
</ol>
<h4 id="2-4-典型方法"><a href="#2-4-典型方法" class="headerlink" title="2.4 典型方法"></a>2.4 典型方法</h4><p><code>replace</code>: 替换 Fragment 实例 </p>
<p><code>add</code>: 添加 Fragment 实例 </p>
<p><code>remove</code>: 移除 Fragment 实例</p>
<h4 id="2-5参考"><a href="#2-5参考" class="headerlink" title="2.5参考"></a>2.5参考</h4><ol>
<li><a href="http://blog.csdn.net/android_tutor/article/details/5772285" target="_blank" rel="external">Android_Tutor : 两分钟彻底让你明白Android Activity生命周期(图文)!</a></li>
</ol>
<h3 id="3-Service"><a href="#3-Service" class="headerlink" title="3. Service"></a>3. Service</h3><h4 id="3-1-Service-和-Thread"><a href="#3-1-Service-和-Thread" class="headerlink" title="3.1 Service 和 Thread"></a>3.1 Service 和 Thread</h4><p>Service: 依托于所在的线程并且在后台运行，不可做耗时操作，否则会 ANR。<br>Thread: 主要是出处理耗时操作。</p>
<h3 id="4-BroadCast-Receiver"><a href="#4-BroadCast-Receiver" class="headerlink" title="4. BroadCast Receiver"></a>4. BroadCast Receiver</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android 基础知识整理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://fitzeng.org/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Handler 机制再了解</title>
    <link href="http://fitzeng.org/2017/09/11/handler/"/>
    <id>http://fitzeng.org/2017/09/11/handler/</id>
    <published>2017-09-11T03:27:00.000Z</published>
    <updated>2017-09-12T01:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这里主要是先了解整个消息传递的过程，知道这样做的好处和必要性。而不是直接介绍里面的几个关键类，然后介绍这个机制，这样容易头晕。而且网络上已经有很多这样的文章了，那些作者所站的高度对于我这种初学者来说有点高，我理解起来是比较稀里糊涂的，所以这里从一个问题出发，一步一步跟踪代码，这里只是搞清楚 handler 是怎么跨线程收发消息的，具体实现细节还是参考网上的那些大神的 Blog 比较权威。<br>PS. 本来是想分章节书写，谁知道这一套军体拳打下来收不住了，所以下面基本是以一种很流畅的过程解释而不是很跳跃，细心看应该会对理解 Handler 机制有所收获。</p>
</blockquote>
<a id="more"></a>
<p>Q1: 假如有一个耗时的数据处理，而且数据处理的结果是对 UI 更新影响的，而 Android 中 UI 更新不是线程安全的，所以规定只能在主线程中更新。</p>
<p>下面我们有两种选择：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">主线程版本：</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</div><div class="line">    <span class="keyword">private</span> Button btnTest;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.layout_test);</div><div class="line"></div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        btnTest = (Button) findViewById(R.id.btn_test);</div><div class="line">        btnTest.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"></div><div class="line">                <span class="comment">// 假装数据处理</span></div><div class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// 假装更新 UI</span></div><div class="line">                Log.d(TAG, <span class="string">"Handle it！"</span> + i);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接在主线程中处理数据，接着直接根据处理结果更新 UI。我想弊端大家都看到了，小则 UI 卡顿，大则造成 <a href="http://fitzeng.org/2017/04/07/RecurrentANR/">ANR</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">子线程版本：</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</div><div class="line">    <span class="keyword">private</span> Button btnTest;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.layout_test);</div><div class="line"></div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        btnTest = (Button) findViewById(R.id.btn_test);</div><div class="line">        btnTest.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="comment">// 假装数据处理</span></div><div class="line">                        <span class="keyword">int</span> i;</div><div class="line">                        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                Thread.sleep(<span class="number">1000</span>);</div><div class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                                e.printStackTrace();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// 返回处理结果</span></div><div class="line">                        handler.sendEmptyMessage(i);</div><div class="line">                    &#125;</div><div class="line">                &#125;).start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Handler handler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="comment">// 假装更新 UI</span></div><div class="line">            Log.d(TAG, <span class="string">"Handle MSG = "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一种典型的处理方式，开一个子线程处理数据，通过 Android 中提供的 Handler 机制进行跨线程通讯，把处理结果返回给主线程，进而更新 UI。这里我们就是探讨 Handler 是如何把数据发送过去的。</p>
<p><img src="/2017/09/11/handler/subThread.png" alt=""></p>
<p>到这里，我们了解到的就是一个 Handler 的黑盒机制，子线程发送，主线程接收。接下来，我们不介绍什么 <code>ThreadLocal</code>、<code>Looper</code> 和 <code>MessageQueue</code>。而是直接从上面的代码引出它们的存在，从原理了解它们存在的必要性，然后在谈它们内部存在的细节。</p>
<p>一切罪恶源于 <code>handler.sendEmptyMessage();</code>，最终找到以下函数 <code>sendMessageAtTime(Message msg, long uptimeMillis)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Handler.class</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Enqueue a message into the message queue after all pending messages</div><div class="line"> * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</div><div class="line"> * &lt;b&gt;The time-base is &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</div><div class="line"> * Time spent in deep sleep will add an additional delay to execution.</div><div class="line"> * You will receive it in &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached</div><div class="line"> * to this handler.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> uptimeMillis The absolute time at which the message should be</div><div class="line"> *         delivered, using the</div><div class="line"> *         &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</div><div class="line"> *         </div><div class="line"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </div><div class="line"> *         message queue.  Returns false on failure, usually because the</div><div class="line"> *         looper processing the message queue is exiting.  Note that a</div><div class="line"> *         result of true does not mean the message will be processed -- if</div><div class="line"> *         the looper is quit before the delivery time of the message</div><div class="line"> *         occurs then the message will be dropped.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MessageQueue</code> 出来了，我们避免不了了。里面主要是 <code>Message next()</code> 和 <code>enqueueMessage(Message msg, long when)</code> 方法值得研究，但是现在还不是时候。</p>
<p>从 <code>MessageQueue queue = mQueue;</code> 中可以看出我们的 <code>handler</code> 对象里面包含一个 mQueue 对象。至于里面存的什么怎么初始化的现在也不用太关心。大概有个概念就是这是个消息队列，存的是消息就行，具体实现细节后面会慢慢水落石出。<br>后面的代码就是说如果 queue 为空则打印 log 返回 false；否则执行 <code>enqueueMessage(queue, msg, uptimeMillis);</code> 入队。那就好理解了，handler 发送信息其实是直接把信息封装进一个消息队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Handler.class</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里涉及 Message，先说下这个类的三个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*package*/</span> Handler target;</div><div class="line">    </div><div class="line"><span class="comment">/*package*/</span> Runnable callback;</div><div class="line">    </div><div class="line"><span class="comment">/*package*/</span> Message next;</div></pre></td></tr></table></figure>
<p>所以 <code>msg.target = this;</code> 把当前 handler 传给了 msg。</p>
<p>中间的 if 代码先忽略，先走主线：执行了 <code>MessageQueue</code> 的 <code>enqueueMessage(msg, uptimeMillis);</code>方法。接着看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">MessageQueue.class</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></div><div class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></div><div class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></div><div class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">        <span class="keyword">if</span> (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码有点长，不影响主线的小细节就不介绍了，那些也很容易看懂的，但是原理还是值得分析。<br><code>if (mQuitting)...</code>，直接看看源码初始化赋值的函数是在 <code>void quit(boolean safe)</code> 函数里面，这里猜测可能是退出消息轮训，消息轮训的退出方式也是值得深究，不过这里不影响主线就不看了。 <code>msg.markInUse(); msg.when = when;</code> 标记消息在用而且继续填充  msg，下面就是看注释了。我们前面介绍的 Message 成员变量 next 就起作用了，把 msg 链在一起了。所以这里的核心就是把 msg 以一种链表形式插进去。似乎这一波分析结束了，在这里划张图总结下：<br><img src="/2017/09/11/handler/sendMsg.png" alt=""><br>推荐自己根据所观察到的变量赋值进行绘制图画，这样印象更加深刻。</p>
<p>OK，消息是存进去了，而且也是在 handler 所在的线程中。那么到底怎么取出信息呢？也就是前面小例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Handler handler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="comment">// 假装更新 UI</span></div><div class="line">        Log.d(TAG, <span class="string">"Handle MSG = "</span> + msg.what);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>handleMessage()</code> 什么时候调用？这里基本断了线索。但是如果你之前哪怕看过类似的一篇文章应该都知道其实在 Android 启动时 main 函数就做了一些操作。这些操作是必要的，这也就是为什么我们不能直接在子线程中 <code>new Handler();</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</div><div class="line">	SamplingProfilerIntegration.start();</div><div class="line">	</div><div class="line">	<span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></div><div class="line">	<span class="comment">// disable it here, but selectively enable it later (via</span></div><div class="line">	<span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></div><div class="line">	CloseGuard.setEnabled(<span class="keyword">false</span>);</div><div class="line">	</div><div class="line">	Environment.initForCurrentUser();</div><div class="line">	</div><div class="line">	<span class="comment">// Set the reporter for event logging in libcore</span></div><div class="line">	EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</div><div class="line">	</div><div class="line">	<span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></div><div class="line">	<span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</div><div class="line">	TrustedCertificateStore.setDefaultUserDirectory(configDir);</div><div class="line">	</div><div class="line">	Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line">	</div><div class="line">	Looper.prepareMainLooper(); <span class="comment">// -------1</span></div><div class="line">	</div><div class="line">	ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">	thread.attach(<span class="keyword">false</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">	    sMainThreadHandler = thread.getHandler(); <span class="comment">// -------2</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">	    Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">	            LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// End of event ActivityThreadMain.</span></div><div class="line">	Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">	Looper.loop(); <span class="comment">// -------3</span></div><div class="line">	</div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出这里在获取 sMainThreadHandler 之前进行了 <code>Looper.prepareMainLooper();</code> 操作，之后进行了 <code>Looper.loop();</code> 操作。</p>
<p>下面开始分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">Loopr.class</div><div class="line"> <span class="comment">/** Initialize the current thread as a looper.</span></div><div class="line">  * This gives you a chance to create handlers that then reference</div><div class="line">  * this looper, before actually starting the loop. Be sure to call</div><div class="line">  * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</div><div class="line">  * &#123;<span class="doctag">@link</span> #quit()&#125;.</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Initialize the current thread as a looper, marking it as an</div><div class="line"> * application's main looper. The main looper for your application</div><div class="line"> * is created by the Android environment, so you should never need</div><div class="line"> * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">        &#125;</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Return the Looper object associated with the current thread.  Returns</div><div class="line"> * null if the calling thread is not associated with a Looper.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前两个方法是在自己创建 Looper 的时候用，第三个是主线程自己用的。由于这里消息传递以主线程为线索。<code>prepare(false);</code>说明了这是主线程，在 <code>sThreadLocal.set(new Looper(quitAllowed));</code> 中的 <code>quitAllowed</code> 为 false 则说明主线程的 MessageQueue 轮训不能 quit。这句代码里还有 ThreadLocal 的 set() 方法。先不深究实现，容易晕，这里需要知道的就是把一个 Looper 对象“放进”了 ThreadLocal，换句话说，通过 ThreadLocal 可以获取不同的 Looper。<br>最后的 <code>sThreadLocal.get();</code> 展示了 get 方法。说明到这时 Looper 已经存在啦。<br>现在看看 Looper 类的成员变量吧！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Looper.class</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></div><div class="line"></div><div class="line"><span class="keyword">final</span> MessageQueue mQueue;</div><div class="line"><span class="keyword">final</span> Thread mThread;</div></pre></td></tr></table></figure>
<p>在这里先介绍一下 ThreadLocal 的上帝视角吧。直接源码，可以猜测这是通过一个 <code>ThreadLocalMap</code> 的内部类对线程进行一种 map。传进来的泛型 T 正是我们的 looper。所以 ThreadLocal 可以根据当前线程查找该线程的 Looper，具体怎么查找推荐看源码，这里就不介绍了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Returns the value in the current thread's copy of this</div><div class="line"> * thread-local variable.  If the variable has no value for the</div><div class="line"> * current thread, it is first initialized to the value returned</div><div class="line"> * by an invocation of the &#123;@link #initialValue&#125; method.</div><div class="line"> *</div><div class="line"> * @return the current thread's value of this thread-local</div><div class="line"> */</div><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null)</div><div class="line">            return (T)e.value;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"> * Sets the current thread's copy of this thread-local variable</div><div class="line"> * to the specified value.  Most subclasses will have no need to</div><div class="line"> * override this method, relying solely on the &#123;@link #initialValue&#125;</div><div class="line"> * method to set the values of thread-locals.</div><div class="line"> *</div><div class="line"> * @param value the value to be stored in the current thread's copy of</div><div class="line"> *        this thread-local.</div><div class="line"> */</div><div class="line">public void set(T value) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分析到这里，handler 和 looper 都有了，但是消息还是没有取出来？<br>这是看第三句 <code>Looper.loop();</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">Looper.class</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Run the message queue in this thread. Be sure to call</div><div class="line"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</div><div class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</div><div class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                Trace.traceEnd(traceTag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一开始也是获取 Looper，但是那么多 Looper 怎么知道这是哪个 Looper 呢？这先放着待会马上解释。把 loop() 函数主要功能搞懂再说。<br>接下来就是获取 Looper 中的 MessageQueue了，等等，这里提出一个疑问，前面说了 Handler 中也存在 MessageQueue，那这之间存在什么关系吗？（最后你会发现其实是同一个）<br>先往下看，一个死循环，也就是轮训消息喽，中间有一句 <code>msg.target.dispatchMessage(msg);</code> 而前面介绍 msg.target 是 handler 型参数。所以和 handler 联系上了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Handler.class</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑很简单，总之就是调动了我们重写的 handleMessage() 方法。</p>
<p>Step 1：<code>Looper.prepare();</code></p>
<blockquote>
<p>在 Looper 中有一个静态变量 sThreadLocal，把创建的 looper “存在” 里面，创建 looper 的同时创建 MessageQueue，并且和当前线程挂钩。</p>
</blockquote>
<p>Step 2：<code>new Handler();</code> </p>
<blockquote>
<p>通过上帝 ThreadLocal，并根据当前线程，可获取 looper，进而获取 MessageQueue，Callback之类的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Handler.class</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Use the &#123;<span class="doctag">@link</span> Looper&#125; for the current thread with the specified callback interface</div><div class="line"> * and set whether the handler should be asynchronous.</div><div class="line"> *</div><div class="line"> * Handlers are synchronous by default unless this constructor is used to make</div><div class="line"> * one that is strictly asynchronous.</div><div class="line"> *</div><div class="line"> * Asynchronous messages represent interrupts or events that do not require global ordering</div><div class="line"> * with respect to synchronous messages.  Asynchronous messages are not subject to</div><div class="line"> * the synchronization barriers introduced by &#123;<span class="doctag">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> callback The callback interface in which to handle messages, or null.</div><div class="line"> * <span class="doctag">@param</span> async If true, the handler calls &#123;<span class="doctag">@link</span> Message#setAsynchronous(boolean)&#125; for</div><div class="line"> * each &#123;<span class="doctag">@link</span> Message&#125; that is sent to it or &#123;<span class="doctag">@link</span> Runnable&#125; that is posted to it.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@hide</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue; <span class="comment">// 前面的两个 MessageQueue 联系起来了，疑问已解答。</span></div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这个函数可以说明在 new Handler() 之前该线程必需有 looper，所以要在这之前调用 <code>Looper.prepare();</code>。</p>
<p>Step 3：<code>Looper.loop();</code></p>
<blockquote>
<p>进行消息循环。</p>
</blockquote>
<p>基本到这里整个过程应该是清楚了，这里我画下我的理解。<br><img src="/2017/09/11/handler/threadLocal.png" alt=""></p>
<p>那么我们现在来看一下 handler 是怎么准确发送信息和处理信息的。注意在 handler 发送信息之前，1、2、3 步已经完成。所以该获取的线程已经获取，直接往该线程所在的 MessageQueue 里面塞信息就行了，反正该信息会在该 handler 所在线程的 looper 中循环，最终会通过消息的 target 参数调用 dispatchMessage()，而在 dispatchMessage() 中会调用我们重写的 handleMessage() 函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里主要是先了解整个消息传递的过程，知道这样做的好处和必要性。而不是直接介绍里面的几个关键类，然后介绍这个机制，这样容易头晕。而且网络上已经有很多这样的文章了，那些作者所站的高度对于我这种初学者来说有点高，我理解起来是比较稀里糊涂的，所以这里从一个问题出发，一步一步跟踪代码，这里只是搞清楚 handler 是怎么跨线程收发消息的，具体实现细节还是参考网上的那些大神的 Blog 比较权威。&lt;br&gt;PS. 本来是想分章节书写，谁知道这一套军体拳打下来收不住了，所以下面基本是以一种很流畅的过程解释而不是很跳跃，细心看应该会对理解 Handler 机制有所收获。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://fitzeng.org/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>一个程序员使用 PPT 的小技巧</title>
    <link href="http://fitzeng.org/2017/09/06/pptAndDev/"/>
    <id>http://fitzeng.org/2017/09/06/pptAndDev/</id>
    <published>2017-09-06T03:27:00.000Z</published>
    <updated>2017-09-06T06:02:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我写了一篇<a href="https://juejin.im/post/59ad4cd56fb9a02477075780" target="_blank" rel="external">《重读 JVM》</a>，<br>在文章下有人评论里面的图是怎么做的，下面是我给的回复：<br><img src="/2017/09/06/pptAndDev/comment.png" alt=""><br>然后想到自己在阅读其他大神些的 Blog 时，下面也有一批人在问作图工具什么的。然后我就想把自己的小技巧分享出来，如有雷同，纯属巧合。</p>
<a id="more"></a>
<h2 id="WHY-IS-PPT"><a href="#WHY-IS-PPT" class="headerlink" title="WHY IS PPT"></a>WHY IS PPT</h2><p>作为一个有点轻微洁癖的程序员，装的软件相同功能的基本不会超过两个。所以不想为写 Blog 画图而再装一个软件，再说并不是每篇 Blog 都要画图，但是要画图的 Blog 一画就是十几张，整理起来很不方便。所以我想到了 PPT，分页存储。其实在这之前我用 PPT 的很大一原因是写简历，之前简历是用 Word 做的，苦不堪言，而且版本保存很恶心。。。文件乱的很，所以想到用 PPT，没想到特别好用。下面开始介绍一下我的实操。</p>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="简历篇"><a href="#简历篇" class="headerlink" title="简历篇"></a>简历篇</h3><ul>
<li>第一步：创建 A4 大小的幻灯片</li>
</ul>
<p><img src="/2017/09/06/pptAndDev/resumeA4.png" alt=""></p>
<ul>
<li>第二步：设计简历</li>
</ul>
<p><img src="/2017/09/06/pptAndDev/draw.png" alt=""><br>这里就是利用插入形状自己设计了，基本够日常使用，我也不是什么 PPT 高手，如果你会使用动画那效果估计更加惊人。</p>
<ul>
<li>第三步：版本控制</li>
</ul>
<p><img src="/2017/09/06/pptAndDev/version.png" alt=""></p>
<p>利用注释！</p>
<ul>
<li>第四步：导出 PDF</li>
</ul>
<p>直接另存为PDF 就可以了，很简单就不截图了。</p>
<h3 id="管理图片篇"><a href="#管理图片篇" class="headerlink" title="管理图片篇"></a>管理图片篇</h3><p>基本有了绘制简历的基础，那么这个不在话下，剩下的就是自己的绘制水平高低了。</p>
<p>解释一下如何导出图片：直接 全选 -&gt; 右键 -&gt; 另存为图片…<br><img src="/2017/09/06/pptAndDev/imageStore.png" alt=""></p>
<p>注意这里的 PNG 如果没有背景图示透明的，所以绘制图片前可以自己加一层背景画布。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章有点水，不过如果对大家能有帮助就知足了。</p>
<p>如果你看到这 &amp;&amp; 如果你是一个程序员，那么按照国际惯例，推荐一下自己的<a href="https://github.com/mk43" target="_blank" rel="external"> GitHub </a> &amp;&amp; <a href="http://fitzeng.org/"> Blog </a> 里面还是有一些干货值得大家发现的。</p>
<p>多谢阅读 ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我写了一篇&lt;a href=&quot;https://juejin.im/post/59ad4cd56fb9a02477075780&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《重读 JVM》&lt;/a&gt;，&lt;br&gt;在文章下有人评论里面的图是怎么做的，下面是我给的回复：&lt;br&gt;&lt;img src=&quot;/2017/09/06/pptAndDev/comment.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;然后想到自己在阅读其他大神些的 Blog 时，下面也有一批人在问作图工具什么的。然后我就想把自己的小技巧分享出来，如有雷同，纯属巧合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tips" scheme="http://fitzeng.org/tags/Tips/"/>
    
      <category term="ppt" scheme="http://fitzeng.org/tags/ppt/"/>
    
  </entry>
  
  <entry>
    <title>重读 JVM</title>
    <link href="http://fitzeng.org/2017/09/02/reJVM/"/>
    <id>http://fitzeng.org/2017/09/02/reJVM/</id>
    <published>2017-09-01T16:00:00.000Z</published>
    <updated>2017-09-04T12:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>秋招开始了，前面由于做别的事耽误了半个月，以前学的东西不用就很容易忘记。所以，这次重新阅读《深入理解 JVM 虚拟机》时，想做一个记录。将碎片的知识整合，方便自己以后阅读，同时也和大家一起分享。内容中会添加我自己的理解，其中如果有错误，欢迎大家指正。</p>
<p>相关阅读:<br><a href="http://fitzeng.org/2017/08/02/reDS/">1. 重拾数据结构</a><br><a href="http://fitzeng.org/2017/08/07/reOS/">2. 重拾操作系统</a><br><a href="http://fitzeng.org/2017/08/31/reCN/">3. 重拾计算机网络(未完成)）</a><br>注意：以上内容会持续更新，欢迎大家关注<a href="https://github.com/mk43" target="_blank" rel="external"> GitHub </a> &amp;&amp; <a href="http://fitzeng.org/"> Blog </a> </p>
</blockquote>
<a id="more"></a>
<h2 id="1-Java-内存区域与内存溢出异常"><a href="#1-Java-内存区域与内存溢出异常" class="headerlink" title="1. Java 内存区域与内存溢出异常"></a>1. Java 内存区域与内存溢出异常</h2><h3 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h3><blockquote>
<p>根据《Java 虚拟机规范(Java SE 7 版)》规定，Java 虚拟机所管理的内存如下图所示。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/jvmRuntimeDataArea.png" alt=""></p>
<h4 id="1-1-1-程序计数器"><a href="#1-1-1-程序计数器" class="headerlink" title="1.1.1 程序计数器"></a>1.1.1 程序计数器</h4><blockquote>
<p>内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</p>
</blockquote>
<p>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
<h4 id="1-1-2-Java-虚拟机栈"><a href="#1-1-2-Java-虚拟机栈" class="headerlink" title="1.1.2 Java 虚拟机栈"></a>1.1.2 Java 虚拟机栈</h4><blockquote>
<p>线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p>
</blockquote>
<p>局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</p>
<p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。<br>OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</p>
<h4 id="1-1-3-本地方法栈"><a href="#1-1-3-本地方法栈" class="headerlink" title="1.1.3 本地方法栈"></a>1.1.3 本地方法栈</h4><blockquote>
<p>区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p>
</blockquote>
<h4 id="1-1-4-Java-堆"><a href="#1-1-4-Java-堆" class="headerlink" title="1.1.4 Java 堆"></a>1.1.4 Java 堆</h4><blockquote>
<p>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p>
</blockquote>
<p>OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</p>
<h4 id="1-1-5-方法区"><a href="#1-1-5-方法区" class="headerlink" title="1.1.5 方法区"></a>1.1.5 方法区</h4><blockquote>
<p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</blockquote>
<p>现在用一张图来介绍每个区域存储的内容。</p>
<p><img src="/2017/09/02/reJVM/jvmcontent.png" alt=""></p>
<h4 id="1-1-6-运行时常量池"><a href="#1-1-6-运行时常量池" class="headerlink" title="1.1.6 运行时常量池"></a>1.1.6 运行时常量池</h4><blockquote>
<p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p>
</blockquote>
<h4 id="1-1-7-直接内存"><a href="#1-1-7-直接内存" class="headerlink" title="1.1.7 直接内存"></a>1.1.7 直接内存</h4><blockquote>
<p>非虚拟机运行时数据区的部分</p>
</blockquote>
<p>在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。<br>OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</p>
<h3 id="1-2-HotSpot-虚拟机对象探秘"><a href="#1-2-HotSpot-虚拟机对象探秘" class="headerlink" title="1.2 HotSpot 虚拟机对象探秘"></a>1.2 HotSpot 虚拟机对象探秘</h3><blockquote>
<p>主要介绍数据是如何创建、如何布局以及如何访问的。</p>
</blockquote>
<h4 id="1-2-1-对象的创建"><a href="#1-2-1-对象的创建" class="headerlink" title="1.2.1 对象的创建"></a>1.2.1 对象的创建</h4><blockquote>
<p>创建过程比较复杂，建议看书了解，这里提供个人的总结。</p>
</blockquote>
<p>遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。<br><br>类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。<br><br>前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。<br><br>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。<br><br>执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。<br></p>
<h4 id="1-2-2-对象的内存布局"><a href="#1-2-2-对象的内存布局" class="headerlink" title="1.2.2 对象的内存布局"></a>1.2.2 对象的内存布局</h4><blockquote>
<p>在 HotSpot 虚拟机中，分为 3 块区域：<code>对象头(Header)</code>、<code>实例数据(Instance Data)</code>和<code>对齐填充(Padding)</code></p>
</blockquote>
<p><code>对象头(Header)</code>：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。<br><br><code>实例数据(Instance Data)</code>：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。<br><br><code>对齐填充(Padding)</code>：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。<br></p>
<h4 id="1-2-3-对象的访问定位"><a href="#1-2-3-对象的访问定位" class="headerlink" title="1.2.3 对象的访问定位"></a>1.2.3 对象的访问定位</h4><blockquote>
<p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p>
</blockquote>
<h5 id="通过句柄访问"><a href="#通过句柄访问" class="headerlink" title="通过句柄访问"></a>通过句柄访问</h5><blockquote>
<p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/jubing.png" alt=""></p>
<h5 id="使用直接指针访问"><a href="#使用直接指针访问" class="headerlink" title="使用直接指针访问"></a>使用直接指针访问</h5><blockquote>
<p>reference 中直接存储对象地址</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/directpointer.png" alt=""></p>
<p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p>
<h3 id="1-3-实战"><a href="#1-3-实战" class="headerlink" title="1.3 实战"></a>1.3 实战</h3><blockquote>
<p>// 待填</p>
</blockquote>
<h2 id="2-垃圾回收器与内存分配策略"><a href="#2-垃圾回收器与内存分配策略" class="headerlink" title="2. 垃圾回收器与内存分配策略"></a>2. 垃圾回收器与内存分配策略</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><blockquote>
<p>程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。</p>
</blockquote>
<h3 id="2-2-对象已死吗？"><a href="#2-2-对象已死吗？" class="headerlink" title="2.2 对象已死吗？"></a>2.2 对象已死吗？</h3><blockquote>
<p>在进行内存回收之前要做的事情就是判断那些对象是‘死’的，哪些是‘活’的。</p>
</blockquote>
<h4 id="2-2-1-引用计数法"><a href="#2-2-1-引用计数法" class="headerlink" title="2.2.1 引用计数法"></a>2.2.1 引用计数法</h4><blockquote>
<p>给对象添加一个引用计数器。但是难以解决循环引用问题。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/referenceCount.png" alt=""><br><br>从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p>
<h4 id="2-2-2-可达性分析法"><a href="#2-2-2-可达性分析法" class="headerlink" title="2.2.2 可达性分析法"></a>2.2.2 可达性分析法</h4><blockquote>
<p>通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/gcTree.png" alt=""></p>
<p>可作为 GC Roots 的对象：<br></p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li>
</ul>
<h4 id="2-2-3-再谈引用"><a href="#2-2-3-再谈引用" class="headerlink" title="2.2.3 再谈引用"></a>2.2.3 再谈引用</h4><blockquote>
<p>前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充，下面具体介绍。</p>
</blockquote>
<p>下面四种引用强度一次逐渐减弱<br></p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><blockquote>
<p>类似于 <code>Object obj = new Object();</code> 创建的，只要强引用在就不回收。 </p>
</blockquote>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><blockquote>
<p>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</p>
</blockquote>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><blockquote>
<p>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p>
</blockquote>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><blockquote>
<p>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
</blockquote>
<h4 id="2-2-4-生存还是死亡"><a href="#2-2-4-生存还是死亡" class="headerlink" title="2.2.4 生存还是死亡"></a>2.2.4 生存还是死亡</h4><blockquote>
<p>即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。<br><br>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。<br><br>finalize() 方法只会被系统自动调用一次。</p>
</blockquote>
<h4 id="2-2-5-回收方法区"><a href="#2-2-5-回收方法区" class="headerlink" title="2.2.5 回收方法区"></a>2.2.5 回收方法区</h4><blockquote>
<p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。<br><br>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p>
</blockquote>
<p>判断废弃常量：一般是判断没有该常量的引用。<br><br>判断无用的类：要以下三个条件都满足 <br></p>
<ul>
<li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li>
<li>加载该类的 ClassLoader 已经被回收</li>
<li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h3 id="2-3-垃圾回收算法"><a href="#2-3-垃圾回收算法" class="headerlink" title="2.3 垃圾回收算法"></a>2.3 垃圾回收算法</h3><blockquote>
<p>仅提供思路</p>
</blockquote>
<h4 id="2-3-1-标记-——-清除算法"><a href="#2-3-1-标记-——-清除算法" class="headerlink" title="2.3.1 标记 —— 清除算法"></a>2.3.1 标记 —— 清除算法</h4><blockquote>
<p>直接标记清除就可。</p>
</blockquote>
<p>两个不足：</p>
<ul>
<li>效率不高</li>
<li>空间会产生大量碎片</li>
</ul>
<h4 id="2-3-2-复制算法"><a href="#2-3-2-复制算法" class="headerlink" title="2.3.2 复制算法"></a>2.3.2 复制算法</h4><blockquote>
<p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p>
</blockquote>
<p>解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p>
<h4 id="2-3-3-标记-整理算法"><a href="#2-3-3-标记-整理算法" class="headerlink" title="2.3.3 标记-整理算法"></a>2.3.3 标记-整理算法</h4><blockquote>
<p>不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。</p>
</blockquote>
<h4 id="2-3-4-分代回收"><a href="#2-3-4-分代回收" class="headerlink" title="2.3.4 分代回收"></a>2.3.4 分代回收</h4><blockquote>
<p>根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。</p>
</blockquote>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><blockquote>
<p>每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。</p>
</blockquote>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><blockquote>
<p>老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 <code>标记 —— 清除</code> 或者 <code>标记 —— 整理</code> 算法回收。</p>
</blockquote>
<h3 id="2-4-HotSpot-的算法实现"><a href="#2-4-HotSpot-的算法实现" class="headerlink" title="2.4 HotSpot 的算法实现"></a>2.4 HotSpot 的算法实现</h3><blockquote>
<p>// 待填</p>
</blockquote>
<h3 id="2-5-垃圾回收器"><a href="#2-5-垃圾回收器" class="headerlink" title="2.5 垃圾回收器"></a>2.5 垃圾回收器</h3><blockquote>
<p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/hotspotGCDevice.png" alt=""><br><br>说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。</p>
<h4 id="2-5-1-Serial-收集器"><a href="#2-5-1-Serial-收集器" class="headerlink" title="2.5.1 Serial 收集器"></a>2.5.1 Serial 收集器</h4><blockquote>
<p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/serial.png" alt=""></p>
<h4 id="2-5-2-ParNew-收集器"><a href="#2-5-2-ParNew-收集器" class="headerlink" title="2.5.2 ParNew 收集器"></a>2.5.2 ParNew 收集器</h4><blockquote>
<p>可以认为是 Serial 收集器的多线程版本。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/parnew.png" alt=""></p>
<h5 id="并行：Parallel"><a href="#并行：Parallel" class="headerlink" title="并行：Parallel"></a>并行：Parallel</h5><blockquote>
<p>指多条垃圾收集线程并行工作，此时用户线程处于等待状态</p>
</blockquote>
<h5 id="并发：Concurrent"><a href="#并发：Concurrent" class="headerlink" title="并发：Concurrent"></a>并发：Concurrent</h5><blockquote>
<p>指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。</p>
</blockquote>
<h4 id="2-5-3-Parallel-Scavenge-收集器"><a href="#2-5-3-Parallel-Scavenge-收集器" class="headerlink" title="2.5.3 Parallel Scavenge 收集器"></a>2.5.3 Parallel Scavenge 收集器</h4><blockquote>
<p>这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p>
</blockquote>
<p>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。<br><br>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p>
<h4 id="2-5-4-Serial-Old-收集器"><a href="#2-5-4-Serial-Old-收集器" class="headerlink" title="2.5.4 Serial Old 收集器"></a>2.5.4 Serial Old 收集器</h4><blockquote>
<p>收集器的老年代版本，单线程，使用 <code>标记 —— 整理</code>。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/serial.png" alt=""></p>
<h4 id="2-5-5-Parallel-Old-收集器"><a href="#2-5-5-Parallel-Old-收集器" class="headerlink" title="2.5.5 Parallel Old 收集器"></a>2.5.5 Parallel Old 收集器</h4><blockquote>
<p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 <code>标记 —— 整理</code></p>
</blockquote>
<p><img src="/2017/09/02/reJVM/parallelOld.png" alt=""></p>
<h4 id="2-5-6-CMS-收集器"><a href="#2-5-6-CMS-收集器" class="headerlink" title="2.5.6 CMS 收集器"></a>2.5.6 CMS 收集器</h4><blockquote>
<p>CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 <code>标记 —— 清除</code> 算法实现。</p>
</blockquote>
<p>运作步骤: <br></p>
<ol>
<li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li>
<li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li>
<li>重新标记(CMS remark)：修正并发标记期间的变动部分</li>
<li>并发清除(CMS concurrent sweep)</li>
</ol>
<p><img src="/2017/09/02/reJVM/concurrentMarkSweep.png" alt=""></p>
<p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、<code>标记 —— 清除</code> 算法带来的空间碎片</p>
<h4 id="2-5-7-G1-收集器"><a href="#2-5-7-G1-收集器" class="headerlink" title="2.5.7 G1 收集器"></a>2.5.7 G1 收集器</h4><blockquote>
<p>面向服务端的垃圾回收器。</p>
</blockquote>
<p>优点：并行与并发、分代收集、空间整合、可预测停顿。</p>
<p>运作步骤: <br></p>
<ol>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking)</li>
<li>筛选回收(Live Data Counting and Evacuation)</li>
</ol>
<p><img src="/2017/09/02/reJVM/G1.png" alt=""></p>
<h3 id="2-6-内存分配与回收策略"><a href="#2-6-内存分配与回收策略" class="headerlink" title="2.6 内存分配与回收策略"></a>2.6 内存分配与回收策略</h3><h4 id="2-6-1-对象优先在-Eden-分配"><a href="#2-6-1-对象优先在-Eden-分配" class="headerlink" title="2.6.1 对象优先在 Eden 分配"></a>2.6.1 对象优先在 Eden 分配</h4><blockquote>
<p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p>
</blockquote>
<p>一般来说 Java 堆的内存模型如下图所示：<br><br><img src="/2017/09/02/reJVM/heapModel.png" alt=""></p>
<h5 id="新生代-GC-Minor-GC"><a href="#新生代-GC-Minor-GC" class="headerlink" title="新生代 GC (Minor GC)"></a>新生代 GC (Minor GC)</h5><blockquote>
<p>发生在新生代的垃圾回收动作，频繁，速度快。</p>
</blockquote>
<h5 id="老年代-GC-Major-GC-Full-GC"><a href="#老年代-GC-Major-GC-Full-GC" class="headerlink" title="老年代 GC (Major GC / Full GC)"></a>老年代 GC (Major GC / Full GC)</h5><blockquote>
<p>发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</p>
</blockquote>
<h4 id="2-6-2-大对象直接进入老年代"><a href="#2-6-2-大对象直接进入老年代" class="headerlink" title="2.6.2 大对象直接进入老年代"></a>2.6.2 大对象直接进入老年代</h4><h4 id="2-6-3-长期存活的对象将进入老年代"><a href="#2-6-3-长期存活的对象将进入老年代" class="headerlink" title="2.6.3 长期存活的对象将进入老年代"></a>2.6.3 长期存活的对象将进入老年代</h4><h4 id="2-6-4-动态对象年龄判定"><a href="#2-6-4-动态对象年龄判定" class="headerlink" title="2.6.4 动态对象年龄判定"></a>2.6.4 动态对象年龄判定</h4><h4 id="2-6-5-空间分配担保"><a href="#2-6-5-空间分配担保" class="headerlink" title="2.6.5 空间分配担保"></a>2.6.5 空间分配担保</h4><h2 id="3-Java-内存模型与线程"><a href="#3-Java-内存模型与线程" class="headerlink" title="3. Java 内存模型与线程"></a>3. Java 内存模型与线程</h2><p><img src="/2017/09/02/reJVM/cpuCacheMemory.png" alt=""></p>
<h3 id="3-1-Java-内存模型"><a href="#3-1-Java-内存模型" class="headerlink" title="3.1 Java 内存模型"></a>3.1 Java 内存模型</h3><blockquote>
<p>屏蔽掉各种硬件和操作系统的内存访问差异。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/threadMemory.png" alt=""></p>
<h4 id="3-1-1-主内存和工作内存之间的交互"><a href="#3-1-1-主内存和工作内存之间的交互" class="headerlink" title="3.1.1 主内存和工作内存之间的交互"></a>3.1.1 主内存和工作内存之间的交互</h4><table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">作用对象</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock</td>
<td style="text-align:center">主内存</td>
<td style="text-align:center">把一个变量标识为一条线程独占的状态</td>
</tr>
<tr>
<td style="text-align:center">unlock</td>
<td style="text-align:center">主内存</td>
<td style="text-align:center">把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td>
</tr>
<tr>
<td style="text-align:center">read</td>
<td style="text-align:center">主内存</td>
<td style="text-align:center">把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td>
</tr>
<tr>
<td style="text-align:center">load</td>
<td style="text-align:center">工作内存</td>
<td style="text-align:center">把 read 操作从主内存中得到的变量值放入工作内存中</td>
</tr>
<tr>
<td style="text-align:center">use</td>
<td style="text-align:center">工作内存</td>
<td style="text-align:center">把工作内存中一个变量的值传递给执行引擎，<br> 每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td>
</tr>
<tr>
<td style="text-align:center">assign</td>
<td style="text-align:center">工作内存</td>
<td style="text-align:center">把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，<br> 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td>
</tr>
<tr>
<td style="text-align:center">store</td>
<td style="text-align:center">工作内存</td>
<td style="text-align:center">把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td>
</tr>
<tr>
<td style="text-align:center">write</td>
<td style="text-align:center">工作内存</td>
<td style="text-align:center">把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td>
</tr>
</tbody>
</table>
<h4 id="3-1-2-对于-volatile-型变量的特殊规则"><a href="#3-1-2-对于-volatile-型变量的特殊规则" class="headerlink" title="3.1.2 对于 volatile 型变量的特殊规则"></a>3.1.2 对于 volatile 型变量的特殊规则</h4><blockquote>
<p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。</p>
</blockquote>
<p>一个变量被定义为 volatile 的特性：<br></p>
<ol>
<li>保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。<br></li>
</ol>
<blockquote>
<p>如果不符合 <code>运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值</code> 和 <code>变量不需要与其他的状态变量共同参与不变约束</code> 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。</p>
</blockquote>
<ol>
<li>禁止指令重排序优化。</li>
</ol>
<blockquote>
<p>通过插入内存屏障保证一致性。</p>
</blockquote>
<h4 id="3-1-3-对于-long-和-double-型变量的特殊规则"><a href="#3-1-3-对于-long-和-double-型变量的特殊规则" class="headerlink" title="3.1.3 对于 long 和 double 型变量的特殊规则"></a>3.1.3 对于 long 和 double 型变量的特殊规则</h4><blockquote>
<p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p>
</blockquote>
<h4 id="3-1-4-原子性、可见性与有序性"><a href="#3-1-4-原子性、可见性与有序性" class="headerlink" title="3.1.4 原子性、可见性与有序性"></a>3.1.4 原子性、可见性与有序性</h4><blockquote>
<p>回顾下并发下应该注意操作的那些特性是什么，同时加深理解。</p>
</blockquote>
<ul>
<li>原子性(Atomicity)</li>
</ul>
<blockquote>
<p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p>
</blockquote>
<ul>
<li>可见性(Visibility)</li>
</ul>
<blockquote>
<p>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p>
</blockquote>
<ul>
<li>有序性(Ordering)</li>
</ul>
<blockquote>
<p>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p>
</blockquote>
<h4 id="3-1-5-先行发生原则"><a href="#3-1-5-先行发生原则" class="headerlink" title="3.1.5 先行发生原则"></a>3.1.5 先行发生原则</h4><blockquote>
<p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p>
</blockquote>
<p>天然的先行发生关系</p>
<table>
<thead>
<tr>
<th style="text-align:center">规则</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">程序次序规则</td>
<td style="text-align:center">在一个线程内，代码按照书写的控制流顺序执行</td>
</tr>
<tr>
<td style="text-align:center">管程锁定规则</td>
<td style="text-align:center">一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td>
</tr>
<tr>
<td style="text-align:center">volatile 变量规则</td>
<td style="text-align:center">volatile 变量的写操作先行发生于后面对这个变量的读操作</td>
</tr>
<tr>
<td style="text-align:center">线程启动规则</td>
<td style="text-align:center">Thread 对象的 start() 方法先行发生于此线程的每一个动作</td>
</tr>
<tr>
<td style="text-align:center">线程终止规则</td>
<td style="text-align:center">线程中所有的操作都先行发生于对此线程的终止检测<br>(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)</td>
</tr>
<tr>
<td style="text-align:center">线程中断规则</td>
<td style="text-align:center">对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生 <br> (通过 Thread.interrupted() 方法检测)</td>
</tr>
<tr>
<td style="text-align:center">对象终结规则</td>
<td style="text-align:center">一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td>
</tr>
<tr>
<td style="text-align:center">传递性</td>
<td style="text-align:center">如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td>
</tr>
</tbody>
</table>
<h3 id="3-2-Java-与线程"><a href="#3-2-Java-与线程" class="headerlink" title="3.2 Java 与线程"></a>3.2 Java 与线程</h3><h4 id="3-2-1-线程的实现"><a href="#3-2-1-线程的实现" class="headerlink" title="3.2.1 线程的实现"></a>3.2.1 线程的实现</h4><h5 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h5><blockquote>
<p>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/klt.png" alt=""></p>
<h5 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h5><blockquote>
<p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/ut.png" alt=""></p>
<h5 id="使用用户线程夹加轻量级进程混合实现"><a href="#使用用户线程夹加轻量级进程混合实现" class="headerlink" title="使用用户线程夹加轻量级进程混合实现"></a>使用用户线程夹加轻量级进程混合实现</h5><blockquote>
<p>直接看图</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/kltAndut.png" alt=""></p>
<h5 id="Java-线程实现"><a href="#Java-线程实现" class="headerlink" title="Java 线程实现"></a>Java 线程实现</h5><blockquote>
<p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p>
</blockquote>
<h4 id="3-2-2-Java-线程调度"><a href="#3-2-2-Java-线程调度" class="headerlink" title="3.2.2 Java 线程调度"></a>3.2.2 Java 线程调度</h4><h5 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h5><blockquote>
<p>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</p>
</blockquote>
<h5 id="抢占式线程调度"><a href="#抢占式线程调度" class="headerlink" title="抢占式线程调度"></a>抢占式线程调度</h5><blockquote>
<p>每个线程由系统来分配执行时间。</p>
</blockquote>
<h4 id="3-2-3-状态转换"><a href="#3-2-3-状态转换" class="headerlink" title="3.2.3 状态转换"></a>3.2.3 状态转换</h4><p>五种状态：</p>
<ul>
<li>新建(new)</li>
</ul>
<blockquote>
<p>创建后尚未启动的线程。</p>
</blockquote>
<ul>
<li>运行(Runable)</li>
</ul>
<blockquote>
<p>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p>
</blockquote>
<ul>
<li>无限期等待(Waiting)</li>
</ul>
<blockquote>
<p>出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。</p>
</blockquote>
<p>以下方法会然线程进入无限期等待状态：<br>1.没有设置 Timeout 参数的 Object.wait() 方法。<br>2.没有设置 Timeout 参数的 Thread.join() 方法。<br>3.LookSupport.park() 方法。</p>
<ul>
<li>限期等待(Timed Waiting)</li>
</ul>
<blockquote>
<p>处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。</p>
</blockquote>
<p>以下方法会让线程进入限期等待状态：<br>1.Thread.sleep() 方法。<br>2.设置了 Timeout 参数的 Object.wait() 方法。<br>3.设置了 Timeout 参数的 Thread.join() 方法。<br>4.LockSupport.parkNanos() 方法。<br>5.LockSupport.parkUntil() 方法。</p>
<ul>
<li>阻塞(Blocked)</li>
</ul>
<blockquote>
<p>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>
</blockquote>
<ul>
<li>结束(Terminated)</li>
</ul>
<blockquote>
<p>已终止线程的线程状态。</p>
</blockquote>
<p><img src="/2017/09/02/reJVM/threadTranslate.png" alt=""></p>
<h2 id="4-线程安全与锁优化"><a href="#4-线程安全与锁优化" class="headerlink" title="4. 线程安全与锁优化"></a>4. 线程安全与锁优化</h2><blockquote>
<p>// 待填</p>
</blockquote>
<h2 id="5-类文件结构"><a href="#5-类文件结构" class="headerlink" title="5. 类文件结构"></a>5. 类文件结构</h2><blockquote>
<p>// 待填</p>
</blockquote>
<p>有点懒了。。。先贴几个网址吧。</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="external">1. Official：The class File Format</a><br><a href="http://blog.csdn.net/luanlouis/article/details/39892027" target="_blank" rel="external">2.亦山: 《Java虚拟机原理图解》 1.1、class文件基本组织结构</a></p>
<h2 id="6-虚拟机类加载机制"><a href="#6-虚拟机类加载机制" class="headerlink" title="6. 虚拟机类加载机制"></a>6. 虚拟机类加载机制</h2><blockquote>
<p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p>
</blockquote>
<p>在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p>
<h3 id="6-1-类加载时机"><a href="#6-1-类加载时机" class="headerlink" title="6.1 类加载时机"></a>6.1 类加载时机</h3><h4 id="类的生命周期-7-个阶段"><a href="#类的生命周期-7-个阶段" class="headerlink" title="类的生命周期( 7 个阶段)"></a>类的生命周期( 7 个阶段)</h4><p><img src="/2017/09/02/reJVM/classLifeCircle.png" alt=""></p>
<p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。</p>
<p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p>
<ol>
<li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。 </li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。</li>
</ol>
<p>前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化，佳作被动引用。举几个例子~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1127</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		System.out.println(<span class="string">"SubClass init!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		System.out.println(<span class="string">"ConstClass init!"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world!"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(SubClass.value);</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *  output : SuperClass init!</div><div class="line">		 * </div><div class="line">		 * 通过子类引用父类的静态对象不会导致子类的初始化</div><div class="line">		 * 只有直接定义这个字段的类才会被初始化</div><div class="line">		 */</div><div class="line">		 </div><div class="line">		SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *  output : </div><div class="line">		 * </div><div class="line">		 * 通过数组定义来引用类不会触发此类的初始化</div><div class="line">		 * 虚拟机在运行时动态创建了一个数组类</div><div class="line">		 */</div><div class="line">		 </div><div class="line">		System.out.println(ConstClass.HELLOWORLD);</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *  output : </div><div class="line">		 * </div><div class="line">		 * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，</div><div class="line">		 * 因此不会触发定义常量的类的初始化。</div><div class="line">		 * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。</div><div class="line">		 */</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-2-类的加载过程"><a href="#6-2-类的加载过程" class="headerlink" title="6.2 类的加载过程"></a>6.2 类的加载过程</h4><h5 id="6-2-1-加载"><a href="#6-2-1-加载" class="headerlink" title="6.2.1 加载"></a>6.2.1 加载</h5><ol>
<li>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。</li>
</ol>
<p>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p>
<ol>
<li>如果数组的组件类型是引用类型，那就递归采用类加载加载。</li>
<li>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。</li>
<li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li>
</ol>
<p>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p>
<h5 id="6-2-2-验证"><a href="#6-2-2-验证" class="headerlink" title="6.2.2 验证"></a>6.2.2 验证</h5><blockquote>
<p>是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。</p>
</blockquote>
<h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><ol>
<li>是否以魔数 0xCAFEBABE 开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据</li>
<li>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息</li>
<li>……</li>
</ol>
<p>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p>
<h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><ol>
<li>这个类是否有父类（除 java.lang.Object 之外）</li>
<li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）</li>
</ol>
<p>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p>
<h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><ol>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据）</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）</li>
<li>……</li>
</ol>
<p>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p>
<h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><ol>
<li>符号引用中通过字符创描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</li>
<li>……</li>
</ol>
<p>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。<br>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p>
<h5 id="6-2-3-准备"><a href="#6-2-3-准备" class="headerlink" title="6.2.3 准备"></a>6.2.3 准备</h5><blockquote>
<p>这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。</p>
</blockquote>
<p><code>public static int value = 1127;</code><br>这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。</p>
<p>基本数据类型的零值</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">零值</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">零值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">0</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">0L</td>
<td style="text-align:center">float</td>
<td style="text-align:center">0.0f</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">(short) 0</td>
<td style="text-align:center">double</td>
<td style="text-align:center">0.0d</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">‘\u0000’</td>
<td style="text-align:center">reference</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">(byte) 0</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。</p>
<h5 id="6-2-4-解析"><a href="#6-2-4-解析" class="headerlink" title="6.2.4 解析"></a>6.2.4 解析</h5><blockquote>
<p>这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
</blockquote>
<ol>
<li>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。</li>
<li>直接引用<br>直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关</li>
</ol>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 中常量类型。</p>
<h5 id="6-2-5-初始化"><a href="#6-2-5-初始化" class="headerlink" title="6.2.5 初始化"></a>6.2.5 初始化</h5><blockquote>
<p>前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。</p>
</blockquote>
<h4 id="6-3-类加载器"><a href="#6-3-类加载器" class="headerlink" title="6.3 类加载器"></a>6.3 类加载器</h4><blockquote>
<p>通过一个类的全限定名来获取描述此类的二进制字节流。</p>
</blockquote>
<h5 id="6-3-1-双亲委派模型"><a href="#6-3-1-双亲委派模型" class="headerlink" title="6.3.1 双亲委派模型"></a>6.3.1 双亲委派模型</h5><blockquote>
<p>从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）</p>
</blockquote>
<ol>
<li><p>启动类加载器<br>加载 lib 下或被 -Xbootclasspath 路径下的类</p>
</li>
<li><p>扩展类加载器<br>加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类</p>
</li>
<li><p>引用程序类加载器<br>ClassLoader负责，加载用户路径上所指定的类库。</p>
</li>
</ol>
<p><img src="/2017/09/02/reJVM/classLoader.png" alt=""><br>除顶层启动类加载器之外，其他都有自己的父类加载器。<br>工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。</p>
<h5 id="6-3-2-破坏双亲委派模型"><a href="#6-3-2-破坏双亲委派模型" class="headerlink" title="6.3.2 破坏双亲委派模型"></a>6.3.2 破坏双亲委派模型</h5><blockquote>
<p>keyword：线程上下文加载器(Thread Context ClassLoader)</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote>
<p>前面两次粗略的阅读，能理解内容，但是很难记住细节。每每碰到不会的知识点就上网查，所以知识点太碎片脑子里没有体系不仅更不容易记住，而且更加容易混乱。但是通过这种方式记录发现自己清晰了很多，就算以后忘记，知识再次捡起的成本也低了很多。</p>
<p>这次还有一些章节虽然阅读了，但是还未完成记录。等自己理解深刻有空闲了就再次记录下来，这里的内容均出自周志明老师的《深入理解 Java 虚拟机》，有兴趣的可以入手纸质版。</p>
<p>多谢阅读</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;秋招开始了，前面由于做别的事耽误了半个月，以前学的东西不用就很容易忘记。所以，这次重新阅读《深入理解 JVM 虚拟机》时，想做一个记录。将碎片的知识整合，方便自己以后阅读，同时也和大家一起分享。内容中会添加我自己的理解，其中如果有错误，欢迎大家指正。&lt;/p&gt;
&lt;p&gt;相关阅读:&lt;br&gt;&lt;a href=&quot;http://fitzeng.org/2017/08/02/reDS/&quot;&gt;1. 重拾数据结构&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://fitzeng.org/2017/08/07/reOS/&quot;&gt;2. 重拾操作系统&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://fitzeng.org/2017/08/31/reCN/&quot;&gt;3. 重拾计算机网络(未完成)）&lt;/a&gt;&lt;br&gt;注意：以上内容会持续更新，欢迎大家关注&lt;a href=&quot;https://github.com/mk43&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; GitHub &lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&quot;http://fitzeng.org/&quot;&gt; Blog &lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://fitzeng.org/tags/Java/"/>
    
      <category term="JVM" scheme="http://fitzeng.org/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>重拾计算机网络</title>
    <link href="http://fitzeng.org/2017/08/31/reCN/"/>
    <id>http://fitzeng.org/2017/08/31/reCN/</id>
    <published>2017-08-30T16:00:00.000Z</published>
    <updated>2017-09-02T02:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>主要是把在重读 《计算机网络》 和 《数据通讯与网络》中觉得有价值的东西记录下来。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-计算机网络基础概念"><a href="#1-计算机网络基础概念" class="headerlink" title="1. 计算机网络基础概念"></a>1. 计算机网络基础概念</h2><blockquote>
<p>一些互相连接的、自治的计算机的集合。</p>
</blockquote>
<h3 id="1-1-网络分类"><a href="#1-1-网络分类" class="headerlink" title="1.1 网络分类"></a>1.1 网络分类</h3><h4 id="不同作用范围的网络"><a href="#不同作用范围的网络" class="headerlink" title="不同作用范围的网络"></a>不同作用范围的网络</h4><ol>
<li>广域网 WAN (Wide Area Network)</li>
<li>城域网 MAN (Metropolitan Area Network)</li>
<li>局域网 LAN (Local Area Network)</li>
<li>个人区域网 PAN (Personal Area Network)</li>
</ol>
<h4 id="不同使用者的网络"><a href="#不同使用者的网络" class="headerlink" title="不同使用者的网络"></a>不同使用者的网络</h4><ol>
<li>公用网 (public network)</li>
<li>专用网 (private network)</li>
</ol>
<h4 id="用来把用户接入到因特网的网络"><a href="#用来把用户接入到因特网的网络" class="headerlink" title="用来把用户接入到因特网的网络"></a>用来把用户接入到因特网的网络</h4><ol>
<li>接入网 AN (Access Network)</li>
</ol>
<h3 id="1-2-计算机网络的性能指标"><a href="#1-2-计算机网络的性能指标" class="headerlink" title="1.2 计算机网络的性能指标"></a>1.2 计算机网络的性能指标</h3><h4 id="速率-bit-s"><a href="#速率-bit-s" class="headerlink" title="速率 (bit/s)"></a>速率 (bit/s)</h4><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><ol>
<li>信号具有的频带宽度 (xxxHZ)</li>
<li>在计算机网络中，从来表示通讯线路所能传送数据的能力。因此网络中的带宽表示在单位时间内ongoing 网络中的某一点到另一点所能通过的<code>最高数据率</code>。单位是比特每秒(b/s)</li>
</ol>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><blockquote>
<p>单位时间通过某个网络(或信道、接口)的数据量</p>
</blockquote>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><blockquote>
<p>数据从网络的一端发送到另一端所需的时间</p>
</blockquote>
<p><code>总延时 = 发送时延 + 传播时延 + 处理时延 + 排队时延</code></p>
<p>发送时延(传输时延)</p>
<blockquote>
<p>发送数据帧的时间</p>
</blockquote>
<p><code>发送时延 = 数据帧长度(b) / 信道带宽(b/s)</code></p>
<p>传播时延</p>
<blockquote>
<p>电磁波在信道中传播一定距离花费的时间</p>
</blockquote>
<p><code>传播时延 = 信道长度(m) / 电磁波在信道上的传播速率(m/s)</code></p>
<p>处理时延</p>
<blockquote>
<p>主机或路由器在收到分组时要花费一定时间处理。</p>
</blockquote>
<p>排队时延</p>
<blockquote>
<p>在路由器中输入队列中排队等待的时间</p>
</blockquote>
<h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><blockquote>
<p>以比特为单位的链路长度(可以理解为 <code>体积 = 截面 * 长度</code>)</p>
</blockquote>
<p><code>时延带宽积 = 传播时延 * 带宽</code></p>
<h4 id="往返时间-RTT-Round-Trip-Time"><a href="#往返时间-RTT-Round-Trip-Time" class="headerlink" title="往返时间 RTT (Round-Trip Time)"></a>往返时间 RTT (Round-Trip Time)</h4><blockquote>
<p>从发送方发送数据开始到发送方接收到来自接收方的确认总共经历的时间。</p>
</blockquote>
<h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>信道利用率</p>
<blockquote>
<p>某信道有百分之几的时间是被利用的</p>
</blockquote>
<p>网络利用率</p>
<blockquote>
<p>D0 : 网络空闲时的时延 D : 当前网络的时延 U : 利用率</p>
</blockquote>
<p><code>D = D0 / (1 - U)</code></p>
<h3 id="1-3-计算机网络的体系结构"><a href="#1-3-计算机网络的体系结构" class="headerlink" title="1.3 计算机网络的体系结构"></a>1.3 计算机网络的体系结构</h3><blockquote>
<p>每层的具体介绍后面章节给出</p>
</blockquote>
<p><img src="/2017/08/31/reCN/osi7.png" alt=""></p>
<h2 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要是把在重读 《计算机网络》 和 《数据通讯与网络》中觉得有价值的东西记录下来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://fitzeng.org/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>重拾操作系统</title>
    <link href="http://fitzeng.org/2017/08/07/reOS/"/>
    <id>http://fitzeng.org/2017/08/07/reOS/</id>
    <published>2017-08-06T16:00:00.000Z</published>
    <updated>2017-08-31T07:15:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>主要是把在重读 《现代操作系统》 中觉得有价值的东西，以 Tips 的形式记录下来。不可能面面俱到，但是如果有一定的基础应该是会回想起很多知识的。具体解释将会以链接形式补充。</p>
</blockquote>
<a id="more"></a>
<h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h3><h4 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h4><blockquote>
<p>主要是为了支持伪并发能力</p>
</blockquote>
<p><img src="/2017/08/07/reOS/threadstate.png" alt=""></p>
<ul>
<li>运行态 : 实际占用 CPU 资源</li>
<li>就绪态 : 可运行，但是由于没有时间片而被暂停等待 CPU 重新调度</li>
<li>阻塞态 : 外部某种事件导致（资源不足）不可运行</li>
</ul>
<p><code>CPU 利用率 = 1 - p ^ n</code> <br><br>p : IO 等待时间比 <br><br>n : 进程数</p>
<h4 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h4><blockquote>
<p>每一个进程有一个地址空间和一个控制线程，主要是使某个进程内的任务之间不被相互阻塞，实现一种进程内并行操作的假象。创建销毁更加轻量级。</p>
<p>共享一组资源，协同完成任务。每个线程有自己的堆栈区（因为要区分同一进程内的线程，CPU 调度要进行状态的保存）</p>
</blockquote>
<p><img src="/2017/08/07/reOS/thread.png" alt=""></p>
<h5 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h5><h6 id="用户空间中实现线程"><a href="#用户空间中实现线程" class="headerlink" title="用户空间中实现线程"></a>用户空间中实现线程</h6><h6 id="内核中实现线程"><a href="#内核中实现线程" class="headerlink" title="内核中实现线程"></a>内核中实现线程</h6><h6 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h6><h4 id="1-3-进程间通信（IPC）"><a href="#1-3-进程间通信（IPC）" class="headerlink" title="1.3 进程间通信（IPC）"></a>1.3 进程间通信（IPC）</h4><h5 id="1-竞争条件"><a href="#1-竞争条件" class="headerlink" title="1.竞争条件"></a>1.竞争条件</h5><blockquote>
<p>两个或者多个进程读写某些共享数据</p>
</blockquote>
<h5 id="2-临界区"><a href="#2-临界区" class="headerlink" title="2.临界区"></a>2.临界区</h5><blockquote>
<p>将共享内存的访问代码称为临界区，确保在每个时刻两个进程不可能同时处于临界区中，这样可以避免竞争条件。核心思想为互斥。</p>
</blockquote>
<p>并发程序准确高效要满足一下四个条件</p>
<ul>
<li>任何两个进程不能同时处于其临界区</li>
<li>不应对 CPU 的速度和数量做任何假设</li>
<li>临界区外运行的程序不得阻塞其他进程</li>
<li>不得使进程无限期等待进入临界区</li>
</ul>
<h5 id="3-忙等待的互斥"><a href="#3-忙等待的互斥" class="headerlink" title="3.忙等待的互斥"></a>3.忙等待的互斥</h5><blockquote>
<p>互斥实现方案</p>
</blockquote>
<h6 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h6><blockquote>
<p>每个进程进入临界区后立即屏蔽所有中断，这样 CPU 无法进行进程切换，就要离开临界区是打开中断。</p>
</blockquote>
<h6 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h6><blockquote>
<p>设置一个共享锁变量，初始值为 0。当一个进程想要进入临界区，必须检测锁的值是否为 0，是则置 1 进入临界区。不是则等待其他进程退出临界区时释放锁直到自己能获取到锁开始进入临界区。</p>
<p>锁变量还是会产生竞争条件</p>
</blockquote>
<h6 id="严格轮换法"><a href="#严格轮换法" class="headerlink" title="严格轮换法"></a>严格轮换法</h6><blockquote>
<p>一直循环等待直到出现允许该进程进入临界区的条件才开始运行，十分消耗 CPU 资源。</p>
<p>避免了竞争条件，但是临界区外运行的程序会发生阻塞</p>
<p>用于忙等待的锁称为自旋锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">A:</div><div class="line"><span class="keyword">while</span> (TRUE) &#123;</div><div class="line">	<span class="keyword">while</span> (turn != <span class="number">0</span>);</div><div class="line">	critical_region();</div><div class="line">	turn = <span class="number">1</span>;</div><div class="line">	noncritical_region();</div><div class="line">&#125;</div><div class="line"></div><div class="line">B:</div><div class="line"><span class="keyword">while</span> (TRUE) &#123;</div><div class="line">	<span class="keyword">while</span> (turn != <span class="number">1</span>); </div><div class="line">	critical_region();</div><div class="line">	turn = <span class="number">0</span>;</div><div class="line">	noncritical_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="Peterson-解法"><a href="#Peterson-解法" class="headerlink" title="Peterson 解法"></a>Peterson 解法</h6><blockquote>
<p>一种互斥算法</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> turn;</div><div class="line"><span class="keyword">int</span> interested[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> other;</div><div class="line">	other = <span class="number">1</span> - process;</div><div class="line">	interested[process] = TRUE;</div><div class="line">	turn = process;</div><div class="line">	<span class="comment">// 如果有另一个程序进入临界区的话则一直空循环</span></div><div class="line">	<span class="keyword">while</span> (turn == process &amp;&amp; interested[other] == TRUE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;</div><div class="line">	interested[process] = FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-睡眠与唤醒"><a href="#4-睡眠与唤醒" class="headerlink" title="4.睡眠与唤醒"></a>4.睡眠与唤醒</h5><blockquote>
<p>前面的弊端是忙等待会消耗 CPU 资源。如果在等待进入临界区时可以挂起，等到某个信号到达再唤醒就可以避免这种情况了。</p>
</blockquote>
<h6 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h6><blockquote>
<p>利用资源缓冲区实现进程间的协调</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100 </span></div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> item;</div><div class="line">	<span class="keyword">while</span> (TURE) &#123;</div><div class="line">		item = produce_item();</div><div class="line">		<span class="keyword">if</span> (count == N) &#123;</div><div class="line">			sleep();</div><div class="line">		&#125;</div><div class="line">		insert_item(item);</div><div class="line">		count = count + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</div><div class="line">			wakeup(consumer);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> item;</div><div class="line">	<span class="keyword">while</span> (TURE) &#123;</div><div class="line">		<span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">			sleep();</div><div class="line">		&#125;</div><div class="line">		item = remove_item();</div><div class="line">		count = count - <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (count == N - <span class="number">1</span>) &#123;</div><div class="line">			wakeup(producer);</div><div class="line">		&#125;</div><div class="line">		consume_item(item);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5.信号量"></a>5.信号量</h5><blockquote>
<p>引入一个信号量来累计唤醒次数，可以为 0 或正数 <br><br>使用 down 和 up 操作代替 sleep 和 wakeup</p>
</blockquote>
<pre><code class="c"><span class="meta">#<span class="meta-keyword">define</span> N 100</span>
<span class="keyword">typedef</span> <span class="keyword">int</span> semaphore
semaphore mutex = <span class="number">1</span>;  <span class="comment">// 控制对临界区的访问</span>
semaphore empty = N; <span class="comment">// 计数缓冲区的空槽数目</span>
semaphore full = <span class="number">0</span>; <span class="comment">// 计数缓冲区的满槽数目</span>

<span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span> </span>{
    <span class="keyword">int</span> item;
    <span class="keyword">while</span> (TRUE) {
        utem = produce_item();
        down(&amp;empty);
        down(&amp;mutex);
        insert_item(item);
        up(&amp;mutex);
        up(&amp;full);
    }
}

<span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span> </span>{
    <span class="keyword">int</span> item;
    <span class="keyword">while</span> (TRUE) {
        down(&amp;full);
        down(&amp;mutex);
        item = remove_item();
        up(&amp;mutex);
        up(&amp;empty);
        consume_item(item);
    }
}
</code></pre>
<ul>
<li>mutex : 用于互斥，保证任一时刻只有一个进程读写缓冲区</li>
<li>full &amp;&amp; empty : 实现同步，保证某种时间的顺序发生或者不发生</li>
</ul>
<h5 id="6-互斥量"><a href="#6-互斥量" class="headerlink" title="6.互斥量"></a>6.互斥量</h5><blockquote>
<p>仅仅适用于管理共享资源或一小段代码</p>
</blockquote>
<h5 id="7-管程"><a href="#7-管程" class="headerlink" title="7.管程"></a>7.管程</h5><h5 id="8-消息传递"><a href="#8-消息传递" class="headerlink" title="8.消息传递"></a>8.消息传递</h5><h5 id="9-屏障"><a href="#9-屏障" class="headerlink" title="9.屏障"></a>9.屏障</h5><h5 id="1-4-调度"><a href="#1-4-调度" class="headerlink" title="1.4 调度"></a>1.4 调度</h5><blockquote>
<p>当有多个进程处于就绪态时就面临调度的选择。<br><br>内核管理线程时调度可以认为是线程级别的。<br><br>进程行为有 <code>计算密集型</code> 和 <code>I/O 密集型</code>。而现在由于 CPU 改进速度加快，进程行为更倾向于后者，所以应该多运行该类进程保持 CPU 的利用率。<br></p>
</blockquote>
<h6 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h6><ol>
<li><p>批处理</p>
<ul>
<li>先来先服务</li>
<li>最短作业优先</li>
<li>最短剩余时间优先</li>
</ul>
</li>
<li><p>交互式</p>
<ul>
<li>轮转调度（每个进程一个时间片，用完就轮转）</li>
<li>优先级调度</li>
<li>多级队列</li>
<li>最短进程优先 （<code>aT0 + (1 - a)T1</code>）</li>
<li>保证优先</li>
<li>彩票调度</li>
<li>公平分享调度</li>
</ul>
</li>
<li><p>实时</p>
</li>
</ol>
<p>线程调度</p>
<blockquote>
<p>和系统支持的线程实现方式有关（理解 : 线程表存在哪的区别）<br></p>
</blockquote>
<p>用户级线程 : 内核并不知道，内核只是选中该进程，至于进程中跑哪个线程由用户态调度决定。<br><br>内核级线程 : 直接调度某个进程内的线程。<br><br>以上两种方式在性能上有主要差别 : 前面提及 I/O 操作其实是很耗时的，所以在进程间切换比在线程间切换更加耗时。因为线程轻量，而进程完成切换要完整的山下文切换，修改内存映像。而且同一进程内的线程 I/O 访问 cache 的局部性更高，不同进程间切换的清理缓存，这也会消耗时间。</p>
<h3 id="2-存储管理"><a href="#2-存储管理" class="headerlink" title="2. 存储管理"></a>2. 存储管理</h3><blockquote>
<p>主要思想就是内存抽象</p>
</blockquote>
<h4 id="2-1-空闲内存管理"><a href="#2-1-空闲内存管理" class="headerlink" title="2.1 空闲内存管理"></a>2.1 空闲内存管理</h4><h5 id="使用位图的存储管理"><a href="#使用位图的存储管理" class="headerlink" title="使用位图的存储管理"></a>使用位图的存储管理</h5><h5 id="使用链表的存储管理"><a href="#使用链表的存储管理" class="headerlink" title="使用链表的存储管理"></a>使用链表的存储管理</h5><h4 id="2-2-虚拟内存"><a href="#2-2-虚拟内存" class="headerlink" title="2.2 虚拟内存"></a>2.2 虚拟内存</h4><blockquote>
<p>程序产生的地址为虚拟地址，在没有虚拟内存的操作系统上，直接将地址输送到内存总线上。而有虚拟内存的操作系统上，把虚拟地址输送到 MMU（Memory Management Unit），由 MMU 将虚拟地址映射为为物理地址。</p>
</blockquote>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><p>虚拟地址空间 : 页面 物理内存地址 : 叶框 4k大小 <br><br>虚拟地址 = 虚拟页号(高位) + 偏移量(低位) <br><br>页表 : 把虚拟地址的页面映射为页框，每个进程都有自己的页表<br></p>
<p>加速分页方法 : 转换检测缓冲区（TLB）主要是优先在 TLB 中查找页面号。<br></p>
<p>大内存页表<br></p>
<ol>
<li>多级页表</li>
<li>倒排页表 : 每个页框一个表项 + TLB 快表</li>
</ol>
<h4 id="2-3-页面置换算法"><a href="#2-3-页面置换算法" class="headerlink" title="2.3 页面置换算法"></a>2.3 页面置换算法</h4><blockquote>
<p>最优页面置换算法不可实现，因为无法确定未来。</p>
</blockquote>
<h5 id="1-最近未使用页面置换算法-NRU"><a href="#1-最近未使用页面置换算法-NRU" class="headerlink" title="1.最近未使用页面置换算法(NRU)"></a>1.最近未使用页面置换算法(NRU)</h5><blockquote>
<p>设置访问（读、写）位 R，页面修改位 M。<br></p>
</blockquote>
<h5 id="2-先进先出页面置换算法-FIFO"><a href="#2-先进先出页面置换算法-FIFO" class="headerlink" title="2.先进先出页面置换算法(FIFO)"></a>2.先进先出页面置换算法(FIFO)</h5><h5 id="3-第二次机会页面置换算法"><a href="#3-第二次机会页面置换算法" class="headerlink" title="3.第二次机会页面置换算法"></a>3.第二次机会页面置换算法</h5><blockquote>
<p>设置一个检测最老页面位 R</p>
</blockquote>
<h5 id="4-时钟页面置换算法"><a href="#4-时钟页面置换算法" class="headerlink" title="4.时钟页面置换算法"></a>4.时钟页面置换算法</h5><blockquote>
<p>链表实现页面选择</p>
</blockquote>
<h5 id="5-最近最少使用页面置换算法-LRU"><a href="#5-最近最少使用页面置换算法-LRU" class="headerlink" title="5.最近最少使用页面置换算法(LRU)"></a>5.最近最少使用页面置换算法(LRU)</h5><blockquote>
<p>利用矩阵模拟 : 增加自身权重减少其他权重，行置 1，列置 0。</p>
</blockquote>
<h5 id="6-用软件模拟-LRU"><a href="#6-用软件模拟-LRU" class="headerlink" title="6.用软件模拟 LRU"></a>6.用软件模拟 LRU</h5><blockquote>
<p>老化算法</p>
</blockquote>
<h5 id="7-工作集页面置换算法"><a href="#7-工作集页面置换算法" class="headerlink" title="7.工作集页面置换算法"></a>7.工作集页面置换算法</h5><h5 id="8-工作集时钟页面置换算法"><a href="#8-工作集时钟页面置换算法" class="headerlink" title="8.工作集时钟页面置换算法"></a>8.工作集时钟页面置换算法</h5><table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">最优算法</td>
<td style="text-align:center">不可实现，但可作为基准</td>
</tr>
<tr>
<td style="text-align:center">NRU(最近未使用)算法</td>
<td style="text-align:center">LRU 的很粗糙近似</td>
</tr>
<tr>
<td style="text-align:center">FIFO(先进先出)算法</td>
<td style="text-align:center">可能抛弃重要页面</td>
</tr>
<tr>
<td style="text-align:center">第二次机会算法</td>
<td style="text-align:center">比 FIFO 有大的改善</td>
</tr>
<tr>
<td style="text-align:center">时钟算法</td>
<td style="text-align:center">现实的</td>
</tr>
<tr>
<td style="text-align:center">LRU(最近最少使用)算法</td>
<td style="text-align:center">很优秀，但很难实现</td>
</tr>
<tr>
<td style="text-align:center">NFU(最不经常使用)算法</td>
<td style="text-align:center">LRU 的相对粗略的近似</td>
</tr>
<tr>
<td style="text-align:center">老化算法</td>
<td style="text-align:center">非常近似 LRU 的有效算法</td>
</tr>
<tr>
<td style="text-align:center">工作集算法</td>
<td style="text-align:center">实现起来开销很大</td>
</tr>
<tr>
<td style="text-align:center">工作集时钟算法</td>
<td style="text-align:center">好的有效算法</td>
</tr>
</tbody>
</table>
<h4 id="2-4-内存映射文件"><a href="#2-4-内存映射文件" class="headerlink" title="2.4 内存映射文件"></a>2.4 内存映射文件</h4><blockquote>
<p>进程发起系统调用，把文件映射到其虚拟地址空间的一部分。一般实现是开始不加载，在程序访问时在按页加载。</p>
</blockquote>
<p>// Linux 待填</p>
<h4 id="2-5-实现"><a href="#2-5-实现" class="headerlink" title="2.5 实现"></a>2.5 实现</h4><h5 id="分页工作"><a href="#分页工作" class="headerlink" title="分页工作"></a>分页工作</h5><ul>
<li>进程创建时 : 操作系统要确定程序和数据在初始时有多大，并为它们创建一个页表，操作系统还要在内存中为页表分配空间并对其进行初始化。<br></li>
<li>进程运行时 : 页表必须在内存中(反之不需要)，并且在磁盘交换区中分配空间。<br></li>
<li>调度一个进程执行时 : 为新进程充值 MMU，刷新 TLB，更换页表。<br></li>
<li>缺页中断发生时 : 操作系统必须通过读硬件寄存器确定是哪个虚拟地址造成了缺页中断通过该信息计算需要哪个页面，定位磁盘位置并找到合适的页框来存放新页面，必要的话要置换老页面，然后把所需页面读入页框。最后，备份程序计数器，是程序计数器指向引起缺页中断的指令，并重新执行该指令。<br></li>
<li>进程退出时 : 释放页表，页面和页面在硬盘上占的空间。</li>
</ul>
<h5 id="缺页中断处理"><a href="#缺页中断处理" class="headerlink" title="缺页中断处理"></a>缺页中断处理</h5><ol>
<li>硬件陷入内核，在堆栈中保存程序计数器。大多数机器将当前的指令的各种状态信息保存在特殊的 CPU 寄存器中。</li>
<li>启动一个汇编代码例程保存通用寄存器和其他易失信息，以免被操作系统破坏。这个例程将操作系统做为一个函数来调用。</li>
<li>当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看他在缺页中断时正在做什么。</li>
<li>一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致，如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。</li>
<li>如果选择的页框“脏”了，安排该页面写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。</li>
<li>一旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行用户进程，则选择另一个用户进程运行。</li>
<li>当磁盘中断发生时，表明该页已被装入，页表已经更新可以反映他的位置，页框也被标记为正常状态。</li>
<li>恢复发生缺页中断指令以前的状态，程序计数器重新定向这条指令。</li>
<li>调度引发缺页中断的进程，操作系统返回调用他的汇编语言例程。</li>
<li>该例程恢复寄存器和其他状态信息，放回到用户空间继续执行，就好像缺页中断没有发生过一样。</li>
</ol>
<h4 id="2-6-分段"><a href="#2-6-分段" class="headerlink" title="2.6 分段"></a>2.6 分段</h4><blockquote>
<p>段是逻辑实体，大小不固定。</p>
</blockquote>
<h4 id="2-7-分段和分页结合-MULTICS"><a href="#2-7-分段和分页结合-MULTICS" class="headerlink" title="2.7 分段和分页结合 : MULTICS"></a>2.7 分段和分页结合 : MULTICS</h4><blockquote>
<p>还有 Intel Pentuium 未介绍</p>
</blockquote>
<p>34 位的 MULTICS 虚拟地址</p>
<table>
<thead>
<tr>
<th style="text-align:center">段号</th>
<th style="text-align:center">页号</th>
<th style="text-align:center">页内偏移</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">6</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<ol>
<li>根据段号找到段描述符</li>
<li>检查该段的页表是否存在内存中。如果在，则找到他；如果不再，则产生一个段错误。如果访问违反了段的保护要求就要求发出一个越界错误(陷阱)。</li>
<li>检查所请求虚拟页面的页表项，如果该页面不再内存中则产生一个缺页中断，如果在内存就从页表中取出这个页面在内存中的起始地址。</li>
<li>把偏移量加到页面的起始地址上，得到要访问的字在内存中的地址。</li>
<li>最后进行读或写操作。</li>
</ol>
<h3 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3. 文件系统"></a>3. 文件系统</h3><blockquote>
<p>文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。磁盘的 0 号盘扇区称为主引导记录(Master Boot Record, MBR)，用来引导计算机。在 MBR 的结尾是分区表，该表给出了每个分区的其实和结束地址。表中的一个分区被标记为活动分区。在计算机被引导时，BIOS 读入并执行 MBR。MBR 做的第一件事是确定活动分区，读入它的第一个块，称为引导块，并执行。</p>
</blockquote>
<p>整个分区: </p>
<table>
<thead>
<tr>
<th style="text-align:center">MBR</th>
<th style="text-align:center">分区表</th>
<th style="text-align:center">磁盘分区</th>
<th style="text-align:center">磁盘分区</th>
<th style="text-align:center">磁盘分区…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>磁盘分区: </p>
<table>
<thead>
<tr>
<th style="text-align:center">引导块</th>
<th style="text-align:center">超级块</th>
<th style="text-align:center">空闲空间管理</th>
<th style="text-align:center">i 节点</th>
<th style="text-align:center">根目录</th>
<th style="text-align:center">文件和目录</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="3-1-文件实现"><a href="#3-1-文件实现" class="headerlink" title="3.1 文件实现"></a>3.1 文件实现</h4><h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><blockquote>
<p>把每个文件作为一连串连续数据块存储在磁盘上。</p>
</blockquote>
<h5 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h5><blockquote>
<p>一个文件由几个磁盘块组成。</p>
</blockquote>
<h5 id="在内存中采用表的链表分配"><a href="#在内存中采用表的链表分配" class="headerlink" title="在内存中采用表的链表分配"></a>在内存中采用表的链表分配</h5><blockquote>
<p>把每个磁盘块的指针字放在内存的一个表中</p>
</blockquote>
<h5 id="i-节点"><a href="#i-节点" class="headerlink" title="i 节点"></a>i 节点</h5><blockquote>
<p>每个文件赋予一个称为 i 节点(index-node)的数据结构，列出文件属性和文件快的磁盘地址。</p>
</blockquote>
<h3 id="4-输入-输出"><a href="#4-输入-输出" class="headerlink" title="4. 输入/输出"></a>4. 输入/输出</h3><h5 id="4-1-I-O-硬件原理"><a href="#4-1-I-O-硬件原理" class="headerlink" title="4.1 I/O 硬件原理"></a>4.1 I/O 硬件原理</h5><h6 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h6><p>块设备 : 以块为单位传输，可寻址<br><br>字符设备 : 以字符为单位收发字符流，不可寻址<br></p>
<h6 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h6><h6 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I/O"></a>内存映射 I/O</h6><h6 id="直接存储器存取"><a href="#直接存储器存取" class="headerlink" title="直接存储器存取"></a>直接存储器存取</h6><p>DMA 工作原理:</p>
<ol>
<li>CPU 对 DMA 控制器进行编程</li>
<li>DMA 请求磁盘传送数据到内存</li>
<li>磁盘传送数据到内存</li>
<li>磁盘给 DMA 控制器应答</li>
<li>完成中断</li>
</ol>
<h3 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5. 死锁"></a>5. 死锁</h3><h4 id="5-1-资源"><a href="#5-1-资源" class="headerlink" title="5.1 资源"></a>5.1 资源</h4><blockquote>
<p>在进程对设备，文件等取得了排他性访问权限的时候，有可能会出现死锁。这类需要排他性使用的对象称为资源。</p>
</blockquote>
<h5 id="可抢占资源"><a href="#可抢占资源" class="headerlink" title="可抢占资源"></a>可抢占资源</h5><blockquote>
<p>可以从拥有它的进程中抢占而不会产生任何副作用。（存储器）</p>
</blockquote>
<h5 id="不可抢占资源"><a href="#不可抢占资源" class="headerlink" title="不可抢占资源"></a>不可抢占资源</h5><blockquote>
<p>指在不引起相关的计算失败的情况下，无法把他从占有它的进程处抢占过来。（ CD 刻录）</p>
</blockquote>
<p>资源使用步骤:</p>
<ol>
<li>请求资源</li>
<li>使用资源</li>
<li>释放资源</li>
</ol>
<h4 id="5-2-死锁概述"><a href="#5-2-死锁概述" class="headerlink" title="5.2 死锁概述"></a>5.2 死锁概述</h4><blockquote>
<p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。</p>
</blockquote>
<h5 id="资源死锁条件"><a href="#资源死锁条件" class="headerlink" title="资源死锁条件"></a>资源死锁条件</h5><p>发生资源死锁的四个必要条件:</p>
<ol>
<li>互斥条件 : 每个资源要么已经分配了一个进程，要么就是可用的。</li>
<li>占有和等待条件 : 已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占条件 : 已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显示地释放。</li>
<li>环路等待条件 : 死锁发生时，系统中一定有两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。</li>
</ol>
<h4 id="5-3-死锁检测与死锁恢复"><a href="#5-3-死锁检测与死锁恢复" class="headerlink" title="5.3 死锁检测与死锁恢复"></a>5.3 死锁检测与死锁恢复</h4><blockquote>
<p>死锁检测主要是判断当前空闲资源在某种合理分配下是否能使所有进程都运行完并且最终资源都能够释放。</p>
</blockquote>
<p>恢复方法 : </p>
<ol>
<li>利用抢占式恢复</li>
<li>利用回滚恢复</li>
<li>利用杀死进程恢复</li>
</ol>
<h4 id="5-4-死锁避免"><a href="#5-4-死锁避免" class="headerlink" title="5.4 死锁避免"></a>5.4 死锁避免</h4><h5 id="资源轨迹图"><a href="#资源轨迹图" class="headerlink" title="资源轨迹图"></a>资源轨迹图</h5><h5 id="安全状态和不安全状态"><a href="#安全状态和不安全状态" class="headerlink" title="安全状态和不安全状态"></a>安全状态和不安全状态</h5><h5 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h5><h5 id="多个资源的银行家算法"><a href="#多个资源的银行家算法" class="headerlink" title="多个资源的银行家算法"></a>多个资源的银行家算法</h5><h4 id="5-5-死锁预防"><a href="#5-5-死锁预防" class="headerlink" title="5.5 死锁预防"></a>5.5 死锁预防</h4><blockquote>
<p>死锁避免从本质上来说是不可能的，因为他要获取未来的信息。</p>
</blockquote>
<h5 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h5><blockquote>
<p>如果资源不被一个进程独占死锁不会发生。（假脱机打印机）</p>
</blockquote>
<h5 id="破坏占有和等待条件"><a href="#破坏占有和等待条件" class="headerlink" title="破坏占有和等待条件"></a>破坏占有和等待条件</h5><blockquote>
<p>开始执行前请求所有资源就不会造成等待。另一种是请求资源时先释放自己所持有的资源，再尝试一次请求资源。</p>
</blockquote>
<h5 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h5><blockquote>
<p>针对某些资源进行虚拟化，实现可抢占。</p>
</blockquote>
<h5 id="破坏环路等待条件"><a href="#破坏环路等待条件" class="headerlink" title="破坏环路等待条件"></a>破坏环路等待条件</h5><blockquote>
<p>保证每个进程在任何时刻只能占用一个资源如果要请求另外一个资源它必须先释放第一个资源。另一种是将所有资源统一编号，进程可以在任何时刻提出资源请求，但是请求必须按照资源编号顺序(升序)提出。</p>
</blockquote>
<h4 id="5-6-其他问题"><a href="#5-6-其他问题" class="headerlink" title="5.6 其他问题"></a>5.6 其他问题</h4><h5 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h5><h5 id="通讯死锁"><a href="#通讯死锁" class="headerlink" title="通讯死锁"></a>通讯死锁</h5><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要是把在重读 《现代操作系统》 中觉得有价值的东西，以 Tips 的形式记录下来。不可能面面俱到，但是如果有一定的基础应该是会回想起很多知识的。具体解释将会以链接形式补充。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://fitzeng.org/tags/C-C/"/>
    
      <category term="OS" scheme="http://fitzeng.org/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Why Marvel ?</title>
    <link href="http://fitzeng.org/2017/08/03/WhyMarvel/"/>
    <id>http://fitzeng.org/2017/08/03/WhyMarvel/</id>
    <published>2017-08-02T16:00:00.000Z</published>
    <updated>2017-08-04T09:21:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>先给自己挖个坑, 记录一下从 12 - 17 这五年间的点点滴滴.很久之前就很想写写自己心中的 Marvel. 人总得有些爱好是与理想相关的, 不是吗?</p>
</blockquote>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;先给自己挖个坑, 记录一下从 12 - 17 这五年间的点点滴滴.很久之前就很想写写自己心中的 Marvel. 人总得有些爱好是与理想相关的, 不是吗?&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Life" scheme="http://fitzeng.org/tags/Life/"/>
    
      <category term="Marvel" scheme="http://fitzeng.org/tags/Marvel/"/>
    
  </entry>
  
</feed>
